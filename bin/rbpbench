#!/usr/bin/env python3

import argparse
import base64
import os
import re
import statistics
import sys
from itertools import combinations
from pandas import DataFrame
from scipy.stats import fisher_exact
from scipy.stats import mannwhitneyu
from rbpbench import benchlib
# from distutils.spawn import find_executable
# from typing import Optional
# import subprocess
# from scipy.stats import ks_2samp
# from scipy.stats import wilcoxon
# import benchlib
# import uuid


__version__ = "0.2"



################################################################################

def setup_argument_parser():
    """Setup argparse parser."""
    # Tool description text.
    help_description = """

    Evaluate CLIP-seq and other genomic region data using a comprehensive collection of known RBP binding motifs (RNA sequence + structure).
    RBPBench can be used for a variety of purposes, from RBP motif search in genomic regions, over motif co-occurrence analysis, 
    to benchmarking CLIP-seq peak callers.

    """

    # Define argument parser.
    p = argparse.ArgumentParser(#add_help=False,
                                prog="rbpbench",
                                description=help_description)

    # Tool version.
    p.add_argument("-v", "--version", action="version",
                   version="rbpbench v" + __version__)

    # Add subparsers.
    subparsers = p.add_subparsers(help='Program modes')

    """
    Search motifs mode.
    """
    p_s = subparsers.add_parser('search',
                                  help='Search motifs in genomic sites')
    p_s.set_defaults(which='search')
    # Add required arguments group.
    p_sm = p_s.add_argument_group("required arguments")
    # Required arguments for search.
    p_sm.add_argument("--in",
                   dest="in_sites",
                   type=str,
                   metavar='str',
                   required=True,
                   help="Genomic RBP binding sites (peak regions) file in BED format")
    p_sm.add_argument("--rbps",
                   dest="list_rbps",
                   type=str,
                   metavar='str',
                   nargs='+',
                   required=True,
                   help="List of RBP names to define RBP motifs used for search (--rbps rbp1 rbp2 .. ). To search with all available motifs, use --rbps ALL. NOTE: to search with user-provided motifs, set --rbps USER and provide --user-meme-xml and/or --user-cm")
    p_sm.add_argument("--genome",
                   dest="in_genome",
                   type=str,
                   metavar='str',
                   required = True,
                   help = "Genomic sequences file (currently supported formats: FASTA)")
    p_sm.add_argument("--out",
                   dest="out_folder",
                   type=str,
                   metavar='str',
                   required=True,
                   help="Results output folder")
    # Optional arguments for search.
    p_s.add_argument("--data-id",
                   dest="data_id",
                   type=str,
                   metavar='str',
                   default = "data_id",
                   help="Dataset ID to describe dataset, e.g. --data-id PUM2_eCLIP_K562, used in output tables and for generating the comparison reports (rbpbench compare)")
    p_s.add_argument("--method-id",
                   dest="method_id",
                   type=str,
                   metavar='str',
                   default = "method_id",
                   help="Method ID to describe peak calling method, e.g. --method-id clipper_idr, used in output tables and for generating the comparison reports (rbpbench compare)")
    p_s.add_argument("--run-id",
                   dest="run_id",
                   type=str,
                   metavar='str',
                   default = "run_id",
                   help="Run ID to describe rbpbench search job, e.g. --run-id RBP1_eCLIP_tool1, used in output tables and reports")
    p_s.add_argument("--user-rbp-id",
                   dest="user_rbp_id",
                   type=str,
                   metavar='str',
                   default = False,
                   help = "Provide RBP ID belonging to provided sequence or structure motif(s) (mandatory for --rbps USER)")
    p_s.add_argument("--user-meme-xml",
                   dest="user_meme_xml",
                   type=str,
                   metavar='str',
                   default = False,
                   help = "Provide MEME XML file containing sequence motif(s) to be used for the run (needs --rbps USER)")
    p_s.add_argument("--user-cm",
                   dest="user_cm",
                   type=str,
                   metavar='str',
                   default = False,
                   help = "Provide covariance model (.cm) file containing covariance model(s) to be used for the run (needs --rbps USER)")
    p_s.add_argument("--ext",
                   dest="ext_up_down",
                   type=str,
                   metavar='str',
                   default="0",
                   help="Up- and downstream extension of --in sites in nucleotides (nt). Set e.g. --ext 30 for 30 nt on both sides, or --ext 20,10 for different up- and downstream extension (default: 0)")
    p_s.add_argument("--motif-db",
                   dest="motif_db",
                   type=int,
                   default=1,
                   choices=[1, 2, 3],
                   help="Motif database to use. 1: human RBP motifs full (259 RBPs, 605 motifs, human_v0.1), 2: human RBP motifs full (low frequencies not rounded, human_v0.1_no_round), 3: human RBP motifs eCLIP (107 RBPs, 316 motifs, human_eclip_v0.1) (default: 1)")
    p_s.add_argument("--fimo-nt-freqs",
                   dest="fimo_nt_freqs",
                   type=str,
                   metavar='str',
                   default = False,
                   help = "Provide FIMO nucleotide frequencies (FIMO option: --bifile) file (default: use internal frequencies file optimized for human transcripts)")
    p_s.add_argument("--fimo-pval",
                   dest="fimo_pval",
                   type=float,
                   metavar='float',
                   default=0.001,
                   help="FIMO p-value threshold (FIMO option: --thresh) (default: 0.001)")
    p_s.add_argument("--bed-score-col",
                   dest="bed_score_col",
                   type=int,
                   metavar='int',
                   default=5,
                   help="--in BED score column used for p-value calculations. BED score can be e.g. log2 fold change or -log10 p-value of the region (default: 5)")
    p_s.add_argument("--unstranded",
                   dest="unstranded",
                   default = False,
                   action = "store_true",
                   help = "Set if --in BED regions are NOT strand-specific, i.e., to look for motifs on both strands of the provided regions. Note that the two strands of a region will still be counted as one region (change with --unstranded-ct) (default: False)")
    p_s.add_argument("--unstranded-ct",
                   dest="unstranded_ct",
                   default = False,
                   action = "store_true",
                   help = "Count each --in region twice for RBP hit statistics when --unstranded is enabled. By default, two strands of one region are counted as one region for RBP hit statistics")
    p_s.add_argument("--report",
                   dest="report",
                   default = False,
                   action = "store_true",
                   help = "Generate an .html report containing RBP co-occurrence / correlation statistics and plots (default: False)")
    p_s.add_argument("--plot-motifs",
                   dest="plot_motifs",
                   default = False,
                   action = "store_true",
                   help = "Visualize selected sequence motifs, by outputting sequence logos and motif hit statistics into a separate .html file (default: False)")

    """
    Batch mode.
    """
    p_b = subparsers.add_parser('batch',
                                  help='Find motifs on > 1 dataset')
    p_b.set_defaults(which='batch')
    # Add required arguments group.
    p_bm = p_b.add_argument_group("required arguments")
    # Required arguments for batch.
    p_bm.add_argument("--bed",
                   dest="bed_files",
                   type=str,
                   metavar='str',
                   nargs='+',
                   required=True,
                   help="Provide folder with BED files (e.g. --bed clipper_bed) OR list of BED files to search for motifs. If folder, RBP IDs should be part of BED file names, like: RBP1_...bed, RBP2_...bed. Alternatively provide BED files and define RBP IDs with --rbp-list")
    p_bm.add_argument("--genome",
                   dest="in_genome",
                   type=str,
                   metavar='str',
                   required = True,
                   help = "Genomic sequences file (currently supported formats: FASTA)")
    p_bm.add_argument("--out",
                   dest="out_folder",
                   type=str,
                   metavar='str',
                   required=True,
                   help="Batch job results output folder")
    # Optional arguments for batch.
    p_b.add_argument("--rbp-list",
                   dest="list_rbp_ids",
                   type=str,
                   metavar='str',
                   nargs='+',
                   help="List of RBP names to define RBP motifs used for search. One --rbp-list RBP ID for each --bed BED file (NOTE: order needs to correspond to --bed-list)")
    p_b.add_argument("--data-list",
                   dest="list_data_ids",
                   type=str,
                   metavar='str',
                   nargs='+',
                   help="List of data IDs to describe datasets given by -bed-list (NOTE: order needs to correspond to --bed order). Alternatively, use --data-id to set method for all datasets")
    p_b.add_argument("--data-id",
                   dest="data_id",
                   type=str,
                   metavar='str',
                   default = "data_id",
                   help="Data ID to describe data for given datasets, e.g. --method-id k562_eclip, used in output tables and for generating the comparison reports (rbpbench compare)")
    p_b.add_argument("--method-list",
                   dest="list_method_ids",
                   type=str,
                   metavar='str',
                   nargs='+',
                   help="List of method IDs to describe datasets given by -bed-list (NOTE: order needs to correspond to --bed order). Alternatively, use --method-id to set method for all datasets")
    p_b.add_argument("--method-id",
                   dest="method_id",
                   type=str,
                   metavar='str',
                   default = "method_id",
                   help="Method ID to describe peak calling method for given datasets, e.g. --method-id clipper_idr, used in output tables and for generating the comparison reports (rbpbench compare)")
    p_b.add_argument("--run-id",
                   dest="run_id",
                   type=str,
                   metavar='str',
                   default = "run_id",
                   help="Run ID to describe rbpbench search job, e.g. --run-id RBP1_eCLIP_tool1, used in output tables and reports")
    p_b.add_argument("--ext",
                   dest="ext_up_down",
                   type=str,
                   metavar='str',
                   default="0",
                   help="Up- and downstream extension of --in sites in nucleotides (nt). Set e.g. --ext 30 for 30 nt on both sides, or --ext 20,10 for different up- and downstream extension (default: 0)")
    p_b.add_argument("--motif-db",
                   dest="motif_db",
                   type=int,
                   default=1,
                   choices=[1, 2, 3],
                   help="Motif database to use. 1: human RBP motifs full (259 RBPs, 605 motifs, human_v0.1), 2: human RBP motifs full (low frequencies not rounded, human_v0.1_no_round), 3: human RBP motifs eCLIP (107 RBPs, 316 motifs, human_eclip_v0.1) (default: 1)")
    p_b.add_argument("--fimo-nt-freqs",
                   dest="fimo_nt_freqs",
                   type=str,
                   metavar='str',
                   default = False,
                   help = "Provide FIMO nucleotide frequencies (FIMO option: --bifile) file (default: use internal frequencies file optimized for human transcripts)")
    p_b.add_argument("--fimo-pval",
                   dest="fimo_pval",
                   type=float,
                   metavar='float',
                   default=0.001,
                   help="FIMO p-value threshold (FIMO option: --thresh) (default: 0.001)")
    p_b.add_argument("--bed-score-col",
                   dest="bed_score_col",
                   type=int,
                   metavar='int',
                   default=5,
                   help="--in BED score column used for p-value calculations. BED score can be e.g. log2 fold change or -log10 p-value of the region (default: 5)")
    p_b.add_argument("--unstranded",
                   dest="unstranded",
                   default = False,
                   action = "store_true",
                   help = "Set if --in BED regions are NOT strand-specific, i.e., to look for motifs on both strands of the provided regions. Note that the two strands of a region will still be counted as one region (change with --unstranded-ct) (default: False)")
    p_b.add_argument("--unstranded-ct",
                   dest="unstranded_ct",
                   default = False,
                   action = "store_true",
                   help = "Count each --in region twice for RBP hit statistics when --unstranded is enabled. By default, two strands of one region are counted as one region for RBP hit statistics")

    """
    Optimal extension mode.
    """
    p_oe = subparsers.add_parser('optex',
                                  help='Investigate optimal extension')
    p_oe.set_defaults(which='optex')
    # Add required arguments group.
    p_oem = p_oe.add_argument_group("required arguments")
    # Required arguments.
    p_oem.add_argument("--in",
                   dest="in_sites",
                   type=str,
                   metavar='str',
                   required=True,
                   help="Genomic RBP binding sites (peak regions) file in BED format (also positives + negatives)")
    p_oem.add_argument("--rbp-id",
                   dest="rbp_id",
                   type=str,
                   metavar='str',
                   required=True,
                   help = "Provide RBP ID to define RBP motifs used for search")
    p_oem.add_argument("--genome",
                   dest="in_genome",
                   type=str,
                   metavar='str',
                   required = True,
                   help = "Genomic sequences file (currently supported formats: FASTA)")
    # Optional arguments.
    p_oe.add_argument("--user-meme-xml",
                   dest="user_meme_xml",
                   type=str,
                   metavar='str',
                   default = False,
                   help = "Provide MEME XML file containing sequence motif(s) to be used as search motifs")
    p_oe.add_argument("--user-cm",
                   dest="user_cm",
                   type=str,
                   metavar='str',
                   default = False,
                   help = "Provide covariance model (.cm) file containing covariance model(s) to be used as search motifs")
    p_oe.add_argument("--motif-db",
                   dest="motif_db",
                   type=int,
                   default=1,
                   choices=[1, 2, 3],
                   help="Motif database to use. 1: human RBP motifs full (259 RBPs, 605 motifs, human_v0.1), 2: human RBP motifs full (low frequencies not rounded, human_v0.1_no_round), 3: human RBP motifs eCLIP (107 RBPs, 316 motifs, human_eclip_v0.1) (default: 1)")
    p_oe.add_argument("--fimo-nt-freqs",
                   dest="fimo_nt_freqs",
                   type=str,
                   metavar='str',
                   default = False,
                   help = "Provide FIMO nucleotide frequencies (FIMO option: --bifile) file (default: use internal frequencies file optimized for human transcripts)")
    p_oe.add_argument("--fimo-pval",
                   dest="fimo_pval",
                   type=float,
                   metavar='float',
                   default=0.001,
                   help="FIMO p-value threshold (FIMO option: --thresh) (default: 0.001)")
    p_oe.add_argument("--bed-score-col",
                   dest="bed_score_col",
                   type=int,
                   metavar='int',
                   default=5,
                   help="--in BED score column used for p-value calculations and finding optimal extension. BED score can be e.g. log2 fold change or -log10 p-value of the region (default: 5)")
    p_oe.add_argument("--ext-pval",
                   dest="ext_pval",
                   type=float,
                   metavar='float',
                   default=0.001,
                   help="Longest extension p-value (default: 0.05)")
    p_oe.add_argument("--ext-list",
                   dest="ext_list",
                   type=int,
                   metavar='int',
                   nargs='+',
                   help="List of extensions to test (e.g. --ext-list 0 10 20 30 40 50). Internally, all combinations will be tested")


    """
    Info mode.
    """
    p_i = subparsers.add_parser('info',
                                  help='Print out RBP IDs in database')
    p_i.set_defaults(which='info')
    # Optional arguments.
    p_i.add_argument("--motif-db",
                   dest="motif_db",
                   type=int,
                   default=1,
                   choices=[1, 2, 3],
                   help="Motif database to use. 1: human RBP motifs full (259 RBPs, 605 motifs, human_v0.1), 2: human RBP motifs full (low frequencies not rounded, human_v0.1_no_round), 3: human RBP motifs eCLIP (107 RBPs, 316 motifs, human_eclip_v0.1) (default: 1)")


    """
    Dist mode.
    """
    p_d = subparsers.add_parser('dist',
                                  help='Plot nt distribution at genomic positions')
    p_d.set_defaults(which='dist')
    # Add required arguments group.
    p_dm = p_d.add_argument_group("required arguments")
    # Required arguments.
    p_dm.add_argument("--in",
                   dest="in_sites",
                   type=str,
                   metavar='str',
                   required=True,
                   help="Genomic RBP binding sites (peak regions) file in BED format (can be single positions or extended regions). Use --cp-mode to define zero position for plotting")
    p_dm.add_argument("--genome",
                   dest="in_genome",
                   type=str,
                   metavar='str',
                   required = True,
                   help = "Genomic sequences file (currently supported formats: FASTA)")
    p_dm.add_argument("--out",
                   dest="out_folder",
                   type=str,
                   metavar='str',
                   required=True,
                   help="Distribution plot results output folder")
    # Optional arguments.
    p_d.add_argument("--cp-mode",
                   dest="cp_mode",
                   type=int,
                   default=1,
                   choices=[1, 2, 3],
                   help="Define which position of --in genomic sites to use as zero position for plotting. 1: upstream end position, 2: center position, 2: downstream end position (default: 1)")
    p_d.add_argument("--ext",
                   dest="ext_up_down",
                   type=int,
                   metavar='str',
                   default="10",
                   help="Up- and downstream extension of --in sites in nucleotides (nt). Set e.g. --ext 20 for 20 nt on both sides (default: 10)")
    p_d.add_argument("--plot-pdf",
                   dest="plot_pdf",
                   default = False,
                   action = "store_true",
                   help = "Plot .pdf (default: .png)")


    """
    Compare mode.
    """
    p_c = subparsers.add_parser('compare',
                                  help='Compare different search results')
    p_c.set_defaults(which='compare')
    # Add required arguments group.
    p_cm = p_c.add_argument_group("required arguments")
    # Required arguments.
    p_cm.add_argument("--in",
                   dest="data_in",
                   type=str,
                   metavar='str',
                   nargs='+',
                   required=True,
                   help="Supply motif search results data, either as folders (--out folders of rbpbench search or batch), or as files (both RBP and motif hit stats files needed!). Order of files does NOT matter")
    p_cm.add_argument("--out",
                   dest="out_folder",
                   type=str,
                   metavar='str',
                   required=True,
                   help="Comparison results output folder")
    return p


################################################################################

def specify_motif_db(motif_db_nr, db_path="./"):
    """
    Returns
    sequence motif database file
    structure motif database file
    motif database string

    motif_db_nr: motif database string
    1: human_v0.1
    2: human_v0.1_no_round
    3: human_eclip_v0.1

    catRAPID_omics_v2.0_6plus_motifs.meme
    catRAPID_omics_v2.0_6plus_motifs.weak_rounded.meme
    s6_refined_ic010_rounded_ENCODE_RBPs.meme

    """

    seq_motifs_db_file = db_path + "/catRAPID_omics_v2.0_6plus_motifs.weak_rounded.meme"
    str_motifs_db_file = db_path + "/str_motifs.cm"
    rbp2ids_file = db_path + "/rbp_motif2name_ids.full.txt"
    motif_db_str = "human_v0.1"
    if motif_db_nr == 2:
        seq_motifs_db_file = db_path + "/catRAPID_omics_v2.0_6plus_motifs.meme"
        motif_db_str = "human_v0.1_no_round"
    if motif_db_nr == 3:
        seq_motifs_db_file = db_path + "/s6_refined_ic010_rounded_ENCODE_RBPs.meme"
        rbp2ids_file = db_path + "/rbp_motif2name_ids.txt"
        motif_db_str = "human_eclip_v0.1"
    return seq_motifs_db_file, str_motifs_db_file, rbp2ids_file, motif_db_str


################################################################################

def main_search(args):
    """
    Search motifs.

    """

    print("Running for you in SEARCH mode ... ")


    assert os.path.exists(args.in_sites), "--in file \"%s\" not found" % (args.in_sites)
    # Check --in BED format.
    if not args.unstranded:
        benchlib.bed_check_format(args.in_sites)

    """
    Library path.
    """
    benchlib_path = os.path.dirname(benchlib.__file__)
    db_path = benchlib_path + "/content"

    """
    FIMO nt frequencies.
    """
    fimo_freqs_file = db_path + "/fimo_nt_freqs.txt"
    if args.fimo_nt_freqs:
        fimo_freqs_file = args.fimo_nt_freqs
    assert os.path.exists(fimo_freqs_file), "set FIMO nucleotide frequencies file \"%s\" not found" % (fimo_freqs_file)

    """
    Motif database.
    """
    seq_motifs_db_file, str_motifs_db_file, rbp2ids_file, motif_db_str = specify_motif_db(args.motif_db, 
                                                                            db_path=db_path)
    args.motif_db_str = motif_db_str

    """
    Get ID mappings

    name2ids_dic:
    RBP name -> motif IDs mapping
    id2type_dic:
    motif ID -> motif type (cm, meme_xml)
    id2org_dic:
    motif ID -> organism ID (so far only "human")

    """
    name2ids_dic, id2type_dic, id2org_dic = benchlib.get_rbp_id_mappings(rbp2ids_file)
    # Motif ID -> RBP name (== RBP ID) mapping.
    id2name_dic = {}
    for rbp_id in name2ids_dic:
        for motif_id in name2ids_dic[rbp_id]:
            id2name_dic[motif_id] = rbp_id

    """
    Get MEME XML database motif blocks dictionary.

    """
    seq_motif_blocks_dic = benchlib.read_in_xml_motifs(seq_motifs_db_file)
    for motif_id in seq_motif_blocks_dic:
        assert motif_id in id2name_dic, "MEME XML motif ID %s not found in prior mapping. Please contact developers!" %(motif_id)

    """
    Get covariance model database motif blocks dictionary.

    """
    str_motif_blocks_dic = benchlib.read_in_cm_blocks(str_motifs_db_file)
    for motif_id in str_motif_blocks_dic:
        assert motif_id in id2name_dic, "Covariance model accession ID %s not found in prior mapping. Please contact developers!" %(motif_id)

    # Remove special chars from run ID.
    args.data_id = benchlib.remove_special_chars_from_str(args.data_id)
    assert args.data_id, "empty string after removing special chars from --data-id. Please provide alphanumeric string for data ID (- or _ are okay as well)"
    args.method_id = benchlib.remove_special_chars_from_str(args.method_id)
    assert args.method_id, "empty string after removing special chars from --method-id. Please provide alphanumeric string for method ID (- or _ are okay as well)"
    # Run ID definition.
    run_id = "run_id"
    if args.run_id:
        run_id = benchlib.remove_special_chars_from_str(args.run_id)
        assert run_id, "empty string after removing special chars from --run-id. Please provide alphanumeric string for run ID (- or _ are okay as well)"
    # else:
    #     random_id = uuid.uuid4()
    #     run_id = str(random_id)

    # hash_len = max(len(run_id), len(args.data_id), len(args.method_id))
    # print("###################" + "#"*hash_len)
    print("Run ID:     ", run_id)
    print("Data ID:    ", args.data_id)
    print("Method ID:  ", args.method_id)
    # print("###################" + "#"*hash_len)

    """
    Output folders + files.

    """
    if not os.path.exists(args.out_folder):
        os.makedirs(args.out_folder)

    filtered_sites_bed = args.out_folder + "/in_sites.filtered.bed"
    filtered_sites_fa = args.out_folder + "/in_sites.filtered.fa"
    seq_motifs_xml = args.out_folder + "/seq_motifs.xml"
    str_motifs_cm = args.out_folder + "/str_motifs.cm"
    fimo_res_tsv = args.out_folder + "/fimo_results.tsv"
    cmsearch_res_txt = args.out_folder + "/cmsearch_results.txt"

    rbp_stats_out = args.out_folder + "/rbp_hit_stats.tsv"
    motif_stats_out = args.out_folder + "/motif_hit_stats.tsv"
    con_res_out_tsv = args.out_folder + "/contingency_table_results.tsv"
    settings_file = args.out_folder + "/settings.find_motifs.out"
    # Output unique motif hits.
    motif_hits_bed_out = args.out_folder + "/motif_hits.rbpbench_search.bed"

    # Temp files.
    # random_id = uuid.uuid1()
    # tmp_out_bed = args.out_folder + "/" + str(random_id) + ".filtered_in.bed"
    out_tmp_bed = args.out_folder + "/rbp_motif_hit_regions.tmp.bed"
    cmstat_tmp_out = args.out_folder + "/cmstat_out.tmp.txt"

    # Delete if existing folder.
    if os.path.exists(fimo_res_tsv):
        os.remove(fimo_res_tsv)
    if os.path.exists(cmsearch_res_txt):
        os.remove(cmsearch_res_txt)


    """
    Load RBP data based on --rbps (+ optionally USER data).

    """

    rbp_in_dic = {}
    for rbp_id in args.list_rbps:
        rbp_in_dic[rbp_id] = 1

    # RBPs for motif search.
    loaded_rbps_dic = {}

    # USER set?
    user_motifs = False
    user_rbp_id = False
    if "USER" in rbp_in_dic:
        user_motifs = True
    else:
        assert not args.user_meme_xml, "--user-meme-xml provided but --rbps USER not set. Please add USER to --rbps list to search for user-supplied motifs"
        assert not args.user_cm, "--user-cm provided but --rbps USER not set. Please add USER to --rbps list to search for user-supplied motifs"
        assert not args.user_rbp_id, "--user-rbp-id set but --rbps USER not set. Please add USER to --rbps list to search for user-supplied motifs"

    # If ALL set, load all RBPs (+ optinally USER).
    if "ALL" in rbp_in_dic:
        if len(rbp_in_dic) == 2:
            assert user_motifs, "set --rbps ALL, --rbps ALL USER, or individual RBPs (+ optinally USER) --rbps RBP1 RBP2 ... USER"
        if len(rbp_in_dic) > 2:
            assert False, "set --rbps ALL, --rbps ALL USER, or individual RBPs (+ optinally USER) --rbps RBP1 RBP2 ... USER"
        print("--rbps ALL selected. Loading all database motifs ... ")
        for rbp_id in name2ids_dic:
            loaded_rbps_dic[rbp_id] = motif_db_str

    else:
        # Load individual RBPs.
        for rbp_id in rbp_in_dic:
            if rbp_id != "USER":
                """
                Check if RBP ID in database.
                Suggest similar RBPs based on string similarity (edit distance).

                """
                if rbp_id not in name2ids_dic:
                    db_rbp_list = []
                    for db_rbp_id in name2ids_dic:
                        db_rbp_list.append(db_rbp_id)
                    pair_dist_dic = benchlib.calc_edit_dist_query_list(rbp_id, db_rbp_list)
                    max_c = 10
                    c = 0
                    suggested_rbps = []
                    for key, value in sorted(pair_dist_dic.items(), key=lambda item: item[1], reverse=False):
                        if c >= max_c:
                            break
                        c += 1
                        suggested_rbps.append(key)
                    suggested_rbps_str = ",".join(suggested_rbps)
                    assert False, "provided --rbps ID %s not in internal motif database (%s). Please provide RBP name present in database. Did you mean (any of) the following database ID(s) (top 10 hits based on string similarity): %s ?" %(rbp_id, motif_db_str, suggested_rbps_str)
                # assert rbp_id in name2ids_dic, "provided --rbps ID %s not in internal motif database. Please provide RBP name present in database" %(rbp_id)
                loaded_rbps_dic[rbp_id] = motif_db_str


    # Motif IDs for search.
    loaded_motif_ids_dic = {}
    for rbp_id in loaded_rbps_dic:
        for motif_id in name2ids_dic[rbp_id]:
            loaded_motif_ids_dic[motif_id] = motif_db_str

    """
    Check and load provided USER data.

    """

    if user_motifs:
        print("--rbps USER selected. Check + load provided USER motifs ... ")
        assert args.user_rbp_id, "--rbps USER demands --user-rbp-id to be set to connect the supplied motif(s) with an RBP ID"
        assert args.user_meme_xml or args.user_cm, "--rbps USER requires a provided sequence or structure motif file (via --user-meme-xml AND/OR --user-cm)"

        # Reformat user_rbp_id. 
        user_rbp_id = benchlib.remove_special_chars_from_str(args.user_rbp_id)
        assert user_rbp_id, "empty string after removing special chars from --user-rbp-id. Please provide alphanumeric string for RBP ID (- or _ are okay as well)"

        assert user_rbp_id not in loaded_rbps_dic, "user RBP ID %s already selected from database. Please deselect respective database RBP ID or provide unique user RBP ID via --user-rbp-id" %(user_rbp_id)
        loaded_rbps_dic[user_rbp_id] = "user"
        # In case user_rbp_id in database, reset motif IDs associated to user_rbp_id.
        name2ids_dic[user_rbp_id] = []
        print("RBP ID for user-supplied motifs:", user_rbp_id)

        user_seq_motif_blocks_dic = {}
        if args.user_meme_xml:
            assert os.path.exists(args.user_meme_xml), "--user-meme-xml file \"%s\" not found" % (args.user_meme_xml)
            user_seq_motif_blocks_dic = benchlib.read_in_xml_motifs(args.user_meme_xml, check=False)
            assert user_seq_motif_blocks_dic, "no motifs read in from provided --user-meme-xml. Make sure to supply sequence motifs in MEME XML format!"
            # Check if motif ID already loaded.
            for acc_id in user_seq_motif_blocks_dic:
                assert acc_id not in loaded_motif_ids_dic, "user-supplied MEME XML motif ID %s already selected, i.e., ID is already associated with selected database RBP %s. Please change user motif ID to a unique motif ID or deselect the respective RBP" %(acc_id, id2name_dic[acc_id])
                loaded_motif_ids_dic[acc_id] = "user"
                # Add user to database blocks (overwrite if same ID encountered).
                seq_motif_blocks_dic[acc_id] = user_seq_motif_blocks_dic[acc_id]
                name2ids_dic[user_rbp_id].append(acc_id)
                id2type_dic[acc_id] = "meme_xml"
                id2name_dic[acc_id] = user_rbp_id

        user_str_motif_blocks_dic = {}
        if args.user_cm:
            assert os.path.exists(args.user_cm), "--user-cm file \"%s\" not found" % (args.user_cm)
            # Check for valid format.
            acc_ids_dic = benchlib.check_cm_file(args.user_cm, cmstat_tmp_out, check=False)
            # Read in covariance model blocks.
            user_str_motif_blocks_dic = benchlib.read_in_cm_blocks(args.user_cm)
            for acc_id in acc_ids_dic:
                assert acc_id in user_str_motif_blocks_dic, "accession ID %s not in blocks dictionary. Please contact developers!" %(acc_id)
            # Check if motif ID already loaded.
            for acc_id in user_str_motif_blocks_dic:
                assert acc_id not in loaded_motif_ids_dic, "user-supplied covariance model accession (ACC) ID %s already selected, i.e., ID is already associated with selected database RBP %s. Please change to a unique accession ID or deselect the respective RBP" %(acc_id, id2name_dic[acc_id])
                loaded_motif_ids_dic[acc_id] = "user"
                # Add user to database blocks (overwrite if same ID encountered).
                str_motif_blocks_dic[acc_id] = user_str_motif_blocks_dic[acc_id]
                name2ids_dic[user_rbp_id].append(acc_id)
                id2type_dic[acc_id] = "cm"
                id2name_dic[acc_id] = user_rbp_id

    """
    Load RBP data, store in RBP() class.

    """

    # Store motif IDs for search.
    search_rbps_dic = {}
    seq_rbps_dic = {}
    str_rbps_dic = {}
    motif_id2idx_dic = {} # motif ID -> list index.
    args.internal_id = []

    for rbp_id in loaded_rbps_dic:
    
        internal_id = base64.urlsafe_b64encode(os.urandom(6)).decode()
        args.internal_id.append(internal_id)
        rbp = benchlib.RBP(rbp_id, internal_id)

        for motif_id in name2ids_dic[rbp_id]:
        
            assert motif_id in loaded_motif_ids_dic, "motif_id %s not in loaded_motif_ids_dic" %(motif_id)

            if id2type_dic[motif_id] == "meme_xml":
                rbp.seq_motif_ids.append(motif_id)
                motif_id2idx_dic[motif_id] = len(rbp.seq_motif_ids) - 1
                rbp.seq_motif_hits.append(0)
                seq_rbps_dic[rbp_id] = 1
            else:
                rbp.str_motif_ids.append(motif_id)
                motif_id2idx_dic[motif_id] = len(rbp.str_motif_ids) - 1
                rbp.str_motif_hits.append(0)
                str_rbps_dic[rbp_id] = 1

        search_rbps_dic[rbp_id] = rbp


    print("# of RBP IDs for search:    ", len(loaded_rbps_dic))
    print("# of motif IDs for search:  ", len(loaded_motif_ids_dic))

    """
    Get chromosome IDs from --genome.
    """
    print("Get --genome FASTA headers ... ")
    chr_ids_dic = benchlib.get_fasta_headers(args.in_genome)

    """
    Filter / extend --in genomic regions BED file.

    """

    # Process extension info.
    ext_parts = args.ext_up_down.split(",")
    c_ext_parts = len(ext_parts)
    ext_up = 0
    ext_down = 0
    if c_ext_parts == 1:
        ext_up = int(ext_parts[0])
        ext_down = int(ext_parts[0])
    elif c_ext_parts == 2:
        ext_up = int(ext_parts[0])
        ext_down = int(ext_parts[1]) 
    else:
        assert False, "invalid --ext argument provided (correct format: --ext 10 OR --ext 20,10)"

    # Unstranded option.
    if args.unstranded:
        print("WARNING: --unstranded enabled. Using both strands for each --in BED region ... ")
        if ext_up != ext_down:
            print("asymmetric --ext and --unstranded set. Extend plus strand and use corresponding minus strand ... ")

    # Filter / extend --in BED.
    print("Preprocess --in sites ... ")
    reg2sc_dic = {}
    reg_stats_dic = benchlib.bed_filter_extend_bed(args.in_sites, filtered_sites_bed,
                                          ext_up=ext_up,
                                          ext_down=ext_down,
                                          remove_dupl=True,
                                          reg2sc_dic=reg2sc_dic,
                                          score_col=args.bed_score_col,
                                          chr_ids_dic=chr_ids_dic,
                                          unstranded=args.unstranded)
    
    assert reg_stats_dic["c_out"], "no --in BED sites remain after chromosome ID filtering"

    """
    Calculate effective size of genomic regions.
    
    """
    print("Calculate effective genomic region size ... ")
    eff_reg_size = benchlib.get_uniq_gen_size(filtered_sites_bed)

    print("# --in regions pre-filtering:  ", reg_stats_dic["c_in"])
    print("# --in regions post-filtering: ", reg_stats_dic["c_out"])
    print("# regions with invalid chr_id: ", reg_stats_dic["c_chr_filter"])
    print("# duplicated regions removed:  ", reg_stats_dic["c_dupl_filter"])
    print("Called region length sum:      ", reg_stats_dic["reg_len_sum"])
    print("Effective region length sum:   ", eff_reg_size)

    """
    Get genomic region sequences from --genome.

    Output FASTA header format:
    >chr8:9772198-9772297(+)

    No need to convert sequences to uppercase, as FIMO works on both 
    lower- and uppercase (as long as DNA / RNA is set correct).

    """
    print("Extract sequences from --genome ... ")
    benchlib.bed_extract_sequences_from_fasta(filtered_sites_bed, 
                                              args.in_genome, filtered_sites_fa,
                                              print_warnings=True)


    """
    Get FASTA sequences and sequence lengths.
    """

    out_seqs_dic = benchlib.read_fasta_into_dic(filtered_sites_fa,
                                       dna=True,
                                       all_uc=True,
                                       id_check=True,
                                       empty_check=False,
                                       skip_n_seqs=False)

    assert out_seqs_dic, "no sequences extracted from FASTA file for --in BED sites. Make sure to use compatible FASTA/BED files!"

    # Effective number of regions used for motif search.
    c_regions = len(out_seqs_dic)
    """
    --unstranded option and not --unstranded-ct

    chr8:9772198-9772297(+)
    """
    if args.unstranded and not args.unstranded_ct:
        # Check if sequences are even.
        assert not len(out_seqs_dic) % 2, "# of --in regions should be an even number since --unstranded is set. Please contact developers"
        c_regions = len(out_seqs_dic) // 2
    
    # Called region size.
    called_reg_size = 0
    len_list = []
    for seq_id in out_seqs_dic:
        seq_len = len(out_seqs_dic[seq_id])
        called_reg_size += seq_len
        len_list.append(seq_len)

    # Length statistics.
    reg_len_median = statistics.median(len_list)
    reg_len_mean = statistics.mean(len_list)
    reg_len_mean = round(reg_len_mean, 2)
    reg_len_min = min(len_list)
    reg_len_max = max(len_list)

    """
    ====================================
    RUN SEQUENCE MOTIF SEARCH WITH FIMO.
    ====================================
    
    """
    fimo_hits_list = []
    call_dic = {}

    if seq_rbps_dic:

        """
        Print motifs to file.

        """

        print("Output motifs to XML ... ")
        out_str, c_added_motifs = benchlib.blocks_to_xml_string(seq_motif_blocks_dic, loaded_motif_ids_dic)

        benchlib.output_string_to_file(out_str, seq_motifs_xml)


        """
        Run FIMO on sequences + motifs.

        """

        print("Run FIMO ... ")
        benchlib.run_fast_fimo(filtered_sites_fa, seq_motifs_xml, fimo_res_tsv,
                    pval_thr=args.fimo_pval,
                    nt_freqs_file=fimo_freqs_file,
                    call_dic=call_dic,
                    params="--norc --verbosity 1 --skip-matched-sequence --text",
                    error_check=False)

        """
        Read in FIMO hits.

        """

        assert os.path.exists(fimo_res_tsv), "FIMO output file fimo.tsv %s does not exist! There must have been an error while running FIMO (invalid xml file provided?)" %(fimo_res_tsv)

        print("Read in FIMO results ... ")
        fimo_hits_list = benchlib.read_in_fimo_results(fimo_res_tsv)

        c_fimo_hits = len(fimo_hits_list)
        print("# of FIMO motif hits:", c_fimo_hits)


    """
    =========================================
    RUN STRUCTURE MOTIF SEARCH WITH CMSEARCH.
    =========================================

    """
    cmsearch_hits_list = []

    if str_rbps_dic:
        
        print("Output covariance models to .cm ... ")
        benchlib.output_cm_blocks_to_file(str_motif_blocks_dic, loaded_motif_ids_dic, str_motifs_cm)

        # Run cmsearch.
        print("Run cmsearch ... ")
        benchlib.run_cmsearch(filtered_sites_fa, str_motifs_cm, cmsearch_res_txt,
                        error_check=False,
                        call_dic=call_dic,
                        params="-g --tformat fasta --toponly --incT 1 -T 1 --default") # or add --anytrunc and remove --g
        # Read in hits.
        print("Read in cmsearch results ... ")
        cmsearch_hits_list, c_cms_hits = benchlib.read_in_cmsearch_results(cmsearch_res_txt, 
                                                                           check=True)

        print("# of cmsearch motif hits:", c_cms_hits)


    """
    Store for each RBP the regions with motif hits (and hit counts), using
    dictionary of dictionaries regions_with_motifs_dic.
    This tells us, how many input regions have motif hits, separated by RBP.
    Also store for each RBP the unique motif hit regions (and hit counts), using
    dictionary of dictionaries unique_motifs_dic.

    regions_with_motifs_dic:
        Dictionary of dictionaries, format:
        {rbp_id1 -> {'region1': motif_c_region1, 'region2': motif_c_region2}, rbp_id2 -> {'region1': motif_c_region1}}
    unique_motifs_dic:
        Dictionary of dictionaries, format:
        {rbp_id1 -> {'motif_region1': c_motif_region1, 'motif_region2': c_motif_region2}, rbp_id2 -> .. }

    """

    regions_with_motifs_dic = {}
    unique_motifs_dic = {}

    # Store regions with sequence motifs.
    for fh in fimo_hits_list:

        rbp_id = id2name_dic[fh.motif_id]

        if rbp_id in regions_with_motifs_dic:
            # fh.seq_name : FASTA header (== --in genomic sequence region).
            if fh.seq_name in regions_with_motifs_dic[rbp_id]:
                regions_with_motifs_dic[rbp_id][fh.seq_name] += 1
            else:
                regions_with_motifs_dic[rbp_id][fh.seq_name] = 1
        else:
            regions_with_motifs_dic[rbp_id] = {}
            regions_with_motifs_dic[rbp_id][fh.seq_name] = 1

        fh_str = repr(fh) # genomic motif region string.

        # Unique motif regions for each RBP.
        if rbp_id in unique_motifs_dic:
            if fh_str in unique_motifs_dic[rbp_id]:
                unique_motifs_dic[rbp_id][fh_str] += 1
            else:
                unique_motifs_dic[rbp_id][fh_str] = 1
        else:
            unique_motifs_dic[rbp_id] = {}
            unique_motifs_dic[rbp_id][fh_str] = 1

        # Output motif stats.


    # Store regions with structure motifs.
    for cmsh in cmsearch_hits_list:

        rbp_id = id2name_dic[cmsh.motif_id]

        if rbp_id in regions_with_motifs_dic:
            # cmsh.seq_name : FASTA header (== --in genomic sequence region).
            if cmsh.seq_name in regions_with_motifs_dic[rbp_id]:
                regions_with_motifs_dic[rbp_id][cmsh.seq_name] += 1
            else:
                regions_with_motifs_dic[rbp_id][cmsh.seq_name] = 1
        else:
            regions_with_motifs_dic[rbp_id] = {}
            regions_with_motifs_dic[rbp_id][cmsh.seq_name] = 1

        cmsh_str = repr(cmsh) # genomic motif region string.

        # Unique motif regions for each RBP.
        if rbp_id in unique_motifs_dic:
            if cmsh_str in unique_motifs_dic[rbp_id]:
                unique_motifs_dic[rbp_id][cmsh_str] += 1
            else:
                unique_motifs_dic[rbp_id][cmsh_str] = 1
        else:
            unique_motifs_dic[rbp_id] = {}
            unique_motifs_dic[rbp_id][cmsh_str] = 1

    """
    Store infos for each RBP in RBP class.

    search_rbps_dic[rbp_id] = rbp_class
    RBP class arguments:
            name: str,
            seq_motif_ids = None,
            str_motif_ids = None,
            c_hit_reg = 0, # # regions with motif hits.
            perc_hit_reg = 0.0, # % hit regions over all regions (i.e. how many input regions contain >= 1 RBP motif).
            c_motif_hits = 0, # # motif hits.
            c_uniq_motif_hits = 0, # # unique motif hits.
            c_uniq_motif_nts = 0, # # unique motif nucleotides.
            perc_uniq_motif_nts_eff_reg = 0.0, # % unique motif nts over effective region length.
            perc_uniq_motif_nts_cal_reg = 0.0, # % unique motif nts over called region length.
            uniq_motif_hits_eff_1000nt = 0.0, # unique motif hits per effective 1000 nt.
            uniq_motif_hits_cal_1000nt = 0.0, # unique motif hits per called 1000 nt.
            ks_pval = 1.0, # Kolmogorov-Smirnov (KS) statistic p-value (are higher scoring sites enriched with motifs).
            ks_stat = 0.0,
            organism: Optional[str] = None

    Number of sequences for FIMO / cmsearch: 
    c_regions

    """
    # Set number of no-hit regions.
    for rbp_id in search_rbps_dic:
        search_rbps_dic[rbp_id].c_no_hit_reg = c_regions

    for rbp_id in regions_with_motifs_dic:
        # number of --in regions with RBP motif hits.
        c_hit_reg = len(regions_with_motifs_dic[rbp_id])
        # Cont hit regions if --unstranded and not --unstranded-ct.
        if args.unstranded and not args.unstranded_ct:
            c_hit_reg = 0
            seen_ids_dic = {}
            for seq_id in regions_with_motifs_dic[rbp_id]:
                core_id = benchlib.reg_get_core_id(seq_id)
                if core_id not in seen_ids_dic:
                    c_hit_reg += 1
                    seen_ids_dic[core_id] = 1

        # number of motif hits on --in regions in total.
        c_motif_hits = 0
        for reg_id in regions_with_motifs_dic[rbp_id]:
            c_motif_hits += regions_with_motifs_dic[rbp_id][reg_id]
        search_rbps_dic[rbp_id].c_hit_reg = c_hit_reg
        search_rbps_dic[rbp_id].c_no_hit_reg = c_regions - c_hit_reg
        search_rbps_dic[rbp_id].c_motif_hits = c_motif_hits

        # % hit regions over all regions (i.e. how many input regions contain >= 1 RBP motif).
        search_rbps_dic[rbp_id].perc_hit_reg = (search_rbps_dic[rbp_id].c_hit_reg / c_regions) * 100

    """
    Get unique motif hits.

    unique_motifs_dic:
        Dictionary of dictionaries, format:
        {rbp_id1 -> {'motif_region1': c_motif_region1, 'motif_region2': c_motif_region2}, rbp_id2 -> .. }
    """

    for rbp_id in unique_motifs_dic:
        c_uniq_motif_hits = len(unique_motifs_dic[rbp_id])
        search_rbps_dic[rbp_id].c_uniq_motif_hits = c_uniq_motif_hits
        # Store individual motif unique hits.
        for motif_str_repr in unique_motifs_dic[rbp_id]:
            motif_id = benchlib.get_motif_id_from_str_repr(motif_str_repr)
            idx = motif_id2idx_dic[motif_id]
            if id2type_dic[motif_id] == "meme_xml":
                search_rbps_dic[rbp_id].seq_motif_hits[idx] += 1
            else:
                search_rbps_dic[rbp_id].str_motif_hits[idx] += 1

    """
    Number of motif nucleotides over called + effective region size.

    """

    print("Calculate effective motif region sizes for each RBP ... ")
    for rbp_id in unique_motifs_dic:
        # Ouput unique motif hit regions (sequence or structure) to BED for RBP rbp_id.
        benchlib.output_motif_hits_to_bed(rbp_id, unique_motifs_dic, out_tmp_bed,
                                 one_based_start=True)
        # Calculate effective motif region size.
        eff_motif_reg_size = benchlib.get_uniq_gen_size(out_tmp_bed)

        # Number of unique motif nucleotides.
        search_rbps_dic[rbp_id].c_uniq_motif_nts = eff_motif_reg_size
        # % unique motif nts over effective region length.
        search_rbps_dic[rbp_id].perc_uniq_motif_nts_eff_reg = (eff_motif_reg_size / eff_reg_size) * 100
        # % unique motif nts over called region length.
        search_rbps_dic[rbp_id].perc_uniq_motif_nts_cal_reg = (eff_motif_reg_size / called_reg_size) * 100
        # Number of unique motif hits per effective 1000 nt.
        search_rbps_dic[rbp_id].uniq_motif_hits_eff_1000nt  = search_rbps_dic[rbp_id].c_uniq_motif_hits / (eff_reg_size / 1000)
        # Number of unique motif hits per called 1000 nt.
        search_rbps_dic[rbp_id].uniq_motif_hits_cal_1000nt  = search_rbps_dic[rbp_id].c_uniq_motif_hits / (called_reg_size / 1000)

    """
    # Print RBP object stats.
    for rbp_id in search_rbps_dic:
        print(search_rbps_dic[rbp_id].__dict__)

    """

    # print(search_rbps_dic["AGGF1"].__dict__)
    print("# --in regions for motif search:", c_regions)
    print("Called genomic region size:     ", called_reg_size)
    print("Effective genomic region size:  ", eff_reg_size)


    """
    Some motif enrichment tests.

    Kolmogorov-Smirnov test:
    conda install -c conda-forge scipy
    from scipy.stats import ks_2samp
    scipy.stats.ks_2samp()
    https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.ks_2samp.html
    Performs the two-sample Kolmogorov-Smirnov test for goodness of fit.    
    This test compares the underlying continuous distributions F(x) and G(x) of 
    two independent samples. See Notes for a description of the available null 
    and alternative hypotheses.

    Changing log2 FC to FC results in same p-values ...

    alternative: two-sided, greater, less
    
    Alternatively:
    Wilcoxon signed-rank test:
    https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.wilcoxon.html
    alternative: two-sided, greater, less
    This however needs same input sizes (x,y)
    Alternatively, use Wilcoxon rank-sum test (Mann-Whitney U test)

    
    """

    # print("Calculate Kolmogorov-Smirnov (KS) statistics ... ")
    print("Calculate Wilcoxon rank-sum test statistics ... ")

    # Check if all scores same (e.g. 0).
    reg_scores_dic = {}
    for reg_id in reg2sc_dic:
        reg_scores_dic[reg2sc_dic[reg_id]] = 1
    if len(reg_scores_dic) == 1:
        print("WARNING: all site scores identical. Reported p-values meaningless! (i.e., equal 1.0)")

    wc_pval_dic = {}
    for rbp_id in regions_with_motifs_dic:
        hit_reg_scores = []
        non_hit_reg_scores = []
        seen_ids_dic = {}
        # CHECK?
        for reg_id in reg2sc_dic:
            reg_sc = reg2sc_dic[reg_id] # float value.

            # If --unstranded, count regions only once as hit or no hit.
            if args.unstranded and not args.unstranded_ct:
                core_id = benchlib.reg_get_core_id(reg_id)
                reg_id1 = core_id + "(+)"
                reg_id2 = core_id + "(-)"
                if core_id not in seen_ids_dic:
                    if reg_id1 in regions_with_motifs_dic[rbp_id] or reg_id2 in regions_with_motifs_dic[rbp_id]:
                        hit_reg_scores.append(reg_sc)
                    else:
                        non_hit_reg_scores.append(reg_sc)
                    seen_ids_dic[core_id] = 1

            else:
                if reg_id in regions_with_motifs_dic[rbp_id]:
                    hit_reg_scores.append(reg_sc)
                else:
                    non_hit_reg_scores.append(reg_sc)

        # print("rbp_id:", rbp_id)
        # print("hit_reg_scores:", hit_reg_scores)
        # print("non_hit_reg_scores:", non_hit_reg_scores)
        # print("# hit regions:    ", len(hit_reg_scores))
        # print("# non-hit regions:", len(non_hit_reg_scores))

        # Calculate the KS statistic and p-value
        # ks_stat, ks_pval = ks_2samp(hit_reg_scores, non_hit_reg_scores, alternative="less")

        wc_pval = 1.0
        # In case no regions without motif hits.
        if not non_hit_reg_scores:
            print("WARNING: all input regions contain %s motifs. Adding dummy scores (median) ... " %(rbp_id))
            dummy_val = statistics.median(hit_reg_scores)
            hit_reg_scores.append(dummy_val)
            non_hit_reg_scores.append(dummy_val)

        # Wilcoxon rank-sum test (Mann-Whitney U test).
        if unique_motifs_dic[rbp_id]:
            wc_stat, wc_pval = mannwhitneyu(hit_reg_scores, non_hit_reg_scores, alternative="greater")
            # wc_stat_less, wc_pval_less = mannwhitneyu(hit_reg_scores, non_hit_reg_scores, alternative="less")

            #print("hit_reg_scores:", hit_reg_scores)
            #print("non_hit_reg_scores:", non_hit_reg_scores)
            # search_rbps_dic[rbp_id].ks_pval = ks_pval
            search_rbps_dic[rbp_id].wc_pval = wc_pval
            # search_rbps_dic[rbp_id].wc_pval_less = wc_pval_less
            wc_pval_dic[rbp_id] = wc_pval

        # print("KS p-value (%s):" %(rbp_id), p_value)


    # Print out RBPs sorted by Wilcoxon p-value.
    sorted_wc_pval_dic = dict(sorted(wc_pval_dic.items(), key=lambda item: item[1], reverse=False))
    print("Compact hit stats (RBP ID, # unique hits, Wilcoxon p-value):")
    for rbp_id, p_value in sorted_wc_pval_dic.items():
        # print("KS p-value (%s):" %(rbp_id), p_value)
        # print(rbp_id, ":", p_value)
        c_hits = search_rbps_dic[rbp_id].c_uniq_motif_hits
        # ks_pval = search_rbps_dic[rbp_id].ks_pval
        # wc_pval_less = search_rbps_dic[rbp_id].wc_pval_less
        # print("RBP:", rbp_id, "# hits:", c_uniq_motif_hits, "KS p-value:", p_value)
        # print("%s\t%i\t%s\t%s" %(rbp_id, c_hits, str(p_value), str(wc_pval_less)))
        print("%s\t%i\t%s" %(rbp_id, c_hits, str(p_value)))
    print("")
    """
    Output RBP hit stats (ie one row per RBP).

    Output clowns:
    rbp_id
    c_regions
    called_reg_size
    effective_reg_size
    c_reg_with_hits
    perc_reg_with_hits
    c_motif_hits
    c_uniq_motif_hits
    c_uniq_motif_nts
    perc_uniq_motif_nts_cal_reg
    perc_uniq_motif_nts_eff_reg
    uniq_motif_hits_cal_1000nt
    uniq_motif_hits_eff_1000nt
    wc_pval
    seq_motif_ids
    seq_motif_hits
    str_motif_ids
    str_motif_hits

    """

    rbp_list = []

    OUTSTATS = open(rbp_stats_out, "w")
    rbp_stats_header = "data_id\tmethod_id\trun_id\tmotif_db\trbp_id\tc_regions\tmean_reg_len\tmedian_reg_len\tmin_reg_len\tmax_reg_len\t"
    rbp_stats_header += "called_reg_size\teffective_reg_size\tc_reg_with_hits\tperc_reg_with_hits\t"
    rbp_stats_header += "c_motif_hits\tc_uniq_motif_hits\tc_uniq_motif_nts\tperc_uniq_motif_nts_cal_reg\tperc_uniq_motif_nts_eff_reg\tuniq_motif_hits_cal_1000nt\t"
    rbp_stats_header += "uniq_motif_hits_eff_1000nt\twc_pval\tseq_motif_ids\tseq_motif_hits\tstr_motif_ids\tstr_motif_hits\tinternal_id\n"
    OUTSTATS.write(rbp_stats_header)

    for rbp_id in search_rbps_dic:

        # print(search_rbps_dic[rbp_id].__dict__)
        rbp_list.append(rbp_id)

        motif_db_out = loaded_rbps_dic[rbp_id]

        c_reg_with_hits = search_rbps_dic[rbp_id].c_hit_reg
        perc_reg_with_hits = search_rbps_dic[rbp_id].perc_hit_reg
        c_motif_hits = search_rbps_dic[rbp_id].c_motif_hits
        c_uniq_motif_hits = search_rbps_dic[rbp_id].c_uniq_motif_hits
        c_uniq_motif_nts = search_rbps_dic[rbp_id].c_uniq_motif_nts
        perc_uniq_motif_nts_cal_reg = search_rbps_dic[rbp_id].perc_uniq_motif_nts_cal_reg
        perc_uniq_motif_nts_eff_reg = search_rbps_dic[rbp_id].perc_uniq_motif_nts_eff_reg
        uniq_motif_hits_cal_1000nt = search_rbps_dic[rbp_id].uniq_motif_hits_cal_1000nt
        uniq_motif_hits_eff_1000nt = search_rbps_dic[rbp_id].uniq_motif_hits_eff_1000nt
        wc_pval = search_rbps_dic[rbp_id].wc_pval
        internal_id = search_rbps_dic[rbp_id].internal_id

        seq_motif_hits = ",".join(str(hc) for hc in search_rbps_dic[rbp_id].seq_motif_hits)
        str_motif_hits = ",".join(str(hc) for hc in search_rbps_dic[rbp_id].str_motif_hits)
        seq_motif_ids = ",".join(search_rbps_dic[rbp_id].seq_motif_ids)
        str_motif_ids = ",".join(search_rbps_dic[rbp_id].str_motif_ids)
        if not seq_motif_hits:
            seq_motif_hits = "-"
        if not str_motif_hits:
            str_motif_hits = "-"
        if not seq_motif_ids:
            seq_motif_ids = "-"
        if not str_motif_ids:
            str_motif_ids = "-"

        row_str = args.data_id + "\t"
        row_str += args.method_id + "\t"
        row_str += run_id + "\t"
        row_str += motif_db_out + "\t"
        row_str += rbp_id + "\t"

        row_str += str(c_regions) + "\t"

        row_str += str(reg_len_mean) + "\t"
        row_str += str(reg_len_median) + "\t"
        row_str += str(reg_len_min) + "\t"
        row_str += str(reg_len_max) + "\t"

        row_str += str(called_reg_size) + "\t"
        row_str += str(eff_reg_size) + "\t"

        row_str += str(c_reg_with_hits) + "\t"
        row_str += str(perc_reg_with_hits) + "\t"

        row_str += str(c_motif_hits) + "\t"
        row_str += str(c_uniq_motif_hits) + "\t"
        row_str += str(c_uniq_motif_nts) + "\t"
        row_str += str(perc_uniq_motif_nts_cal_reg) + "\t"
        row_str += str(perc_uniq_motif_nts_eff_reg) + "\t"
        row_str += str(uniq_motif_hits_cal_1000nt) + "\t"
        row_str += str(uniq_motif_hits_eff_1000nt) + "\t"
        row_str += str(wc_pval) + "\t"
        row_str += seq_motif_ids + "\t"
        row_str += seq_motif_hits + "\t"
        row_str += str_motif_ids + "\t"
        row_str += str_motif_hits + "\t"
        row_str += internal_id + "\n"

        OUTSTATS.write(row_str)

    OUTSTATS.close()

    """
    Region ID list.
    
    """
    reg_ids_list = []
    if args.unstranded and not args.unstranded_ct:
        for seq_id, seq in sorted(out_seqs_dic.items()):
            core_id = benchlib.reg_get_core_id(seq_id)
            reg_ids_list.append(core_id)
    else:
        for seq_id, seq in sorted(out_seqs_dic.items()):
            reg_ids_list.append(seq_id)


    """
    Store RBP binding information for each input region.
    Format region_rbp_binds_dic:
    region_id -> [False, True, False ... ] 
    with list number of RBP IDs (len_rbp_list), alphabetically sorted.

    """

    rbp_list.sort()
    len_rbp_list = len(rbp_list)
    region_rbp_binds_dic = {}
    # Store rbp_id -> for each region if hit: 1, else: 0, i.e.: [1,0,0,0,0]
    reg_hits_dic = {}
    add_count = False # Add # of motif hits in region or just add 1 (if False)

    # RBP ID to index mapping.
    rbp2idx_dic = {}
    idx2rbp_dic = {}
    for idx, rbp_id in enumerate(rbp_list):
        rbp2idx_dic[rbp_id] = idx
        idx2rbp_dic[idx] = rbp_id
        # Region has hits yes(1)/no(0).
        hit_list = []
        for reg_id in reg_ids_list:
            if args.unstranded and not args.unstranded_ct:
                reg_id1 = reg_id + "(+)"
                reg_id2 = reg_id + "(-)"
                if rbp_id in regions_with_motifs_dic and (reg_id1 in regions_with_motifs_dic[rbp_id] or reg_id2 in regions_with_motifs_dic[rbp_id]):
                    hit_list.append(1)
                else:
                    hit_list.append(0)
            else:
                if rbp_id in regions_with_motifs_dic and reg_id in regions_with_motifs_dic[rbp_id]:
                    if add_count:
                        hit_list.append(regions_with_motifs_dic[rbp_id][reg_id])
                    else:
                        hit_list.append(1)
                else:
                    hit_list.append(0)
        reg_hits_dic[rbp_id] = hit_list

    # Init region_rbp_binds_dic, over all regions.
    seen_ids_dic = {}
    for reg_id in reg2sc_dic:
        if args.unstranded and not args.unstranded_ct:
            core_id = benchlib.reg_get_core_id(reg_id)
            if core_id not in seen_ids_dic:
                region_rbp_binds_dic[core_id] = [False]*len_rbp_list
                seen_ids_dic[core_id] = 1

        else:
            region_rbp_binds_dic[reg_id] = [False]*len_rbp_list

    """
    Output motif region stats (1 row for each motif hit).
    Report ALL motif hits,
    plus report how many times one genomic motif hit occurs (uniq_count). 

    """

    OUTSTATS = open(motif_stats_out,"w")

    motif_stats_header = "data_id\tmethod_id\trun_id\tmotif_db\tregion_id\trbp_id\tmotif_id\tchr_id\tgen_s\tgen_e\tstrand\tregion_s\tregion_e\tregion_len\t"
    motif_stats_header += "uniq_count\tfimo_score\tfimo_pval\tcms_score\tcms_eval\tinternal_id\n"
    OUTSTATS.write(motif_stats_header)

    # Unique motif regions BED.
    motif_reg_dic = {}

    # hit_id = "%s:%s-%s(%s),%s" %(cols[7], cols[8], cols[9], cols[10], cols[6])

    for fh in fimo_hits_list:

        rbp_id = id2name_dic[fh.motif_id]
        region_id = fh.seq_name
        region_len = benchlib.get_length_from_seq_name(fh.seq_name)
        # genomic motif region string.
        fh_str = repr(fh) 
        uniq_count = unique_motifs_dic[rbp_id][fh_str]
        # Store binding info of RBP in region.
        rbp_idx = rbp2idx_dic[rbp_id]

        if args.unstranded and not args.unstranded_ct:
            core_id = benchlib.reg_get_core_id(region_id)
            region_rbp_binds_dic[core_id][rbp_idx] = True
        else:
            region_rbp_binds_dic[region_id][rbp_idx] = True

        motif_db_out = loaded_motif_ids_dic[fh.motif_id]

        internal_id = search_rbps_dic[rbp_id].internal_id

        # Store motif hit as BED.
        hit_id = "%s:%s-%s(%s),%s" %(fh.chr_id, str(fh.start), str(fh.end), fh.strand, fh.motif_id)
        if hit_id not in motif_reg_dic:
            bed_row = "%s\t%i\t%i\t%s,%s;%i;%s,%s\t0\t%s\t%s\t%s\t-1.0\t-1.0" %(fh.chr_id, fh.start-1, fh.end, rbp_id, fh.motif_id, uniq_count, args.method_id, args.data_id, fh.strand, str(fh.score), str(fh.pval))
            motif_reg_dic[hit_id] = bed_row

        row_str = args.data_id + "\t"
        row_str += args.method_id + "\t"
        row_str += run_id + "\t"
        row_str += motif_db_out + "\t"
        row_str += region_id + "\t"
        row_str += rbp_id + "\t"
        row_str += fh.motif_id + "\t"
        row_str += fh.chr_id + "\t"
        row_str += str(fh.start) + "\t"  # 1-based.
        row_str += str(fh.end) + "\t"
        row_str += fh.strand + "\t"
        row_str += str(fh.seq_s) + "\t"  # 1-based.
        row_str += str(fh.seq_e) + "\t"
        row_str += str(region_len) + "\t"
        row_str += str(uniq_count) + "\t"
        row_str += str(fh.score) + "\t"
        row_str += str(fh.pval) + "\t"
        row_str += "-\t"
        row_str += "-\t"
        row_str += internal_id + "\n"

        OUTSTATS.write(row_str)

    for cmsh in cmsearch_hits_list:

        rbp_id = id2name_dic[cmsh.motif_id]
        region_id = cmsh.seq_name
        region_len = benchlib.get_length_from_seq_name(cmsh.seq_name)
        # genomic motif region string.
        cmsh_str = repr(cmsh) 
        uniq_count = unique_motifs_dic[rbp_id][cmsh_str]
        # Store binding info of RBP in region.
        rbp_idx = rbp2idx_dic[rbp_id]

        if args.unstranded and not args.unstranded_ct:
            core_id = benchlib.reg_get_core_id(region_id)
            region_rbp_binds_dic[core_id][rbp_idx] = True
        else:
            region_rbp_binds_dic[region_id][rbp_idx] = True

        motif_db_out = loaded_motif_ids_dic[cmsh.motif_id]

        internal_id = search_rbps_dic[rbp_id].internal_id

        # Store motif hit as BED.
        hit_id = "%s:%s-%s(%s),%s" %(cmsh.chr_id, str(cmsh.start), str(cmsh.end), cmsh.strand, cmsh.motif_id)
        if hit_id not in motif_reg_dic:
            bed_row = "%s\t%i\t%i\t%s,%s;%i;%s,%s\t0\t%s\t%s\t%s\t-1.0\t-1.0" %(cmsh.chr_id, cmsh.start-1, cmsh.end, rbp_id, cmsh.motif_id, uniq_count, args.method_id, args.data_id, cmsh.strand, str(cmsh.score), str(cmsh.e_value))
            motif_reg_dic[hit_id] = bed_row

        row_str = args.data_id + "\t"
        row_str += args.method_id + "\t"
        row_str += run_id + "\t"
        row_str += motif_db_out + "\t"
        row_str += region_id + "\t"
        row_str += rbp_id + "\t"
        row_str += cmsh.motif_id + "\t"
        row_str += cmsh.chr_id + "\t"
        row_str += str(cmsh.start) + "\t"
        row_str += str(cmsh.end) + "\t"
        row_str += cmsh.strand + "\t"
        row_str += str(cmsh.seq_s) + "\t"
        row_str += str(cmsh.seq_e) + "\t"
        row_str += str(region_len) + "\t"
        row_str += str(uniq_count) + "\t"
        row_str += "-\t"
        row_str += "-\t"
        row_str += str(cmsh.score) + "\t"
        row_str += str(cmsh.e_value) + "\t"
        row_str += internal_id + "\n"
        #print("region_id:", region_id)
        #print("evalue:", cmsh.e_value)
        #print(row_str)

        OUTSTATS.write(row_str)

    OUTSTATS.close()

    """
    Output motif hits as BED.
    """

    OUTBED = open(motif_hits_bed_out,"w")
    for hit_id in motif_reg_dic:
        OUTBED.write("%s\n" %(motif_reg_dic[hit_id]))
    OUTBED.close()


    """
    Significance testing:
    Check for co-occurrences of motifs from different RBPs in regions.
    Use 2x2 contingency tables, and some test for significance,
    e.g. Fisher exact or Chi-squared

    region_rbp_binds_dic format:
    'chr20:62139082-62139128(-)': [False, False, False]
    ...
    rbp2idx_dic
    idx2rbp_dic

    from itertools import combinations
    Number of combinations (draw k from n elements, no order, no repetition)
    Binomialcoefficient: n over k, where n = #RBPs, and k = 2
    rbp_pairs = list(combinations(rbp_list, 2))

    make_contingency_table_2x2(region_labels_dic, idx1, idx2):
    https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.fisher_exact.html
                   List 1              Not in List 1
    List 2         A                   B
    Not in List 2  C                   D

    table = [[A, B], [C, D]]

    from scipy.stats import chi2_contingency
    stat, p, dof, expected = chi2_contingency(table)
    Note that chi2_contingency does not tolerate zero elements.

    """
    # Store p-values in 2d-list.
    pval_ll = [] # p-values (fisher exact).
    or_ll = [] # odds ratios.
    pval_cont_lll = []

    for rbp_id in rbp_list:
        pval_ll.append([1.0]*len_rbp_list)
        pval_cont_lll.append([]*len_rbp_list)
        #pval_cont_lll.append([["1.0","-", "-"]]*len_rbp_list)
        or_ll.append([0.0]*len_rbp_list)

    for i in range(len_rbp_list):
        for j in range(len_rbp_list):
            pval_cont_lll[i].append(["1.0","-", "-"])


    # Add p-values of 1.0 in diagonal.
    # for idx, rbp_id in enumerate(rbp_list):
    #     pval_ll[idx][idx] = 1.0
    #     pval_cont_lll[idx][idx] = 1.0

    rbp_pairs = list(combinations(rbp_list, 2))
    con_pval_dic = {}
    con_table_dic = {}
    pair_str_dic = {}

    # print("rbp2idx_dic:", rbp2idx_dic)
    # #print("region_rbp_binds_dic:", region_rbp_binds_dic)
    # print("len(region_rbp_binds_dic):", len(region_rbp_binds_dic))
    # true_c = 0
    # for reg_id in region_rbp_binds_dic:
    #     for label in region_rbp_binds_dic[reg_id]:
    #         if label:
    #             true_c += 1
    # print("# TRUEs:", true_c)

    c_regions_with_hits = 0
    for reg_id in region_rbp_binds_dic:
        reg_hit = False
        for label in region_rbp_binds_dic[reg_id]:
            if label:
                reg_hit = True
        if reg_hit:
            c_regions_with_hits += 1
    print("# regions with hits (all motifs):", c_regions_with_hits)

    print("Compute motif region co-occurrences between RBP pairs ... ")
    for pair in rbp_pairs:
        pair = list(pair)
        pair.sort()
        idx1 = rbp2idx_dic[pair[0]]
        idx2 = rbp2idx_dic[pair[1]]
        # pair_list = [pair[0], pair[1]]
        # pair_list.sort()
        pair_str = ",".join(pair)
        # pair_str_dic[pair_str] = [pair_list[0], pair_list[1]]
        pair_str_dic[pair_str] = [pair[0], pair[1]]

        table = benchlib.make_contingency_table_2x2(region_rbp_binds_dic, idx1, idx2)
        odds_ratio, p_value = fisher_exact(table, alternative="two-sided")

        # if p_value == 0:
        #     p_value = 2.2e-308
            # print("PVALUE ZERO! (%s, odds_ratio: %s)" %(str(p_value), str(odds_ratio)))
            # print("pair_str:", pair_str)
            # print("table_str:", table_str)

        con_pval_dic[pair_str] = p_value
        con_table_dic[pair_str] = table
        table_str = str(table)

        # print(pair_str, table_str, p_value)
        # print("Pair:", pair_str, "Odds ratio:", odds_ratio,"Fisher p-value:", p_value)
        pval_ll[idx1][idx2] = p_value
        pval_ll[idx2][idx1] = p_value
        pval_cont_lll[idx2][idx1][0] = str(p_value)
        pval_cont_lll[idx2][idx1][1] = pair_str
        pval_cont_lll[idx2][idx1][2] = table_str
        # pval_cont_lll[idx2][idx1][0] = str(p_value)
        # pval_cont_lll[idx2][idx1][1] = pair_str
        # pval_cont_lll[idx2][idx1][2] = table_str
        or_ll[idx1][idx2] = odds_ratio
        or_ll[idx2][idx1] = odds_ratio


    # Print out RBPs sorted by KS p-value.
    sorted_con_pval_dic = dict(sorted(con_pval_dic.items(), key=lambda item: item[1], reverse=False))

    print("Co-occurrence contigency table format: [A, B], [C, D]")
    print("A: RBP1 AND RBP2")
    print("B: NOT RBP1 AND RBP2")
    print("C: RBP1 AND NOT RBP2")
    print("D: NOT RBP1 AND NOT RBP2")
    print("Co-occurrence of motifs (RBP IDs (RBP1,RBP2), # hits, contingency table, Fisher p-value <=0.05):")
    c_reported = 0

    for pair_str, p_value in sorted_con_pval_dic.items():
        if p_value > 0.05:
            break
        c_reported += 1
        rbp1 = pair_str_dic[pair_str][0]
        rbp2 = pair_str_dic[pair_str][1]
        con_table = con_table_dic[pair_str]
        rbp1_hits = search_rbps_dic[rbp1].c_uniq_motif_hits
        rbp2_hits = search_rbps_dic[rbp2].c_uniq_motif_hits
        print("%s\t%i,%i\t%s\t%s" %(pair_str, rbp1_hits, rbp2_hits, str(con_table), str(p_value)))

    if not c_reported:
        print("NO SIGNIFICANT CO-OCCURRENCES FOUND!")
    print("")

    # Print table to file.
    benchlib.output_con_table_results(con_res_out_tsv, pval_ll, rbp_list)

    """
    Correlation.

    Setting add_count = True changes correlations a bit (use motif hit counts 
    instead of 1 for any number of hits)

    """

    if args.report:

        print("Calculate correlations ... ")
        # Correlation between RBPs dataframe.
        df = DataFrame(reg_hits_dic, columns=rbp_list)
        df_corr = df.corr(method='pearson')


        for i,rbp1 in enumerate(rbp_list):
            for j,rbp2 in enumerate(rbp_list):
                if j > i:
                    pval_ll[i][j] = None

        # Fisher p-value dataframe.
        df_pval = DataFrame(pval_ll, columns=rbp_list, index=rbp_list)

        # Write None to upper-diagonal entries.
        for i in range(len(rbp_list)):
            for j in range(len(rbp_list)):
                if j > i:
                    df_corr.iloc[i][j] = None

        for i in range(len(rbp_list)):
            for j in range(len(rbp_list)):
                if j > i:
                    df_pval.iloc[i][j] = None

        # print("df_pval:", df_pval)
        # Log transform p-values.
        benchlib.log_tf_df(df_pval, convert_zero_pv=True)
        # print("df_pval:", df_pval)


        # print("df:", df)
        # print("df.corr():", df.corr(method='pearson'))
        # print("reg_hits_dic[SLBP]:", reg_hits_dic["SLBP"])

        # Plot correlations.
        # motif_db
        # import plotly.express as px
        # fig = px.imshow(df_corr)
        # fig.show()


        html_report_out = args.out_folder + "/" + "report.rbpbench_search.html"
        plots_subfolder = "html_report_plots"
        benchlib_path = os.path.dirname(benchlib.__file__)

        benchlib.search_generate_html_report(df_corr, df_pval, pval_cont_lll,
                                         search_rbps_dic,
                                         fimo_hits_list, cmsearch_hits_list,
                                         id2name_dic, args.out_folder, 
                                         benchlib_path,
                                         html_report_out=html_report_out,
                                         plots_subfolder=plots_subfolder)


    """
    Motif plots and motif hit statistics HTML.

    """

    if args.plot_motifs:
        
        print("Generate motif plots HTML ... ")
        html_motif_plots_out = args.out_folder + "/" + "motif_plots.rbpbench_search.html"
        plots_subfolder = "html_motif_plots"
        benchlib_path = os.path.dirname(benchlib.__file__)

        benchlib.search_generate_html_motif_plots(search_rbps_dic, seq_motif_blocks_dic, 
                                         str_motif_blocks_dic, args.out_folder, 
                                         benchlib_path, loaded_motif_ids_dic,
                                         html_report_out=html_motif_plots_out,
                                         plots_subfolder=plots_subfolder)


    """
    Output parameter settings.

    """
    # Output mode settings.
    print("Output parameter settings ... ")
    SETOUT = open(settings_file, "w")
    for arg in vars(args):
        SETOUT.write("%s\t%s\n" %(arg, str(getattr(args, arg))))
    for call in call_dic:
        SETOUT.write("%s\t%s\n" %(call, call_dic[call]))
    SETOUT.close()

    """
    Take out the trash.

    """
    print("Delete .tmp files ... ")
    if os.path.exists(out_tmp_bed):
        os.remove(out_tmp_bed)
    if os.path.exists(cmstat_tmp_out):
        os.remove(cmstat_tmp_out)


    """
    Inform about outputs.

    """
    print("")
    print("OUTPUT FILES")
    print("============")
    print("")
    print("Run parameter settings:\n%s" %(settings_file))
    print("Co-occurrence p-values for each RBP pair .tsv:\n%s" %(con_res_out_tsv))
    print("Filtered input regions .bed:\n%s" %(filtered_sites_bed))
    print("Filtered input regions .fa:\n%s" %(filtered_sites_fa))
    print("Motif hits .bed:\n%s" %(motif_hits_bed_out))
    print("RBP hit stats .tsv:\n%s" %(rbp_stats_out))
    print("Motif hit stats .tsv:\n%s" %(motif_stats_out))
    if args.plot_motifs:
        print("Motif plots and hit statistics .html:\n%s" %(html_motif_plots_out))
    if args.report:
        print("Search report .html:\n%s" %(html_report_out))
    print("")


################################################################################

def main_batch(args):
    """
    Batch search motifs.

    """

    print("Running for you in BATCH mode ... ")


    """
    Check input --bed BED files.

    """
    bed_path = False
    bed_list = []

    if len(args.bed_files) == 1:
        if os.path.isdir(args.bed_files[0]):
            bed_path = args.bed_files[0]
            bed_files = benchlib.dir_get_files(bed_path, file_ending="bed")
            assert bed_files, "no BED files (.bed file extension expected) found in given --bed %s folder" %(bed_path)
            for bed_file in bed_files:
                bed_list.append(bed_file)
        elif os.path.isfile(args.bed_files[0]):
            bed_list.append(args.bed_files[0])
        else:
            assert False, "given --bed argument %s is not a file or a folder" %(args.bed_files[0])
    elif len(args.bed_files) > 1:
        for bed_file in args.bed_files:
            if os.path.isfile(bed_file):
                bed_list.append(bed_file)
            else:
                assert False, "given --bed argument %s is not a file. > 1 --bed argument was provided, so each element is expected to be a file" %(bed_file)
        # Demand RBP list to be provided.
        assert args.list_rbp_ids, "single BED files provided via --bed, but --rbp-list is not set. Please provide RBP IDs for each BED file in matching order"
    else:
        assert False, "no --bed arguments supplied"
    assert bed_list, "bed_list empty"

    """
    Check other list inputs and store.

    """

    rbp_ids_list = []
    if args.list_rbp_ids:
        assert not bed_path, "--rbp-list expects BED files provided in same order with --bed, not as BED folder"
        assert len(args.list_rbp_ids) == len(bed_list), "number of --rbp-list arguments != number of --bed arguments"
        for rbp_id in args.list_rbp_ids:
            # new_rbp_id = benchlib.remove_special_chars_from_str(rbp_id)
            # assert new_rbp_id, "empty string after removing special chars from --rbp-list argument %s. Please provide valid RBP ID (i.e., RBP ID from database)" %(rbp_id)
            rbp_ids_list.append(rbp_id)

    data_ids_list = []
    if args.list_data_ids:
        assert not bed_path, "--data-list expects BED files provided in same order with --bed, not as BED folder"
        assert len(args.list_data_ids) == len(bed_list), "number of --data-list arguments != number of --bed arguments"
        for data_id in args.list_data_ids:
            new_data_id = benchlib.remove_special_chars_from_str(data_id)
            assert new_data_id, "empty string after removing special chars from --data-list argument %s. Please provide alphanumeric string (- or _ are okay as well)" %(data_id)
            data_ids_list.append(new_data_id)
    else:
        args.data_id = benchlib.remove_special_chars_from_str(args.data_id)
        assert args.data_id, "empty string after removing special chars from --data-id. Please provide alphanumeric string for data ID (- or _ are okay as well)"

    method_ids_list = []
    if args.list_method_ids:
        assert not bed_path, "--method-list expects BED files provided in same order with --bed, not as BED folder"
        assert len(args.list_method_ids) == len(bed_list), "number of --method-list arguments != number of --bed arguments"
        for method_id in args.list_method_ids:
            new_method_id = benchlib.remove_special_chars_from_str(method_id)
            assert new_method_id, "empty string after removing special chars from --method-list argument %s. Please provide alphanumeric string (- or _ are okay as well)" %(method_id)
            method_ids_list.append(new_method_id)
    else:
        args.method_id = benchlib.remove_special_chars_from_str(args.method_id)
        assert args.method_id, "empty string after removing special chars from --method-id. Please provide alphanumeric string for method ID (- or _ are okay as well)"

    """
    Extracting RBP IDs from BED file names.

    """

    if not rbp_ids_list:
        print("No --rbp-list provided. Extracting RBP IDs from --bed file names ... ")

        for bed_file in bed_list:
            rbp_id = False
            if re.search(".+\.bed", bed_file):
                m = re.search("(.+)\.bed", bed_file)
                fn = m.group(1)
                fnp = fn.split("_")
                rbp_id = fnp[0]
            else:
                assert False, "BED file %s with invalid ending (.bed expected)" %(bed_file)
            assert rbp_id, "no RBP ID extracted from BED file name %s" %(bed_file)
            rbp_ids_list.append(rbp_id)

    assert rbp_ids_list, "no RBP IDs list after pre-processing"
    assert len(rbp_ids_list) == len(bed_list), "number of RBP IDs != number of --bed files"

    """
    Library path.
    """
    benchlib_path = os.path.dirname(benchlib.__file__)
    db_path = benchlib_path + "/content"


    """
    FIMO nt frequencies.
    """
    fimo_freqs_file = db_path + "/fimo_nt_freqs.txt" # CONDA2SET
    if args.fimo_nt_freqs:
        fimo_freqs_file = args.fimo_nt_freqs
    assert os.path.exists(fimo_freqs_file), "set FIMO nucleotide frequencies file \"%s\" not found" % (fimo_freqs_file)

    """
    Motif database.
    """
    seq_motifs_db_file, str_motifs_db_file, rbp2ids_file, motif_db_str = specify_motif_db(args.motif_db, 
                                                                            db_path=db_path)
    args.motif_db_str = motif_db_str


    """
    Get ID mappings

    name2ids_dic:
    RBP name -> motif IDs mapping
    id2type_dic:
    motif ID -> motif type (cm, meme_xml)
    id2org_dic:
    motif ID -> organism ID (so far only "human")

    """
    name2ids_dic, id2type_dic, id2org_dic = benchlib.get_rbp_id_mappings(rbp2ids_file)
    # Motif ID -> RBP name (== RBP ID) mapping.
    id2name_dic = {}
    for rbp_id in name2ids_dic:
        for motif_id in name2ids_dic[rbp_id]:
            id2name_dic[motif_id] = rbp_id


    """
    Get MEME XML database motif blocks dictionary.

    """
    seq_motif_blocks_dic = benchlib.read_in_xml_motifs(seq_motifs_db_file)
    for motif_id in seq_motif_blocks_dic:
        assert motif_id in id2name_dic, "MEME XML motif ID %s not found in prior mapping. Please contact developers!" %(motif_id)

    """
    Get covariance model database motif blocks dictionary.

    """
    str_motif_blocks_dic = benchlib.read_in_cm_blocks(str_motifs_db_file)
    for motif_id in str_motif_blocks_dic:
        assert motif_id in id2name_dic, "Covariance model accession ID %s not found in prior mapping. Please contact developers!" %(motif_id)

    """
    Check if RBP IDs are in database.

    """
    for rbp_id in rbp_ids_list:
        assert rbp_id in name2ids_dic, "given RBP ID \"%s\" not in motif database. Please provide valid RBP IDs (either via --rbp-list or as part of BED names if --bed folder is provided)" %(rbp_id)

    """
    Run ID definition.

    Use internal_id instead (to connect RBP and motif stats tables)
    import os
    import base64
    base64.urlsafe_b64encode(os.urandom(6)).decode()
    https://stackoverflow.com/questions/13484726/safe-enough-8-character-short-unique-random-string
    
    """

    run_id = "run_id"
    if args.run_id:
        run_id = benchlib.remove_special_chars_from_str(args.run_id)
        assert run_id, "empty string after removing special chars from --run-id. Please provide alphanumeric string for run ID (- or _ are okay as well)"
    # else:
    #     random_id = uuid.uuid4()
    #     run_id = str(random_id)
    print("Run ID:", run_id)

    """
    Output folders + files.

    """
    if not os.path.exists(args.out_folder):
        os.makedirs(args.out_folder)

    filtered_sites_bed = args.out_folder + "/in_sites.filtered.bed"
    filtered_sites_fa = args.out_folder + "/in_sites.filtered.fa"
    seq_motifs_xml = args.out_folder + "/seq_motifs.xml"
    str_motifs_cm = args.out_folder + "/str_motifs.cm"
    fimo_res_tsv = args.out_folder + "/fimo_results.tsv"
    cmsearch_res_txt = args.out_folder + "/cmsearch_results.txt"

    rbp_stats_out = args.out_folder + "/rbp_hit_stats.tsv"
    motif_stats_out = args.out_folder + "/motif_hit_stats.tsv"
    con_res_out_tsv = args.out_folder + "/contingency_table_results.tsv"
    settings_file = args.out_folder + "/settings.find_motifs.out"

    # Output unique motif hits.
    motif_hits_bed_out = args.out_folder + "/motif_hits.rbpbench_batch.bed"

    # Temp files.
    # random_id = uuid.uuid1()
    # tmp_out_bed = args.out_folder + "/" + str(random_id) + ".filtered_in.bed"
    out_tmp_bed = args.out_folder + "/rbp_motif_hit_regions.tmp.bed"
    cmstat_tmp_out = args.out_folder + "/cmstat_out.tmp.txt"

    # Delete if existing folder.
    if os.path.exists(fimo_res_tsv):
        os.remove(fimo_res_tsv)
    if os.path.exists(cmsearch_res_txt):
        os.remove(cmsearch_res_txt)

    """
    Get chromosome IDs from --genome.
    """
    print("Get --genome FASTA headers ... ")
    chr_ids_dic = benchlib.get_fasta_headers(args.in_genome)


    """
    Region extensions.

    """

    ext_parts = args.ext_up_down.split(",")
    c_ext_parts = len(ext_parts)
    ext_up = 0
    ext_down = 0
    if c_ext_parts == 1:
        ext_up = int(ext_parts[0])
        ext_down = int(ext_parts[0])
    elif c_ext_parts == 2:
        ext_up = int(ext_parts[0])
        ext_down = int(ext_parts[1]) 
    else:
        assert False, "invalid --ext argument provided (correct format: --ext 10 OR --ext 20,10)"



    """
    Output files + write headers.

    """
    # RBP batch stats file.
    OUTRBPSTATS = open(rbp_stats_out,"w")
    rbp_stats_header = "data_id\tmethod_id\trun_id\tmotif_db\trbp_id\tc_regions\tmean_reg_len\tmedian_reg_len\tmin_reg_len\tmax_reg_len\t"
    rbp_stats_header += "called_reg_size\teffective_reg_size\tc_reg_with_hits\tperc_reg_with_hits\t"
    rbp_stats_header += "c_motif_hits\tc_uniq_motif_hits\tc_uniq_motif_nts\tperc_uniq_motif_nts_cal_reg\tperc_uniq_motif_nts_eff_reg\tuniq_motif_hits_cal_1000nt\t"
    rbp_stats_header += "uniq_motif_hits_eff_1000nt\twc_pval\tseq_motif_ids\tseq_motif_hits\tstr_motif_ids\tstr_motif_hits\tinternal_id\n"
    OUTRBPSTATS.write(rbp_stats_header)

    # Motif batch stats file.
    OUTMTFSTATS = open(motif_stats_out,"w")
    motif_stats_header = "data_id\tmethod_id\trun_id\tmotif_db\tregion_id\trbp_id\tmotif_id\tchr_id\tgen_s\tgen_e\tstrand\tregion_s\tregion_e\tregion_len\t"
    motif_stats_header += "uniq_count\tfimo_score\tfimo_pval\tcms_score\tcms_eval\tinternal_id\n"
    OUTMTFSTATS.write(motif_stats_header)

    args.internal_id = []

    # Unique motif regions BED.
    motif_reg_dic = {}

    # Unstranded option.
    if args.unstranded:
        print("WARNING: --unstranded enabled. Using both strands for each --in BED region ... ")
        if ext_up != ext_down:
            print("asymmetric --ext and --unstranded set. Extend plus strand and use corresponding minus strand ... ")

    print("Run motif search for each dataset ... ")

    """
    Run motif search for each BED / RBP ID combination.

    """

    for idx, bed_file in enumerate(bed_list):

        rbp_id = rbp_ids_list[idx]
        bed_file_path = bed_file
        if bed_path:
            bed_file_path = bed_path + "/" + bed_file

        data_id = args.data_id
        if data_ids_list:
            data_id = data_ids_list[idx]
        method_id = args.method_id
        if method_ids_list:
            method_id = method_ids_list[idx]

        # Motif IDs for search.
        loaded_motif_ids_dic = {}
        for motif_id in name2ids_dic[rbp_id]:
            loaded_motif_ids_dic[motif_id] = motif_db_str

        # Store motif IDs for search.
        search_rbps_dic = {} #
        seq_rbps_dic = {}
        str_rbps_dic = {}
        motif_id2idx_dic = {} # motif ID -> list index.

        print("")
        print("RBP ID:        ", rbp_id)
        print("BED file:      ", bed_file)
        print("# of motif IDs:", len(loaded_motif_ids_dic))
        print("Motif IDs:     ", loaded_motif_ids_dic)
        internal_id = base64.urlsafe_b64encode(os.urandom(6)).decode()
        args.internal_id.append(internal_id)
        print("Data ID:       ", data_id)
        print("Method ID:     ", method_id)
        print("Internal ID:   ", internal_id)

        rbp = benchlib.RBP(rbp_id, internal_id)

        for motif_id in name2ids_dic[rbp_id]:
            if id2type_dic[motif_id] == "meme_xml":
                rbp.seq_motif_ids.append(motif_id)
                motif_id2idx_dic[motif_id] = len(rbp.seq_motif_ids) - 1
                rbp.seq_motif_hits.append(0)
                seq_rbps_dic[rbp_id] = 1
            else:
                rbp.str_motif_ids.append(motif_id)
                motif_id2idx_dic[motif_id] = len(rbp.str_motif_ids) - 1
                rbp.str_motif_hits.append(0)
                str_rbps_dic[rbp_id] = 1

        """
        Filter / extend --in genomic regions BED file.

        """
        print("Preprocess --in sites ... ")
        reg2sc_dic = {}
        reg_stats_dic = benchlib.bed_filter_extend_bed(bed_file_path, filtered_sites_bed,
                                            ext_up=ext_up,
                                            ext_down=ext_down,
                                            remove_dupl=True,
                                            reg2sc_dic=reg2sc_dic,
                                            score_col=args.bed_score_col,
                                            chr_ids_dic=chr_ids_dic,
                                            unstranded=args.unstranded)
        
        assert reg_stats_dic["c_out"], "no --in BED sites remain after chromosome ID filtering"

        """
        Calculate effective size of genomic regions.
        
        """
        print("Calculate effective genomic region size ... ")
        eff_reg_size = benchlib.get_uniq_gen_size(filtered_sites_bed)

        print("# --in regions pre-filtering:  ", reg_stats_dic["c_in"])
        print("# --in regions post-filtering: ", reg_stats_dic["c_out"])
        print("# regions with invalid chr_id: ", reg_stats_dic["c_chr_filter"])
        print("# duplicated regions removed:  ", reg_stats_dic["c_dupl_filter"])
        print("Called region length sum:      ", reg_stats_dic["reg_len_sum"])
        print("Effective region length sum:   ", eff_reg_size)

        """
        Get genomic region sequences from --genome.

        """
        print("Extract sequences from --genome ... ")
        benchlib.bed_extract_sequences_from_fasta(filtered_sites_bed, 
                                                args.in_genome, filtered_sites_fa,
                                                print_warnings=True)

        """
        Get FASTA sequences and sequence lengths.
        """

        out_seqs_dic = benchlib.read_fasta_into_dic(filtered_sites_fa,
                                        dna=True,
                                        all_uc=True,
                                        id_check=True,
                                        empty_check=False,
                                        skip_n_seqs=False)

        assert out_seqs_dic, "no sequences extracted from FASTA file for --in BED sites. Make sure to use compatible FASTA/BED files!"

        # Effective number of regions used for motif search.
        c_regions = len(out_seqs_dic)
        if args.unstranded and not args.unstranded_ct:
            # Check if sequences are even.
            assert not len(out_seqs_dic) % 2, "# of --in regions should be an even number since --unstranded is set. Please contact developers"
            c_regions = len(out_seqs_dic) // 2

        # Called region size.
        called_reg_size = 0
        len_list = []
        for seq_id in out_seqs_dic:
            seq_len = len(out_seqs_dic[seq_id])
            called_reg_size += seq_len
            len_list.append(seq_len)

        # Length statistics.
        reg_len_median = int(statistics.median(len_list))
        reg_len_mean = statistics.mean(len_list)
        reg_len_mean = round(reg_len_mean, 2)
        reg_len_min = min(len_list)
        reg_len_max = max(len_list)

        """
        ====================================
        RUN SEQUENCE MOTIF SEARCH WITH FIMO.
        ====================================
        
        """
        fimo_hits_list = []
        call_dic = {}

        if seq_rbps_dic:

            """
            Print motifs to file.

            """

            print("Output motifs to XML ... ")
            out_str, c_added_motifs = benchlib.blocks_to_xml_string(seq_motif_blocks_dic, loaded_motif_ids_dic)

            benchlib.output_string_to_file(out_str, seq_motifs_xml)

            """
            Run FIMO on sequences + motifs.

            """

            print("Run FIMO ... ")
            benchlib.run_fast_fimo(filtered_sites_fa, seq_motifs_xml, fimo_res_tsv,
                        pval_thr=args.fimo_pval,
                        nt_freqs_file=fimo_freqs_file,
                        call_dic=call_dic,
                        params="--norc --verbosity 1 --skip-matched-sequence --text",
                        error_check=False)

            """
            Read in FIMO hits.

            """

            assert os.path.exists(fimo_res_tsv), "FIMO output file fimo.tsv %s does not exist! There must have been an error while running FIMO (invalid xml file provided?)" %(fimo_res_tsv)

            print("Read in FIMO results ... ")
            fimo_hits_list = benchlib.read_in_fimo_results(fimo_res_tsv)

            c_fimo_hits = len(fimo_hits_list)
            print("# of FIMO motif hits:", c_fimo_hits)


        """
        =========================================
        RUN STRUCTURE MOTIF SEARCH WITH CMSEARCH.
        =========================================

        """
        cmsearch_hits_list = []

        if str_rbps_dic:
            
            print("Output covariance models to .cm ... ")
            benchlib.output_cm_blocks_to_file(str_motif_blocks_dic, loaded_motif_ids_dic, str_motifs_cm)

            # Run cmsearch.
            print("Run cmsearch ... ")
            benchlib.run_cmsearch(filtered_sites_fa, str_motifs_cm, cmsearch_res_txt,
                            error_check=False,
                            call_dic=call_dic,
                            params="-g --tformat fasta --toponly --incT 1 -T 1 --default")
            # Read in hits.
            print("Read in cmsearch results ... ")
            cmsearch_hits_list, c_cms_hits = benchlib.read_in_cmsearch_results(cmsearch_res_txt)

            print("# of cmsearch motif hits:", c_cms_hits)


        """
        Store regions with motif hits (and hit counts).
        This tells us, how many input regions have motif hits (+ how many hits).

        Also store the unique motif hit regions (and hit counts).

        regions_with_motifs_dic:
            region -> motif_c_region

        unique_motifs_dic:
            motif_region -> c_motif_region

        """

        regions_with_motifs_dic = {}
        unique_motifs_dic = {}

        # Store regions with sequence motifs.
        for fh in fimo_hits_list:

            if fh.seq_name in regions_with_motifs_dic:
                regions_with_motifs_dic[fh.seq_name] += 1
            else:
               regions_with_motifs_dic[fh.seq_name] = 1 

            fh_str = repr(fh) # genomic motif region string.

            if fh_str in unique_motifs_dic:
                unique_motifs_dic[fh_str] += 1
            else:
                unique_motifs_dic[fh_str] = 1

        # Store regions with structure motifs.
        for cmsh in cmsearch_hits_list:

            if cmsh.seq_name in regions_with_motifs_dic:
                regions_with_motifs_dic[cmsh.seq_name] += 1
            else:
               regions_with_motifs_dic[cmsh.seq_name] = 1 

            cmsh_str = repr(cmsh) # genomic motif region string.

            if cmsh_str in unique_motifs_dic:
                unique_motifs_dic[cmsh_str] += 1
            else:
                unique_motifs_dic[cmsh_str] = 1

        """
        Store infos in RBP object.

        """
        # number of --in regions with RBP motif hits.
        c_hit_reg = len(regions_with_motifs_dic)
        if args.unstranded and not args.unstranded_ct:
            c_hit_reg = 0
            seen_ids_dic = {}
            for seq_id in regions_with_motifs_dic:
                core_id = benchlib.reg_get_core_id(seq_id)
                if core_id not in seen_ids_dic:
                    c_hit_reg += 1
                    seen_ids_dic[core_id] = 1

        # number of motif hits on --in regions in total.
        c_motif_hits = 0
        for reg_id in regions_with_motifs_dic:
            c_motif_hits += regions_with_motifs_dic[reg_id]
        
        rbp.c_hit_reg = c_hit_reg
        rbp.c_motif_hits = c_motif_hits
        # % hit regions over all regions (i.e. how many input regions contain >= 1 RBP motif).
        rbp.perc_hit_reg = (rbp.c_hit_reg / c_regions) * 100

        """
        Get unique motif hits.

        """
        rbp.c_uniq_motif_hits = len(unique_motifs_dic)
        # Store individual motif unique hits.
        for motif_str_repr in unique_motifs_dic:
            motif_id = benchlib.get_motif_id_from_str_repr(motif_str_repr)
            idx = motif_id2idx_dic[motif_id]
            if id2type_dic[motif_id] == "meme_xml":
                rbp.seq_motif_hits[idx] += 1
            else:
                rbp.str_motif_hits[idx] += 1

        """
        Number of motif nucleotides over called + effective region size.

        """

        print("Calculate effective motif region sizes ... ")

        # Ouput unique motif hit regions (sequence or structure) to BED.
        eff_motif_reg_size = 0
        if unique_motifs_dic:
            benchlib.batch_output_motif_hits_to_bed(unique_motifs_dic, out_tmp_bed,
                                                    one_based_start=True)
            # Calculate effective motif region size.
            eff_motif_reg_size = benchlib.get_uniq_gen_size(out_tmp_bed)

        # Number of unique motif nucleotides.
        rbp.c_uniq_motif_nts = eff_motif_reg_size
        # % unique motif nts over effective region length.
        rbp.perc_uniq_motif_nts_eff_reg = (eff_motif_reg_size / eff_reg_size) * 100
        # % unique motif nts over called region length.
        rbp.perc_uniq_motif_nts_cal_reg = (eff_motif_reg_size / called_reg_size) * 100
        # Number of unique motif hits per effective 1000 nt.
        rbp.uniq_motif_hits_eff_1000nt  = rbp.c_uniq_motif_hits / (eff_reg_size / 1000)
        # Number of unique motif hits per called 1000 nt.
        rbp.uniq_motif_hits_cal_1000nt  = rbp.c_uniq_motif_hits / (called_reg_size / 1000)

        print("# --in regions for motif search:", c_regions)
        print("Called genomic region size:     ", called_reg_size)
        print("Effective genomic region size:  ", eff_reg_size)

        """
        Motif enrichment test:
        Are motifs enriched in higher scoring sites?

        """

        print("Calculate Wilcoxon rank-sum test statistics ... ")

        # Check if all scores same (e.g. 0).
        reg_scores_dic = {}
        for reg_id in reg2sc_dic:
            reg_scores_dic[reg2sc_dic[reg_id]] = 1
        if len(reg_scores_dic) == 1:
            print("WARNING: all site scores identical. Reported p-values meaningless! (i.e., equal 1.0)")

        hit_reg_scores = []
        non_hit_reg_scores = []
        seen_ids_dic = {}

        for reg_id in reg2sc_dic:
            reg_sc = reg2sc_dic[reg_id] # float value.
            # If --unstranded, count regions only once as hit or no hit.
            if args.unstranded and not args.unstranded_ct:
                core_id = benchlib.reg_get_core_id(reg_id)
                reg_id1 = core_id + "(+)"
                reg_id2 = core_id + "(-)"
                if core_id not in seen_ids_dic:
                    if reg_id1 in regions_with_motifs_dic or reg_id2 in regions_with_motifs_dic:
                        hit_reg_scores.append(reg_sc)
                    else:
                        non_hit_reg_scores.append(reg_sc)
                    seen_ids_dic[core_id] = 1
            else:
                if reg_id in regions_with_motifs_dic:
                    hit_reg_scores.append(reg_sc)
                else:
                    non_hit_reg_scores.append(reg_sc)

        wc_pval = 1.0
        # In case no regions without motif hits.
        if not non_hit_reg_scores:
            print("WARNING: all input regions contain motifs. Adding dummy scores (median) ... ")
            dummy_val = statistics.median(hit_reg_scores)
            hit_reg_scores.append(dummy_val)
            non_hit_reg_scores.append(dummy_val)

        print("# hit regions:    ", len(hit_reg_scores))
        print("# non-hit regions:", len(non_hit_reg_scores))

        if unique_motifs_dic:
            wc_stat, wc_pval = mannwhitneyu(hit_reg_scores, non_hit_reg_scores, alternative="greater")
            rbp.wc_pval = wc_pval
        print("Compact hit stats (RBP ID, # unique hits, Wilcoxon p-value):")
        print("%s\t%i\t%s" %(rbp_id, rbp.c_uniq_motif_hits, str(wc_pval)))

        """
        Output RBP hit stats (one row per RBP).

        """
        c_reg_with_hits = rbp.c_hit_reg
        perc_reg_with_hits = rbp.perc_hit_reg
        c_motif_hits = rbp.c_motif_hits
        c_uniq_motif_hits = rbp.c_uniq_motif_hits
        c_uniq_motif_nts = rbp.c_uniq_motif_nts
        perc_uniq_motif_nts_cal_reg = rbp.perc_uniq_motif_nts_cal_reg
        perc_uniq_motif_nts_eff_reg = rbp.perc_uniq_motif_nts_eff_reg
        uniq_motif_hits_cal_1000nt = rbp.uniq_motif_hits_cal_1000nt
        uniq_motif_hits_eff_1000nt = rbp.uniq_motif_hits_eff_1000nt
        wc_pval = rbp.wc_pval

        seq_motif_hits = ",".join(str(hc) for hc in rbp.seq_motif_hits)
        str_motif_hits = ",".join(str(hc) for hc in rbp.str_motif_hits)
        seq_motif_ids = ",".join(rbp.seq_motif_ids)
        str_motif_ids = ",".join(rbp.str_motif_ids)
        if not seq_motif_hits:
            seq_motif_hits = "-"
        if not str_motif_hits:
            str_motif_hits = "-"
        if not seq_motif_ids:
            seq_motif_ids = "-"
        if not str_motif_ids:
            str_motif_ids = "-"

        row_str = data_id + "\t"
        row_str += method_id + "\t"
        row_str += run_id + "\t"
        row_str += motif_db_str + "\t"
        row_str += rbp_id + "\t"

        row_str += str(c_regions) + "\t"

        row_str += str(reg_len_mean) + "\t"
        row_str += str(reg_len_median) + "\t"
        row_str += str(reg_len_min) + "\t"
        row_str += str(reg_len_max) + "\t"

        row_str += str(called_reg_size) + "\t"
        row_str += str(eff_reg_size) + "\t"

        row_str += str(c_reg_with_hits) + "\t"
        row_str += str(perc_reg_with_hits) + "\t"

        row_str += str(c_motif_hits) + "\t"
        row_str += str(c_uniq_motif_hits) + "\t"
        row_str += str(c_uniq_motif_nts) + "\t"
        row_str += str(perc_uniq_motif_nts_cal_reg) + "\t"
        row_str += str(perc_uniq_motif_nts_eff_reg) + "\t"
        row_str += str(uniq_motif_hits_cal_1000nt) + "\t"
        row_str += str(uniq_motif_hits_eff_1000nt) + "\t"
        row_str += str(wc_pval) + "\t"
        row_str += seq_motif_ids + "\t"
        row_str += seq_motif_hits + "\t"
        row_str += str_motif_ids + "\t"
        row_str += str_motif_hits + "\t"
        row_str += internal_id + "\n"

        OUTRBPSTATS.write(row_str)


        """
        Output motif region stats (one row per motif hit).
        Report ALL motif hits, plus report how many times one genomic 
        motif hit occurs (uniq_count). 

        """

        for fh in fimo_hits_list:

            region_id = fh.seq_name
            region_len = benchlib.get_length_from_seq_name(fh.seq_name)
            # Genomic motif region string.
            fh_str = repr(fh) 
            uniq_count = unique_motifs_dic[fh_str]

            # Store motif hit as BED.
            hit_id = "%s:%s-%s(%s),%s;%s" %(fh.chr_id, str(fh.start), str(fh.end), fh.strand, fh.motif_id, internal_id)
            if hit_id not in motif_reg_dic:
                bed_row = "%s\t%i\t%i\t%s,%s;%i;%s,%s\t0\t%s\t%s\t%s\t-1.0\t-1.0" %(fh.chr_id, fh.start-1, fh.end, rbp_id, fh.motif_id, uniq_count, method_id, data_id, fh.strand, str(fh.score), str(fh.pval))
                motif_reg_dic[hit_id] = bed_row

            row_str = data_id + "\t"
            row_str += method_id + "\t"
            row_str += run_id + "\t"
            row_str += motif_db_str + "\t"
            row_str += region_id + "\t"
            row_str += rbp_id + "\t"
            row_str += fh.motif_id + "\t"
            row_str += fh.chr_id + "\t"
            row_str += str(fh.start) + "\t"
            row_str += str(fh.end) + "\t"
            row_str += fh.strand + "\t"
            row_str += str(fh.seq_s) + "\t"
            row_str += str(fh.seq_e) + "\t"
            row_str += str(region_len) + "\t"
            row_str += str(uniq_count) + "\t"
            row_str += str(fh.score) + "\t"
            row_str += str(fh.pval) + "\t"
            row_str += "-\t"
            row_str += "-\t"
            row_str += internal_id + "\n"

            OUTMTFSTATS.write(row_str)

        for cmsh in cmsearch_hits_list:

            region_id = cmsh.seq_name
            region_len = benchlib.get_length_from_seq_name(cmsh.seq_name)
            # Genomic motif region string.
            cmsh_str = repr(cmsh) 
            uniq_count = unique_motifs_dic[cmsh_str]

            # Store motif hit as BED.
            hit_id = "%s:%s-%s(%s),%s;%s" %(cmsh.chr_id, str(cmsh.start), str(cmsh.end), cmsh.strand, cmsh.motif_id, internal_id)
            if hit_id not in motif_reg_dic:
                bed_row = "%s\t%i\t%i\t%s,%s;%i;%s,%s\t0\t%s\t%s\t%s\t-1.0\t-1.0" %(cmsh.chr_id, cmsh.start-1, cmsh.end, rbp_id, cmsh.motif_id, uniq_count, cmsh.strand, method_id, data_id, str(cmsh.score), str(cmsh.eval))
                motif_reg_dic[hit_id] = bed_row

            row_str = data_id + "\t"
            row_str += method_id + "\t"
            row_str += run_id + "\t"
            row_str += motif_db_str + "\t"
            row_str += region_id + "\t"
            row_str += rbp_id + "\t"
            row_str += cmsh.motif_id + "\t"
            row_str += cmsh.chr_id + "\t"
            row_str += str(cmsh.start) + "\t"
            row_str += str(cmsh.end) + "\t"
            row_str += cmsh.strand + "\t"
            row_str += str(cmsh.seq_s) + "\t"
            row_str += str(cmsh.seq_e) + "\t"
            row_str += str(region_len) + "\t"
            row_str += str(uniq_count) + "\t"
            row_str += "-\t"
            row_str += "-\t"
            row_str += str(cmsh.score) + "\t"
            row_str += str(cmsh.e_value) + "\t"
            row_str += internal_id + "\n"

            OUTMTFSTATS.write(row_str)

    OUTRBPSTATS.close()
    OUTMTFSTATS.close()

    OUTBED = open(motif_hits_bed_out,"w")
    for hit_id in motif_reg_dic:
        OUTBED.write("%s\n" %(motif_reg_dic[hit_id]))
    OUTBED.close()


    """
    Output parameter settings.

    """
    # Output mode settings.
    print("")
    print("Output parameter settings ... ")
    SETOUT = open(settings_file, "w")
    for arg in vars(args):
        SETOUT.write("%s\t%s\n" %(arg, str(getattr(args, arg))))
    for call in call_dic:
        SETOUT.write("%s\t%s\n" %(call, call_dic[call]))
    SETOUT.close()

    """
    Take out the trash.

    """
    print("Delete .tmp files ... ")
    if os.path.exists(out_tmp_bed):
        os.remove(out_tmp_bed)
    if os.path.exists(cmstat_tmp_out):
        os.remove(cmstat_tmp_out)

    """
    Inform about outputs.

    """
    print("")
    print("OUTPUT FILES")
    print("============")
    print("")
    print("Run parameter settings:\n%s" %(settings_file))
    print("Motif hits .bed:\n%s" %(motif_hits_bed_out))
    print("RBP hit stats .tsv:\n%s" %(rbp_stats_out))
    print("Motif hit stats .tsv:\n%s" %(motif_stats_out))
    print("")


################################################################################

def main_optex(args):
    """
    Investigate optimal extension

    """

    print("Running for you in OPTEX mode ... ")

    assert os.path.exists(args.in_sites), "--in file \"%s\" not found" % (args.in_sites)
    # Check --in BED format.
    benchlib.bed_check_format(args.in_sites)

    # Reformat user_rbp_id. 
    rbp_id = benchlib.remove_special_chars_from_str(args.rbp_id)
    assert rbp_id, "empty string after removing special chars from given --rbp-id %s. Please provide alphanumeric string for RBP ID (- or _ are okay as well)" %(args.rbp_id)

    """
    Library path.
    """
    benchlib_path = os.path.dirname(benchlib.__file__)
    db_path = benchlib_path + "/content"


    """
    FIMO nt frequencies.
    """
    fimo_freqs_file = db_path + "/fimo_nt_freqs.txt" # CONDA2SET
    if args.fimo_nt_freqs:
        fimo_freqs_file = args.fimo_nt_freqs
    assert os.path.exists(fimo_freqs_file), "set FIMO nucleotide frequencies file \"%s\" not found" % (fimo_freqs_file)

    """
    Motif database.
    """
    seq_motifs_db_file, str_motifs_db_file, rbp2ids_file, motif_db_str = specify_motif_db(args.motif_db, 
                                                                            db_path=db_path)
    args.motif_db_str = motif_db_str

    """
    Temp outputs.

    """
    tmp_id = base64.urlsafe_b64encode(os.urandom(6)).decode()
    tmp_out_folder = "optex_tmp_out_" + tmp_id

    if not os.path.exists(tmp_out_folder):
        os.makedirs(tmp_out_folder)

    filtered_sites_bed = tmp_out_folder + "/in_sites.filtered.bed"
    filtered_sites_fa = tmp_out_folder + "/in_sites.filtered.fa"
    seq_motifs_xml = tmp_out_folder + "/seq_motifs.xml"
    str_motifs_cm = tmp_out_folder + "/str_motifs.cm"
    fimo_res_tsv = tmp_out_folder + "/fimo_results.tsv"
    cmsearch_res_txt = tmp_out_folder + "/cmsearch_results.txt"

    out_tmp_bed = tmp_out_folder + "/rbp_motif_hit_regions.tmp.bed"
    cmstat_tmp_out = tmp_out_folder + "/cmstat_out.tmp.txt"

    # Delete if existing folder.
    if os.path.exists(fimo_res_tsv):
        os.remove(fimo_res_tsv)
    if os.path.exists(cmsearch_res_txt):
        os.remove(cmsearch_res_txt)

    """
    Get ID mappings

    name2ids_dic:
    RBP name -> motif IDs mapping
    id2type_dic:
    motif ID -> motif type (cm, meme_xml)
    id2org_dic:
    motif ID -> organism ID (so far only "human")

    """
    name2ids_dic, id2type_dic, id2org_dic = benchlib.get_rbp_id_mappings(rbp2ids_file)
    # Motif ID -> RBP name (== RBP ID) mapping.
    id2name_dic = {}
    for rbpid in name2ids_dic:
        for motif_id in name2ids_dic[rbpid]:
            id2name_dic[motif_id] = rbpid


    """
    Define search motifs.

    """

    seq_motif_blocks_dic = {}
    str_motif_blocks_dic = {}
    loaded_motif_ids_dic = {}

    if rbp_id in name2ids_dic:

        print("RBP ID %s in database ... " %(rbp_id))

        assert not args.user_meme_xml, "provided RBP ID in motif database, but --user-meme-xml provided. Please provide RBP ID not in motif database to search with --user-meme-xml motif(s)"
        assert not args.user_cm, "provided RBP ID in motif database, but --user-cm provided. Please provide RBP ID not in motif database to search with --user-cm motif(s)"

        """
        Get MEME XML database motif blocks dictionary.

        """
        seq_motif_blocks_dic = benchlib.read_in_xml_motifs(seq_motifs_db_file)
        for motif_id in seq_motif_blocks_dic:
            assert motif_id in id2name_dic, "MEME XML motif ID %s not found in prior mapping. Please contact developers!" %(motif_id)

        """
        Get covariance model database motif blocks dictionary.

        """
        str_motif_blocks_dic = benchlib.read_in_cm_blocks(str_motifs_db_file)
        for motif_id in str_motif_blocks_dic:
            assert motif_id in id2name_dic, "Covariance model accession ID %s not found in prior mapping. Please contact developers!" %(motif_id)

        for motif_id in name2ids_dic[rbp_id]:
            loaded_motif_ids_dic[motif_id] = 1

    else:

        print("RBP ID %s NOT in database ... " %(rbp_id))

        assert args.user_meme_xml or args.user_cm, "--rbp-id not in database. Please provide user motif(s) (via --user-meme-xml OR --user-cm), set different motif database or supply RBP ID present in set database"

        if args.user_meme_xml:
            assert not args.user_cm, "either supply --user-meme-xml or --user-cm"
            assert os.path.exists(args.user_meme_xml), "--user-meme-xml file \"%s\" not found" % (args.user_meme_xml)
            seq_motif_blocks_dic = benchlib.read_in_xml_motifs(args.user_meme_xml, check=False)
            assert seq_motif_blocks_dic, "no motifs read in from provided --user-meme-xml. Make sure to supply sequence motifs in MEME XML format!"
            for acc_id in seq_motif_blocks_dic:
                name2ids_dic[rbp_id] = [acc_id]
                id2type_dic[acc_id] = "meme_xml"
                id2name_dic[acc_id] = rbp_id
                loaded_motif_ids_dic[acc_id] = 1

        if args.user_cm:
            assert not args.user_meme_xml, "either supply --user-meme-xml or --user-cm"
            assert os.path.exists(args.user_cm), "--user-cm file \"%s\" not found" % (args.user_cm)
            # Check for valid format.
            acc_ids_dic = benchlib.check_cm_file(args.user_cm, cmstat_tmp_out, check=True)
            # Read in covariance model blocks.
            str_motif_blocks_dic = benchlib.read_in_cm_blocks(args.user_cm)
            for acc_id in acc_ids_dic:
                assert acc_id in str_motif_blocks_dic, "accession ID %s not in blocks dictionary. Please contact developers!" %(acc_id)
            for acc_id in str_motif_blocks_dic:
                name2ids_dic[rbp_id] = [acc_id]
                id2type_dic[acc_id] = "cm"
                id2name_dic[acc_id] = rbp_id
                loaded_motif_ids_dic[acc_id] = 1


    """
    Make RBP object.

    """
    motif_id2idx_dic = {}
    seq_rbps_dic = {}
    str_rbps_dic = {}
    search_rbps_dic = {}

    rbp = benchlib.RBP(rbp_id)

    for motif_id in loaded_motif_ids_dic:

        if id2type_dic[motif_id] == "meme_xml":
            rbp.seq_motif_ids.append(motif_id)
            motif_id2idx_dic[motif_id] = len(rbp.seq_motif_ids) - 1
            rbp.seq_motif_hits.append(0)
            seq_rbps_dic[rbp_id] = 1
        else:
            rbp.str_motif_ids.append(motif_id)
            motif_id2idx_dic[motif_id] = len(rbp.str_motif_ids) - 1
            rbp.str_motif_hits.append(0)
            str_rbps_dic[rbp_id] = 1

        search_rbps_dic[rbp_id] = rbp


    print("RBP ID:        ", rbp_id)
    print("# of motif IDs:", len(loaded_motif_ids_dic))
    print("Motif IDs:     ", loaded_motif_ids_dic)

    """
    Get chromosome IDs from --genome.
    """
    print("Get --genome FASTA headers ... ")
    chr_ids_dic = benchlib.get_fasta_headers(args.in_genome)


    """
    Run motif search for each up- downstream extension combination.

    """
    from itertools import product
    ext_list = [0, 5, 10, 15, 20, 25, 30, 35, 40, 45, 50, 55, 60]

    # If user extension list given.
    if args.ext_list:
        ext_dic = {}
        for ext in args.ext_list:
            ext_dic[ext] = 1
        ext_list = []
        for ext in ext_dic:
            ext_list.append(ext)

    combined_list = list(product(ext_list, ext_list))
    ext2pval_dic = {}
    ext2stats_dic = {}
    sum_ext = 0
    longest_ext = "-"
    
    for ext in combined_list:

        print("")
        print("Extension (upstream, downstream):", ext)
        ext_up = ext[0]
        ext_down = ext[1]
        ext_str = "%i-%i" %(ext_up, ext_down)

        # Filter / extend --in BED.
        reg2sc_dic = {}
        reg_stats_dic = benchlib.bed_filter_extend_bed(args.in_sites, filtered_sites_bed,
                                            ext_up=ext_up,
                                            ext_down=ext_down,
                                            remove_dupl=True,
                                            reg2sc_dic=reg2sc_dic,
                                            score_col=args.bed_score_col,
                                            chr_ids_dic=chr_ids_dic)
        
        assert reg_stats_dic["c_out"], "no --in BED sites remain after chromosome ID filtering"

        # Check if all scores same (e.g. 0).
        reg_scores_dic = {}
        for reg_id in reg2sc_dic:
            reg_scores_dic[reg2sc_dic[reg_id]] = 1
        assert len(reg_scores_dic) != 1, "all site scores identical. Please use meaningful scores (--in BED column set by --bed-score-col)"

        """
        Calculate effective size of genomic regions.
        
        """
        print("Calculate effective genomic region size ... ")
        eff_reg_size = benchlib.get_uniq_gen_size(filtered_sites_bed)

        # print("# --in regions pre-filtering:  ", reg_stats_dic["c_in"])
        # print("# --in regions post-filtering: ", reg_stats_dic["c_out"])
        # print("# regions with invalid chr_id: ", reg_stats_dic["c_chr_filter"])
        # print("# duplicated regions removed:  ", reg_stats_dic["c_dupl_filter"])
        # print("Called region length sum:      ", reg_stats_dic["reg_len_sum"])
        # print("Effective region length sum:   ", eff_reg_size)

        """
        Get genomic region sequences from --genome.

        Output FASTA header format:
        >chr8:9772198-9772297(+)

        No need to convert sequences to uppercase, as FIMO works on both 
        lower- and uppercase (as long as DNA / RNA is set correct).

        """
        # print("Extract sequences from --genome ... ")
        benchlib.bed_extract_sequences_from_fasta(filtered_sites_bed, 
                                                args.in_genome, filtered_sites_fa,
                                                print_warnings=True)

        """
        Get FASTA sequences and sequence lengths.
        """

        out_seqs_dic = benchlib.read_fasta_into_dic(filtered_sites_fa,
                                        dna=True,
                                        all_uc=True,
                                        id_check=True,
                                        empty_check=False,
                                        skip_n_seqs=False)

        assert out_seqs_dic, "no sequences extracted from FASTA file for --in BED sites. Make sure to use compatible FASTA/BED files!"

        # Effective number of regions used for motif search.
        c_regions = len(out_seqs_dic)

        # Called region size.
        called_reg_size = 0
        for seq_id in out_seqs_dic:
            called_reg_size += len(out_seqs_dic[seq_id])


        """
        ====================================
        RUN SEQUENCE MOTIF SEARCH WITH FIMO.
        ====================================
        
        """
        fimo_hits_list = []
        call_dic = {}

        if seq_rbps_dic:

            """
            Print motifs to file.

            """

            # print("Output motifs to XML ... ")
            out_str, c_added_motifs = benchlib.blocks_to_xml_string(seq_motif_blocks_dic, loaded_motif_ids_dic)

            benchlib.output_string_to_file(out_str, seq_motifs_xml)


            """
            Run FIMO on sequences + motifs.

            """

            # print("Run FIMO ... ")
            benchlib.run_fast_fimo(filtered_sites_fa, seq_motifs_xml, fimo_res_tsv,
                        pval_thr=args.fimo_pval,
                        nt_freqs_file=fimo_freqs_file,
                        call_dic=call_dic,
                        params="--norc --verbosity 1 --skip-matched-sequence --text",
                        error_check=False)

            """
            Read in FIMO hits.

            """

            assert os.path.exists(fimo_res_tsv), "FIMO output file fimo.tsv %s does not exist! There must have been an error while running FIMO (invalid xml file provided?)" %(fimo_res_tsv)

            # print("Read in FIMO results ... ")
            fimo_hits_list = benchlib.read_in_fimo_results(fimo_res_tsv)

            c_fimo_hits = len(fimo_hits_list)
            # print("# of FIMO motif hits:", c_fimo_hits)

        """
        =========================================
        RUN STRUCTURE MOTIF SEARCH WITH CMSEARCH.
        =========================================

        """
        cmsearch_hits_list = []

        if str_rbps_dic:
            
            # print("Output covariance models to .cm ... ")
            benchlib.output_cm_blocks_to_file(str_motif_blocks_dic, loaded_motif_ids_dic, str_motifs_cm)

            # Run cmsearch.
            # print("Run cmsearch ... ")
            benchlib.run_cmsearch(filtered_sites_fa, str_motifs_cm, cmsearch_res_txt,
                            error_check=False,
                            call_dic=call_dic,
                            params="-g --tformat fasta --toponly --incT 1 -T 1 --default")
            # Read in hits.
            # print("Read in cmsearch results ... ")
            cmsearch_hits_list, c_cms_hits = benchlib.read_in_cmsearch_results(cmsearch_res_txt)

            # print("# of cmsearch motif hits:", c_cms_hits)

        """
        Store regions with motif hits (and hit counts).
        This tells us, how many input regions have motif hits (+ how many hits).

        Also store the unique motif hit regions (and hit counts).

        regions_with_motifs_dic:
            region -> motif_c_region

        unique_motifs_dic:
            motif_region -> c_motif_region

        """

        regions_with_motifs_dic = {}
        unique_motifs_dic = {}

        # Store regions with sequence motifs.
        for fh in fimo_hits_list:

            if fh.seq_name in regions_with_motifs_dic:
                regions_with_motifs_dic[fh.seq_name] += 1
            else:
               regions_with_motifs_dic[fh.seq_name] = 1 

            fh_str = repr(fh) # genomic motif region string.

            if fh_str in unique_motifs_dic:
                unique_motifs_dic[fh_str] += 1
            else:
                unique_motifs_dic[fh_str] = 1

        # Store regions with structure motifs.
        for cmsh in cmsearch_hits_list:

            if cmsh.seq_name in regions_with_motifs_dic:
                regions_with_motifs_dic[cmsh.seq_name] += 1
            else:
               regions_with_motifs_dic[cmsh.seq_name] = 1 

            cmsh_str = repr(cmsh) # genomic motif region string.

            if cmsh_str in unique_motifs_dic:
                unique_motifs_dic[cmsh_str] += 1
            else:
                unique_motifs_dic[cmsh_str] = 1

        """
        Store infos in RBP object.

        """
        # number of --in regions with RBP motif hits.
        c_hit_reg = len(regions_with_motifs_dic)
        # number of motif hits on --in regions in total.
        c_motif_hits = 0
        for reg_id in regions_with_motifs_dic:
            c_motif_hits += regions_with_motifs_dic[reg_id]
        
        rbp.c_hit_reg = c_hit_reg
        rbp.c_motif_hits = c_motif_hits
        # % hit regions over all regions (i.e. how many input regions contain >= 1 RBP motif).
        rbp.perc_hit_reg = (rbp.c_hit_reg / c_regions) * 100

        """
        Get unique motif hits.

        """
        rbp.c_uniq_motif_hits = len(unique_motifs_dic)
        # Store individual motif unique hits.
        for motif_str_repr in unique_motifs_dic:
            motif_id = benchlib.get_motif_id_from_str_repr(motif_str_repr)
            idx = motif_id2idx_dic[motif_id]
            if id2type_dic[motif_id] == "meme_xml":
                rbp.seq_motif_hits[idx] += 1
            else:
                rbp.str_motif_hits[idx] += 1

        """
        Number of motif nucleotides over called + effective region size.

        """

        # print("Calculate effective motif region sizes ... ")

        # Ouput unique motif hit regions (sequence or structure) to BED.
        eff_motif_reg_size = 0
        if unique_motifs_dic:
            benchlib.batch_output_motif_hits_to_bed(unique_motifs_dic, out_tmp_bed,
                                                    one_based_start=True)
            # Calculate effective motif region size.
            eff_motif_reg_size = benchlib.get_uniq_gen_size(out_tmp_bed)

        # Number of unique motif nucleotides.
        rbp.c_uniq_motif_nts = eff_motif_reg_size
        # % unique motif nts over effective region length.
        rbp.perc_uniq_motif_nts_eff_reg = (eff_motif_reg_size / eff_reg_size) * 100
        # % unique motif nts over called region length.
        rbp.perc_uniq_motif_nts_cal_reg = (eff_motif_reg_size / called_reg_size) * 100
        # Number of unique motif hits per effective 1000 nt.
        rbp.uniq_motif_hits_eff_1000nt  = rbp.c_uniq_motif_hits / (eff_reg_size / 1000)
        # Number of unique motif hits per called 1000 nt.
        rbp.uniq_motif_hits_cal_1000nt  = rbp.c_uniq_motif_hits / (called_reg_size / 1000)

        print("# --in regions for motif search:", c_regions)
        print("Called genomic region size:     ", called_reg_size)
        print("Effective genomic region size:  ", eff_reg_size)

        """
        Motif enrichment test:
        Are motifs enriched in higher scoring sites?

        """

        # print("Calculate Wilcoxon rank-sum test statistics ... ")

        # Check if all scores same (e.g. 0).
        reg_scores_dic = {}
        for reg_id in reg2sc_dic:
            reg_scores_dic[reg2sc_dic[reg_id]] = 1
        if len(reg_scores_dic) == 1:
            print("WARNING: all site scores identical. Reported p-values meaningless! (i.e., equal 1.0)")

        hit_reg_scores = []
        non_hit_reg_scores = []

        for reg_id in reg2sc_dic:
            reg_sc = reg2sc_dic[reg_id] # float value.
            if reg_id in regions_with_motifs_dic:
                hit_reg_scores.append(reg_sc)
            else:
                non_hit_reg_scores.append(reg_sc)

        wc_pval = 1.0
        # In case no regions without motif hits.
        if not non_hit_reg_scores:
            print("WARNING: all input regions contain motifs. Adding dummy scores (median) ... ")
            dummy_val = statistics.median(hit_reg_scores)
            hit_reg_scores.append(dummy_val)
            non_hit_reg_scores.append(dummy_val)

        print("# regions with motifs:         ", len(hit_reg_scores))
        print("# regions without motifs:      ", len(non_hit_reg_scores))

        hit_reg_median_sc = "-"
        non_hit_reg_median_sc = "-"
        if hit_reg_scores:
            hit_reg_median_sc = statistics.median(hit_reg_scores)
        if non_hit_reg_scores:
            non_hit_reg_median_sc = statistics.median(non_hit_reg_scores)


        print("Median score motif regions:    ", hit_reg_median_sc)
        print("Median score non-motif regions:", non_hit_reg_median_sc)

        if unique_motifs_dic:
            wc_stat, wc_pval = mannwhitneyu(hit_reg_scores, non_hit_reg_scores, alternative="greater")
            rbp.wc_pval = wc_pval
        print("Compact hit stats (RBP ID, # unique hits, Wilcoxon p-value):")
        print("%s\t%i\t%s" %(rbp_id, rbp.c_uniq_motif_hits, str(wc_pval)))

        ext2pval_dic[ext_str] = wc_pval
        ext2stats_dic[ext_str] = [len(hit_reg_scores), len(non_hit_reg_scores), rbp.c_uniq_motif_hits]
        if wc_pval <= args.ext_pval:
            new_sum = ext_up + ext_down
            if new_sum > sum_ext:
                sum_ext = new_sum
                longest_ext = ext_str

    """
    Take out the trash.

    """
    import shutil
    print("Delete tmp folder ... ")
    if os.path.exists(tmp_out_folder):
        shutil.rmtree(tmp_out_folder)

    """
    Report.

    """
    best_pval = 1.0
    best_ext = "-"
    for ext in ext2pval_dic:
        if ext2pval_dic[ext] < best_pval:
            best_pval = ext2pval_dic[ext]
            best_ext = ext

    print("")
    print("REPORT")
    print("======")
    print("")
    print("Longest extension p-value:   ", args.ext_pval)
    print("Longest extension:           ", longest_ext)
    print("Best p-value extension:      ", best_ext)
    print("Best p-value:                ", best_pval)
    print("# hit regions (best ext):    ", ext2stats_dic[best_ext][0])
    print("# non-hit regions (best ext):", ext2stats_dic[best_ext][1])
    print("# unique hits (best ext):    ", ext2stats_dic[best_ext][2])
    print("")


################################################################################

def main_info(args):
    """
    Print RBP IDs in database.

    """

    print("Running for you in INFO mode ... ")

    """
    Library path.
    """
    benchlib_path = os.path.dirname(benchlib.__file__)
    db_path = benchlib_path + "/content"

    """
    Motif database.
    """
    seq_motifs_db_file, str_motifs_db_file, rbp2ids_file, motif_db_str = specify_motif_db(args.motif_db, 
                                                                            db_path=db_path)

    """
    Get ID mappings

    name2ids_dic:
    RBP name -> motif IDs mapping
    id2type_dic:
    motif ID -> motif type (cm, meme_xml)
    id2org_dic:
    motif ID -> organism ID (so far only "human")

    """
    name2ids_dic, id2type_dic, id2org_dic = benchlib.get_rbp_id_mappings(rbp2ids_file)
    # Motif ID -> RBP name (== RBP ID) mapping.
    id2name_dic = {}
    c_motif_ids = 0
    for rbp_id in name2ids_dic:
        for motif_id in name2ids_dic[rbp_id]:
            c_motif_ids += 1
            id2name_dic[motif_id] = rbp_id

    print("")
    print("Motif database: %s" %(motif_db_str))
    print("# RBP IDs:      %i" %(len(name2ids_dic)))
    print("# motif IDs:    %i" %(c_motif_ids))
    print("")
    print("rbp_id\t#_motifs")
    for rbp_id in name2ids_dic:
        c_rbp_motifs = len(name2ids_dic[rbp_id])
        print("%s\t%i" %(rbp_id, c_rbp_motifs))
    print("")


################################################################################

def main_dist(args):
    """
    Plot nt distribution at crosslink (CL) positions.

    """

    print("Running for you in DIST mode ... ")

    assert os.path.exists(args.in_sites), "--in file \"%s\" not found" % (args.in_sites)
    assert args.ext_up_down >= 0 and args.ext_up_down <= 100, "please use reasonable --ext (>= 0 AND <= 100)"

    # Check --in BED format.
    benchlib.bed_check_format(args.in_sites)

    """
    Output folders + files.

    """
    if not os.path.exists(args.out_folder):
        os.makedirs(args.out_folder)

    filtered_sites_bed = args.out_folder + "/in_sites.filtered.bed"
    filtered_sites_fa = args.out_folder + "/in_sites.filtered.fa"
    motif_plot_out = args.out_folder + "/nt_dist_zero_pos.png"
    if args.plot_pdf:
        motif_plot_out = args.out_folder + "/nt_dist_zero_pos.pdf"

    """
    Get chromosome IDs from --genome.
    """
    print("Get --genome FASTA headers ... ")
    chr_ids_dic = benchlib.get_fasta_headers(args.in_genome)

    # Filter / extend --in BED.
    print("Preprocess --in sites ... ")
    reg_stats_dic = benchlib.bed_extend_bed(args.in_sites, filtered_sites_bed,
                                          ext_lr=args.ext_up_down,
                                          cp_mode=args.cp_mode,
                                          remove_dupl=True,
                                          chr_ids_dic=chr_ids_dic)
    
    assert reg_stats_dic["c_out"], "no --in BED sites remain after chromosome ID filtering"

    """
    Calculate effective size of genomic regions.
    
    """
    print("Calculate effective genomic region size ... ")
    eff_reg_size = benchlib.get_uniq_gen_size(filtered_sites_bed)

    print("# --in regions pre-filtering:  ", reg_stats_dic["c_in"])
    print("# --in regions post-filtering: ", reg_stats_dic["c_out"])
    print("# regions with invalid chr_id: ", reg_stats_dic["c_chr_filter"])
    print("# duplicated regions removed:  ", reg_stats_dic["c_dupl_filter"])
    print("Called region length sum:      ", reg_stats_dic["reg_len_sum"])
    print("Effective region length sum:   ", eff_reg_size)

    """
    Get genomic region sequences from --genome.

    Output FASTA header format:
    >chr8:9772198-9772297(+)

    No need to convert sequences to uppercase, as FIMO works on both 
    lower- and uppercase (as long as DNA / RNA is set correct).

    """

    print("Extract sequences from --genome ... ")
    benchlib.bed_extract_sequences_from_fasta(filtered_sites_bed, 
                                              args.in_genome, filtered_sites_fa,
                                              print_warnings=True)


    """
    Get FASTA sequences and sequence lengths.
    """

    out_seqs_dic = benchlib.read_fasta_into_dic(filtered_sites_fa,
                                       dna=True,
                                       all_uc=True,
                                       id_check=True,
                                       empty_check=False,
                                       skip_n_seqs=False)

    assert out_seqs_dic, "no sequences extracted from FASTA file for --in BED sites. Make sure to use compatible FASTA/BED files!"

    # Effective number of regions used for motif search.
    c_regions = len(out_seqs_dic)

    """
    Construct positional probabilty matrix.
        
    """

    # Expected region size.
    exp_reg_len = args.ext_up_down*2 + 1

    print("Create position probability matrix ... ")
    # Get position probability matrix for plotting.
    ppm = benchlib.make_pos_freq_matrix(out_seqs_dic, 
                         exp_len=exp_reg_len,
                         report=True,
                         to_ppm=True)


    print("Plot distribution ... ")
    benchlib.plot_nt_distribution_zero_pos(ppm, args.ext_up_down,
                                           plot_out=motif_plot_out)


    print("")
    print("Distribution plot file:\n%s" %(motif_plot_out))
    print("")

    # Take out the trash.
    # if os.path.exists(filtered_sites_bed):
    #     os.remove(filtered_sites_bed)
    # if os.path.exists(filtered_sites_fa):
    #     os.remove(filtered_sites_fa)


################################################################################

def main_compare(args):
    """
    Compare and report different rbpbench motif search results.

    """

    print("Running for you in COMPARE mode ... ")

    """
    Check / read in input --in data.

    """
    in_files = []
    for data in args.data_in:
        if os.path.isdir(data):
            rbp_stats_file = data + "/rbp_hit_stats.tsv"
            motif_stats_file = data + "/motif_hit_stats.tsv"
            assert os.path.exists(rbp_stats_file), "RBP stats file %s not found. Please provide valid rbpbench search/batch output folder via --in" %(rbp_stats_file)
            assert os.path.exists(motif_stats_file), "motif stats file %s not found. Please provide valid rbpbench search/batch output folder via --in" %(motif_stats_file)
            in_files.append(rbp_stats_file)
            in_files.append(motif_stats_file)
        elif os.path.isfile(data):
            in_files.append(data)
        else:
            assert False, "--in argument \"%s\" neither folder nor a file. Please provide rbpbench search/batch output folder or RBP/motif stats files" %(data)

    assert in_files, "no --in files read in from given --in locations. Please provide valid rbpbench search/batch output folder or RBP/motif stats files"

    file_check_dic = {}
    for in_file in in_files:
        assert in_file not in file_check_dic, "--in file %s given > 1. Please provide each file only once" %(in_file)
        file_check_dic[in_file] = 1
    
    """
    Read in RBP/motif stats data.

    rbp_stats_dic:
    internal_id -> RBPStats object

    motif_stats_dic:
    internal_id -> MotifStats object

    """
    rbp_stats_dic = {}
    motif_stats_dic = {}

    for in_file in in_files:
        type = benchlib.check_report_in_file(in_file)
        if type == "rbp_stats":
            benchlib.read_in_rbp_stats(in_file, rbp_stats_dic=rbp_stats_dic)
        elif type == "motif_stats":
            benchlib.read_in_motif_stats(in_file, motif_stats_dic=motif_stats_dic,
                                         store_uniq_only=True)
        else:
            assert False, "invalid --in file encountered (%s). Please provide valid rbpbench search/batch output folder or RBP/motif stats files" %(in_file)

    assert rbp_stats_dic, "No RBP stats read in from --in files. Please provide valid (non-empty) rbpbench search/batch output folder or RBP/motif stats files"
    assert motif_stats_dic, "No motif stats read in from --in files. Please provide valid (non-empty) rbpbench search/batch output folder or RBP/motif stats files"
    c_rbp_stats = len(rbp_stats_dic)
    c_motif_stats = len(motif_stats_dic)
    assert c_rbp_stats == c_motif_stats, "# RBP stats != # motif stats. Please provide RBP/motif stats files in pairs"
    for internal_id in rbp_stats_dic:
        assert internal_id in motif_stats_dic, "RBP stats internal_id %s not found in motif stats files. Please provide matching RBP/motif stats files"

    print("# RBP stats:  ", c_rbp_stats)
    print("# motif stats:", c_motif_stats)

    """
    Output files.

    """
    if not os.path.exists(args.out_folder):
        os.makedirs(args.out_folder)


    """
    Get data_id, method_id, rbp_id infos.
    Depending on whether combinations are present, different statistics can 
    be produced.

    3 types of comparions:
    1) between different methods (same rbp_id,data_id,motif_db)
        Table (some peak region dataset stats) between methods

        Bar plot % of regions with motifs
        Bar plot %
        Venn diagram motif
    2) between different RBPs on same dataset (so same data_id,
    and c_regions,mean_reg_len,median_reg_len,min_reg_len,max_reg_len,called_reg_size)
        basically reporting output of rbpbench search (could also be made as html output of rbpbench search!)
    3) between different datasets (same rbp_id,method_id,motif_db)

    Only do 1) 3) here, 2) can be done in search mode!
        
    for 1) kennzahlen:
    perc_uniq_motif_nts_cal_reg	perc_uniq_motif_nts_eff_reg	uniq_motif_hits_cal_1000nt	uniq_motif_hits_eff_1000nt


    data_id,method_id,motif_db,rbp_id,internal_id
    k562_eclip,dewseq_w100_s5,human_v0.1,PUM1,XRgmwD56
    k562_eclip,dewseq_w100_s5,human_v0.1,PUM2,ZzLuEZR9
    k562_eclip,clipper_idr,human_v0.1,PUM1,GeR1WaFK
    k562_eclip,clipper_idr,human_v0.1,PUM2,fEag63xM

    MotifStats.hit_id : chr:s-e(+),motif_id

    compare_methods_dic: {'k562_eclip,human_v0.1,PUM1': [['clipper_idr', 'GeR1WaFK', 'PUM1', 'k562_eclip', 'human_v0.1'], 
    ['dewseq_w100_s5', 'aErgL-gv', 'PUM1', 'k562_eclip', 'human_v0.1']], 
    'k562_eclip,human_v0.1,PUM2': [['clipper_idr', 'fEag63xM', 'PUM2', 'k562_eclip', 'human_v0.1'], 
    ['dewseq_w100_s5', 'ZzLuEZR9', 'PUM2', 'k562_eclip', 'human_v0.1']]}

    Single run, so same method ID, changing comp_ids:
    k562_eclip,human_v0.1,PUM1
    k562_eclip,human_v0.1,PUM2
    k562_eclip,human_v0.1,SLBP

    So we would need new comp_id:
    k562_eclip,human_v0.1,clipper_idr
    And variable ID will be rbp_id
    
    change to dic of dic 
    clipper_idr,human_v0.1,PUM1 -> k562_eclip -> GeR1WaFK
    

    """
    compare_methods_dic = {}
    compare_datasets_dic = {}

    for internal_id in rbp_stats_dic:
        data_id = rbp_stats_dic[internal_id].data_id
        method_id = rbp_stats_dic[internal_id].method_id
        rbp_id = rbp_stats_dic[internal_id].rbp_id
        motif_db = rbp_stats_dic[internal_id].motif_db
        comp_id = "%s,%s,%s" %(data_id, motif_db, rbp_id) # comparison ID (i.e. what is fixed).
        if comp_id not in compare_methods_dic:
            compare_methods_dic[comp_id] = {}
            compare_methods_dic[comp_id][method_id] = internal_id
        else:
            if method_id not in compare_methods_dic[comp_id]:
                compare_methods_dic[comp_id][method_id] = internal_id
            else:
                assert False, "data supplied via --in contains a combination twice (data_id:%s,rbp_id:%s,motif_db:%s,method_id:%s). Please provide unique combinations for method comparison" %(data_id, rbp_id, motif_db, method_id)
                # compare_methods_dic[comp_id][method_id].append(internal_id)
        # Dataset ID based dict of dicts.
        comp_id = "%s,%s,%s" %(method_id, motif_db, rbp_id)
        if comp_id not in compare_datasets_dic:
            compare_datasets_dic[comp_id] = {}
            compare_datasets_dic[comp_id][data_id] = internal_id
        else:
            if data_id not in compare_datasets_dic[comp_id]:
                compare_datasets_dic[comp_id][data_id] = internal_id
            else:
                assert False, "data supplied via --in contains a combination twice (data_id:%s,rbp_id:%s,motif_db:%s,method_id:%s). Please provide unique combinations for dataset comparison" %(data_id, rbp_id, motif_db, method_id)
                # compare_datasets_dic[comp_id][data_id].append(internal_id)

    # print("compare_methods_dic:", compare_methods_dic)
    # print("compare_datasets_dic:", compare_datasets_dic)

    # Binomial coefficient.
    from math import comb 

    # How much method comparisons?
    c_method_comps = 0
    for comp_id in compare_methods_dic:
        c_methods = len(compare_methods_dic[comp_id])
        c_method_comps += comb(c_methods, 2)

    print("# of method combinations:", c_method_comps)

    # How much dataset comparisons?
    c_data_comps = 0
    for comp_id in compare_datasets_dic:
        c_data = len(compare_datasets_dic[comp_id])
        c_data_comps += comb(c_data, 2)

    print("# of data combinations:", c_data_comps)

    if not c_method_comps and not c_data_comps:
        assert False, "--in data does not contain any dataset or method combinations. Please provide combinations for method or dataset comparsion"

    """
    Create comparison statistics and HTML report.

    """

    html_report_out = args.out_folder + "/" + "report.rbpbench_compare.html"
    plots_subfolder = "html_report_plots"
    benchlib_path = os.path.dirname(benchlib.__file__)


    # Generate report.
    benchlib.compare_generate_html_report(compare_methods_dic, 
                                          compare_datasets_dic,
                                          rbp_stats_dic, motif_stats_dic,
                                          args.out_folder, benchlib_path,
                                          html_report_out=html_report_out,
                                          plots_subfolder=plots_subfolder)


    """
    Output comparison stats.

    """

    comp_stats_tsv_out = args.out_folder + "/" + "comparison_stats.rbpbench_compare.tsv"
    motif_hits_tsv_out = args.out_folder + "/" + "motif_hits.rbpbench_compare.tsv"
    motif_hits_bed_out = args.out_folder + "/motif_hits.rbpbench_compare.bed"

    OUTCS = open(comp_stats_tsv_out, "w")
    outcs_header = "combined_id\tmethod_id\tdata_id\tmotif_db\trbp_id\tc_regions\tc_uniq_motif_hits\t"
    outcs_header += "perc_reg_with_hits\tperc_uniq_motif_nts_eff_reg\tuniq_motif_hits_cal_1000nt\n"
    OUTCS.write(outcs_header)

    # Method ID comparisons.
    for comp_id, method_dic in sorted(compare_methods_dic.items()):
        if len(method_dic) < 2:
            continue
        for method_id in method_dic:
            int_id = compare_methods_dic[comp_id][method_id]
            data_id = rbp_stats_dic[int_id].data_id
            rbp_id = rbp_stats_dic[int_id].rbp_id
            motif_db = rbp_stats_dic[int_id].motif_db
            c_regions = rbp_stats_dic[int_id].c_regions
            c_uniq_motif_hits = rbp_stats_dic[int_id].c_uniq_motif_hits
            perc_reg_with_hits = rbp_stats_dic[int_id].perc_reg_with_hits
            perc_uniq_motif_nts_eff_reg = rbp_stats_dic[int_id].perc_uniq_motif_nts_eff_reg
            uniq_motif_hits_cal_1000nt = rbp_stats_dic[int_id].uniq_motif_hits_cal_1000nt
            outcs_line = comp_id + "\t"
            outcs_line += method_id + "\t"
            outcs_line += data_id + "\t"
            outcs_line += motif_db + "\t"
            outcs_line += rbp_id + "\t"
            outcs_line += str(c_regions) + "\t"
            outcs_line += str(c_uniq_motif_hits) + "\t"
            outcs_line += str(perc_reg_with_hits) + "\t"
            outcs_line += str(perc_uniq_motif_nts_eff_reg) + "\t"
            outcs_line += str(uniq_motif_hits_cal_1000nt) + "\n"
            OUTCS.write(outcs_line)

    # Data ID comparisons.
    for comp_id, data_dic in sorted(compare_datasets_dic.items()):
        if len(data_dic) < 2:
            continue
        for data_id in data_dic:
            int_id = compare_datasets_dic[comp_id][data_id]
            method_id = rbp_stats_dic[int_id].method_id
            rbp_id = rbp_stats_dic[int_id].rbp_id
            motif_db = rbp_stats_dic[int_id].motif_db
            c_regions = rbp_stats_dic[int_id].c_regions
            c_uniq_motif_hits = rbp_stats_dic[int_id].c_uniq_motif_hits
            perc_reg_with_hits = rbp_stats_dic[int_id].perc_reg_with_hits
            perc_uniq_motif_nts_eff_reg = rbp_stats_dic[int_id].perc_uniq_motif_nts_eff_reg
            uniq_motif_hits_cal_1000nt = rbp_stats_dic[int_id].uniq_motif_hits_cal_1000nt
            outcs_line = comp_id + "\t"
            outcs_line += method_id + "\t"
            outcs_line += data_id + "\t"
            outcs_line += motif_db + "\t"
            outcs_line += rbp_id + "\t"
            outcs_line += str(c_regions) + "\t"
            outcs_line += str(c_uniq_motif_hits) + "\t"
            outcs_line += str(perc_reg_with_hits) + "\t"
            outcs_line += str(perc_uniq_motif_nts_eff_reg) + "\t"
            outcs_line += str(uniq_motif_hits_cal_1000nt) + "\n"
            OUTCS.write(outcs_line)

    OUTCS.close()


    """
    Output motif intersection stats (used for Venn diagrams).

    """

    OUTMH = open(motif_hits_tsv_out, "w")
    outmh_header = "combined_id\tmotif_hit_id\tmethod_data_ids_with_hit\n"
    OUTMH.write(outmh_header)
    OUTBED = open(motif_hits_bed_out, "w")

    # Method ID comparisons.
    for comp_id, method_dic in sorted(compare_methods_dic.items()):
        if len(method_dic) < 2:
            continue
        int_ids = []
        method_ids = []
        for method_id, int_id in sorted(method_dic.items()):
            int_ids.append(int_id)
            method_ids.append(method_id)

        # Motif Hit ID (chr_id:gen_s-gen_e(strand),motif_id) to method IDs sporting this hit.
        hid2mids_dic = {}
        mid2c_dic = {}

        for idx, int_id in enumerate(int_ids):
            mid = method_ids[idx]
            for motif_stats in motif_stats_dic[int_id]:  # motif_stats instance of MotifStats object.
                hid = motif_stats.hit_id
                if hid in hid2mids_dic:
                    hid2mids_dic[hid].append(mid)
                else:
                    hid2mids_dic[hid] = [mid]
                if mid in mid2c_dic:
                    mid2c_dic[mid] += 1
                else:
                    mid2c_dic[mid] = 1

        # print("Comparison:", comp_id)
        # print("Method ID motif hit counts:")
        # for mid in mid2c_dic:
        #     print(mid, mid2c_dic[mid])


        for hid in hid2mids_dic:
            mids_str = ",".join(hid2mids_dic[hid])
            OUTMH.write("%s\t%s\t%s\n" %(comp_id, hid, mids_str))
            # Also store motif hit in BED format.
            id_elem = benchlib.get_hit_id_elements(hid)
            OUTBED.write("%s\t%s\t%s\t%s;%s;%s\t0\t%s\n" %(id_elem[0], id_elem[1], id_elem[2], id_elem[4], comp_id, mids_str, id_elem[3]))

    # Data ID comparisons.
    for comp_id, data_dic in sorted(compare_datasets_dic.items()):
        if len(data_dic) < 2:
            continue
        int_ids = []
        data_ids = []
        for data_id, int_id in sorted(data_dic.items()):
            int_ids.append(int_id)
            data_ids.append(data_id)

        # Motif Hit ID (chr_id:gen_s-gen_e(strand),motif_id) to data IDs sporting this hit.
        hid2dids_dic = {}
        did2c_dic = {}

        for idx, int_id in enumerate(int_ids):
            did = data_ids[idx]
            for motif_stats in motif_stats_dic[int_id]:
                hid = motif_stats.hit_id
                if hid in hid2dids_dic:
                    hid2dids_dic[hid].append(did)
                else:
                    hid2dids_dic[hid] = [did]
                if did in did2c_dic:
                    did2c_dic[did] += 1
                else:
                    did2c_dic[did] = 1

        # print("Comparison:", comp_id)
        # print("Data ID motif hit counts:")
        # for did in did2c_dic:
        #     print(did, did2c_dic[did])

        for hid in hid2dids_dic:
            dids_str = ",".join(hid2dids_dic[hid])
            OUTMH.write("%s\t%s\t%s\n" %(comp_id, hid, dids_str))
            # Also store motif hit in BED format.
            id_elem = benchlib.get_hit_id_elements(hid)
            OUTBED.write("%s\t%s\t%s\t%s;%s;%s\t0\t%s\n" %(id_elem[0], id_elem[1], id_elem[2], id_elem[4], comp_id, dids_str, id_elem[3]))

    OUTMH.close()
    OUTBED.close()

    """
    Inform about outputs.

    """
    print("")
    print("OUTPUT FILES")
    print("============")
    print("")
    print("Comparison stats .tsv:\n%s" %(comp_stats_tsv_out))
    print("Motif hit stats .tsv:\n%s" %(motif_hits_tsv_out))
    print("Motif hits .bed:\n%s" %(motif_hits_bed_out))
    print("Motif search comparison Report .html:\n%s" %(html_report_out))
    print("")


################################################################################

if __name__ == '__main__':
    # Setup argparse.
    parser = setup_argument_parser()
    # Print help if no parameter is set.
    if len(sys.argv) < 2:
        parser.print_help()
        sys.exit()
    # Read in command line arguments.
    args = parser.parse_args()

    # Show some banner.
    print(benchlib.print_some_banner())

    # Are my tools ready?
    # assert hoodlib.is_tool("bedtools"), "bedtools not in PATH"
    # assert hoodlib.is_tool("twoBitToFa"), "twoBitToFa not in PATH"
    # assert hoodlib.is_tool("twoBitInfo"), "twoBitInfo not in PATH"

    # Run selected mode.
    if args.which == 'search':
        main_search(args)
    elif args.which == 'batch':
        main_batch(args)
    elif args.which == 'optex':
        main_optex(args)
    elif args.which == 'info':
        main_info(args)
    elif args.which == 'dist':
        main_dist(args)
    elif args.which == 'compare':
        main_compare(args)
