#!/usr/bin/env python3

import argparse
import base64
import os
import re
import statistics
import sys
from itertools import combinations

from pandas import DataFrame
from rbpbench import benchlib
from scipy.stats import fisher_exact
from scipy.stats import mannwhitneyu
from scipy.stats import false_discovery_control  # Benjamini-Hochberg correction.

# from distutils.spawn import find_executable
# from typing import Optional
# from scipy.stats import ks_2samp
# from scipy.stats import wilcoxon

__version__ = "0.9"


################################################################################

def setup_argument_parser():
    """Setup argparse parser."""
    # Tool description text.
    help_description = """

    Evaluate CLIP-seq and other genomic region data using a comprehensive collection of known RBP binding motifs (RNA sequence + structure).
    RBPBench can be used for a variety of purposes, from RBP motif search in genomic regions, over motif co-occurrence analysis, 
    to benchmarking CLIP-seq peak callers, as well as comparisons across cell types and CLIP-seq protocols.

    """

    # Define argument parser.
    p = argparse.ArgumentParser(#add_help=False,
                                prog="rbpbench",
                                description=help_description)

    # Tool version.
    p.add_argument("-v", "--version", action="version",
                   version="rbpbench v" + __version__)

    # Add subparsers.
    subparsers = p.add_subparsers(help='Program modes')

    """
    Search motifs mode.
    """
    p_s = subparsers.add_parser('search',
                                help='Search motifs in genomic sites')
    p_s.set_defaults(which='search')
    # Add required arguments group.
    p_sm = p_s.add_argument_group("required arguments")
    # Required arguments for search.
    p_sm.add_argument("--in",
                   dest="in_sites",
                   type=str,
                   metavar='str',
                   required=True,
                   help="Genomic RBP binding sites (peak regions) file in BED format")
    p_sm.add_argument("--rbps",
                   dest="list_rbps",
                   type=str,
                   metavar='str',
                   nargs='+',
                   required=True,
                   help="List of RBP names to define RBP motifs used for search (--rbps rbp1 rbp2 .. ). To search with all available motifs, use --rbps ALL. NOTE: to search with user-provided motifs, set --rbps USER and provide --user-meme-xml and/or --user-cm")
    p_sm.add_argument("--genome",
                   dest="in_genome",
                   type=str,
                   metavar='str',
                   required = True,
                   help = "Genomic sequences file (currently supported formats: FASTA)")
    p_sm.add_argument("--out",
                   dest="out_folder",
                   type=str,
                   metavar='str',
                   required=True,
                   help="Results output folder")
    # Optional arguments for search.
    p_s.add_argument("--data-id",
                   dest="data_id",
                   type=str,
                   metavar='str',
                   default = "data_id",
                   help="Dataset ID to describe dataset, e.g. --data-id PUM2_eCLIP_K562, used in output tables and for generating the comparison reports (rbpbench compare)")
    p_s.add_argument("--method-id",
                   dest="method_id",
                   type=str,
                   metavar='str',
                   default = "method_id",
                   help="Method ID to describe peak calling method, e.g. --method-id clipper_idr, used in output tables and for generating the comparison reports (rbpbench compare)")
    p_s.add_argument("--run-id",
                   dest="run_id",
                   type=str,
                   metavar='str',
                   default = "run_id",
                   help="Run ID to describe rbpbench search job, e.g. --run-id RBP1_eCLIP_tool1, used in output tables and reports")
    p_s.add_argument("--user-rbp-id",
                   dest="user_rbp_id",
                   type=str,
                   metavar='str',
                   default = False,
                   help = "Provide RBP ID belonging to provided sequence or structure motif(s) (mandatory for --rbps USER)")
    p_s.add_argument("--user-meme-xml",
                   dest="user_meme_xml",
                   type=str,
                   metavar='str',
                   default = False,
                   help = "Provide MEME/DREME XML file containing sequence motif(s) to be used for the run (needs --rbps USER)")
    p_s.add_argument("--user-cm",
                   dest="user_cm",
                   type=str,
                   metavar='str',
                   default = False,
                   help = "Provide covariance model (.cm) file containing covariance model(s) to be used for the run (needs --rbps USER)")
    p_s.add_argument("--ext",
                   dest="ext_up_down",
                   type=str,
                   metavar='str',
                   default="0",
                   help="Up- and downstream extension of --in sites in nucleotides (nt). Set e.g. --ext 30 for 30 nt on both sides, or --ext 20,10 for different up- and downstream extension (default: 0)")
    p_s.add_argument("--motif-db",
                   dest="motif_db",
                   type=int,
                   default=1,
                   choices=[1, 2, 3],
                   help="Built-in motif database to use. 1: human RBP motifs full (259 RBPs, 605 motifs, \"catrapid.omics.v2.1.human.6plus\"), 2: human RBP motifs full (low frequencies not rounded, \"catrapid.omics.v2.1.human.6plus.noround\"), 3: human RBP motifs eCLIP (107 RBPs, 316 motifs, \"s6_refined_ic010.human.rounded.encode_rbps\") (default: 1)")
    p_s.add_argument("--custom-db",
                   dest="custom_db",
                   type=str,
                   metavar='str',
                   default = False,
                   help = "Provide custom motif database folder. Alternatively, provide single files via --custom-db-meme-xml, --custom-db-cm, --custom-db-info")
    p_s.add_argument("--custom-db-id",
                   dest="custom_db_id",
                   type=str,
                   metavar='str',
                   default = "custom",
                   help = "Set ID/name for provided custom motif database via --custom-db  (default: \"custom\")")
    p_s.add_argument("--custom-db-meme-xml",
                   dest="custom_db_meme_xml",
                   type=str,
                   metavar='str',
                   default = False,
                   help = "Provide custom motif database MEME/DREME XML file containing sequence motifs")
    p_s.add_argument("--custom-db-cm",
                   dest="custom_db_cm",
                   type=str,
                   metavar='str',
                   default = False,
                   help = "Provide custom motif database covariance model (.cm) file containing covariance model(s)")
    p_s.add_argument("--custom-db-info",
                   dest="custom_db_info",
                   type=str,
                   metavar='str',
                   default = False,
                   help = "Provide custom motif database info table file containing RBP ID -> motif ID -> motif type assignments")
    p_s.add_argument("--regex",
                   dest="regex",
                   type=str,
                   metavar='str',
                   help="Define regular expression (regex) DNA motif to include in search, e.g. --regex AAACC, --regex 'C[ACGT]AC[AC]', .. NOTE that after motif hit found in region, search continues right after motif hit")
    p_s.add_argument("--regex-id",
                   dest="regex_id",
                   type=str,
                   metavar='str',
                   default = "regex",
                   help="Set regex ID used as RBP ID and database ID associated to -regex hits (default: \"regex\")")
    p_s.add_argument("--motif-regex-id",
                   dest="motif_regex_id",
                   default = False,
                   action = "store_true",
                   help="Use --regex-id for motif ID as well. By default, regular expression string is used as motif ID for regex motif hits")
    p_s.add_argument("--regex-search-mode",
                   dest="regex_search_mode",
                   type=int,
                   default=1,
                   choices=[1, 2],
                   help="Define regex search mode. 1: when motif hit encountered, continue +1 after motif hit end position, 2: when motif hit encountered, continue +1 of motif hit start position (default: 1)")
    p_s.add_argument("--fimo-nt-freqs",
                   dest="fimo_nt_freqs",
                   type=str,
                   metavar='str',
                   default = False,
                   help = "Provide FIMO nucleotide frequencies (FIMO option: --bifile) file (default: use internal frequencies file optimized for human transcripts)")
    p_s.add_argument("--fimo-pval",
                   dest="fimo_pval",
                   type=float,
                   metavar='float',
                   default=0.001,
                   help="FIMO p-value threshold (FIMO option: --thresh) (default: 0.001)")
    p_s.add_argument("--bed-score-col",
                   dest="bed_score_col",
                   type=int,
                   metavar='int',
                   default=5,
                   help="--in BED score column used for p-value calculations. BED score can be e.g. log2 fold change or -log10 p-value of the region (default: 5)")
    p_s.add_argument("--wrs-mode",
                   dest="wrs_mode",
                   type=int,
                   default=1,
                   choices=[1, 2],
                   help="Defines Wilcoxon rank sum test alternative hypothesis for testing whether motif-containing regions have significantly different scores. 1: test for higher (greater) scores, 2: test for lower (less) scores (default: 1)")
    p_s.add_argument("--fisher-mode",
                   dest="fisher_mode",
                   type=int,
                   default=1,
                   choices=[1, 2, 3],
                   help="Defines Fisher exact test alternative hypothesis for testing co-occurrences of RBP motifs. 1: greater, 2: two-sided, 3: less (default: 1)")
    p_s.add_argument("--unstranded",
                   dest="unstranded",
                   default = False,
                   action = "store_true",
                   help = "Set if --in BED regions are NOT strand-specific, i.e., to look for motifs on both strands of the provided regions. Note that the two strands of a region will still be counted as one region (change with --unstranded-ct) (default: False)")
    p_s.add_argument("--unstranded-ct",
                   dest="unstranded_ct",
                   default = False,
                   action = "store_true",
                   help = "Count each --in region twice for RBP hit statistics when --unstranded is enabled. By default, two strands of one region are counted as one region for RBP hit statistics")
    p_s.add_argument("--report",
                   dest="report",
                   default = False,
                   action = "store_true",
                   help = "Generate an .html report containing RBP co-occurrence / correlation statistics and plots (default: False)")
    p_s.add_argument("--plot-motifs",
                   dest="plot_motifs",
                   default = False,
                   action = "store_true",
                   help = "Visualize selected sequence motifs, by outputting sequence logos and motif hit statistics into a separate .html file (default: False)")
    p_s.add_argument("--add-motif-annot",
                   dest="add_motif_annot",
                   default = False,
                   action = "store_true",
                   help = "Add motif hit region annotations to --plot-motifs HTML file. This requires --plot-motifs and --gtf set (default: False)")
    p_s.add_argument("--cooc-pval-thr",
                   dest="cooc_pval_thr",
                   type=float,
                   metavar='float',
                   default=0.05,
                   help="RBP co-occurrence p-value threshold for reporting significant co-occurrences. NOTE that if --cooc-pval-mode Bonferroni is selected, this threshold gets further adjusted by Bonferroni correction (i.e. divided by number of tests). Threshold applies unchanged for BH corrected p-values as well as for disabled correction (default: 0.05)")
    p_s.add_argument("--cooc-pval-mode",
                   dest="cooc_pval_mode",
                   type=int,
                   default=1,
                   choices=[1, 2, 3],
                   help="Defines multiple testing correction mode for co-occurrence p-values. 1: Bonferroni, 2: Benjamini-Hochberg (BH), 3: no correction (default: 1)")
    p_s.add_argument("--max-motif-dist",
                   dest="max_motif_dist",
                   type=int,
                   metavar='int',
                   default=20,
                   help="Set maximum motif distance for RBP co-occurrence plot statistic inside hover boxes (default: 20)")
    p_s.add_argument("--disable-len-dist-plot",
                   dest="disable_len_dist_plot",
                   default = False,
                   action = "store_true",
                   help = "Disable input sequence length distribution plot in HTML report (default: False)")
    p_s.add_argument("--upset-plot-min-degree",
                   dest="upset_plot_min_degree",
                   type=int,
                   metavar='int',
                   default=2,
                   help="Upset plot minimum degree parameter (default: 2)")
    p_s.add_argument("--upset-plot-max-degree",
                   dest="upset_plot_max_degree",
                   type=int,
                   metavar='int',
                   default=None,
                   help="Upset plot maximum degree. By default no maximum degree is set. Useful to look at specific degrees only (together with --upset-plot-min-degree), e.g. 2 or 2 to 3 (default: None)")
    p_s.add_argument("--upset-plot-min-subset-size",
                   dest="upset_plot_min_subset_size",
                   type=int,
                   metavar='int',
                   default=5,
                   help="Upset plot minimum subset size (default: 5)")
    p_s.add_argument("--upset-plot-max-subset-rank",
                   dest="upset_plot_max_subset_rank",
                   type=int,
                   metavar='int',
                   default=25,
                   help="Upset plot maximum subset rank to plot. All tied subsets are included (default: 25)")
    p_s.add_argument("--upset-plot-max-rbp-rank",
                   dest="upset_plot_max_rbp_rank",
                   type=int,
                   metavar='int',
                   default=None,
                   help="Maximum RBP hit region count rank. Set this to limit the amount of RBPs included in upset plot (+ statistic !) to top --upset-plot-max-rbp-rank RBPs. By default all RBPs are included (default: None)")
    p_s.add_argument("--upset-plot-min-rbp-count",
                   dest="upset_plot_min_rbp_count",
                   type=int,
                   metavar='int',
                   default=0,
                   help="Minimum amount of input sites containing motifs for an RBP in order for the RBP to be included in upset plot (+ statistic !). By default, all RBPs are included, also RBPs without hit regions (default: 0)")
    p_s.add_argument("--gtf",
                   dest="in_gtf",
                   type=str,
                   metavar='str',
                   default = False,
                   help = "Input GTF file for genomic region annotations + related plots (e.g. from GENCODE or Ensembl). By default the most prominent transcripts will be extracted and used for functional annotation. Alternatively, provide a list of expressed transcripts via --tr-list (together with --gtf containing the transcripts). Note that only features on standard chromosomes (1,2,..,X,Y,MT) are currently used for annotation")
    p_s.add_argument("--tr-list",
                   dest="tr_list",
                   type=str,
                   metavar='str',
                   default = False,
                   help = "Supply file with transcript IDs (one ID per row) to define which transcripts to use from --gtf for genomic annoation of input regions")
    p_s.add_argument("--tr-types",
                   dest="tr_types_list",
                   type=str,
                   metavar='str',
                   nargs='+',
                   help="List of transcript biotypes to consider for genomic region annotations. By default an internal selection of transcript biotypes is used (in addition to intron, CDS, UTR, intergenic). Note that provided biotype strings need to be in GTF file")
    p_s.add_argument("--gtf-feat-min-overlap",
                   dest="gtf_feat_min_overlap",
                   type=float,
                   metavar='float',
                   default=0.1,
                   help="Minimum amount of overlap required for a region to be assigned to a GTF feature (if less or no overlap, region will be assigned to \"intergenic\") (default: 0.1)")
    p_s.add_argument("--add-all-reg-bar",
                   dest="add_all_reg_bar",
                   default = False,
                   action = "store_true",
                   help = "Add region annotations for all input regions to stacked bar plot (default: False)")
    p_s.add_argument("--set-rbp-id",
                   dest="set_rbp_id",
                   type=str,
                   metavar='str',
                   default = None,
                   help = "Set reference RBP ID to plot motif distances relative to motifs from this RBP (needs to be one of the selected RBP IDs!). Motif plot will be centered on best scoring motif of the RBP for each region")
    p_s.add_argument("--motif-distance-plot-range",
                   dest="motif_distance_plot_range",
                   type=int,
                   metavar='int',
                   default=60,
                   help="Set range of motif distance plot. I.e., centered on the set RBP (--set-rbp-id) motifs, motifs within minus and plus --motif-distance-plot-range will be plotted (default: 50)")
    p_s.add_argument("--motif-min-pair-count",
                   dest="motif_min_pair_count",
                   type=int,
                   metavar='int',
                   default=10,
                   help="On single motif level, minimum count of co-occurrences of a motif with set RBP ID (--set-rbp-id) motif to be reported and plotted (default: 10)")
    p_s.add_argument("--rbp-min-pair-count",
                   dest="rbp_min_pair_count",
                   type=int,
                   metavar='int',
                   default=10,
                   help="On RBP level, minimum amount of co-occurrences of motifs for an RBP ID compared to set RBP ID (--set-rbp-id) motifs to be reported and plotted (default: 10)")
    p_s.add_argument("--plot-abs-paths",
                   dest="plot_abs_paths",
                   default = False,
                   action = "store_true",
                   help = "Store plot files with absolute paths in HTML files. Default is relative paths (default: False)")
    p_s.add_argument("--meme-no-check",
                   dest="meme_disable_check",
                   default = False,
                   action = "store_true",
                   help = "Disable MEME version check. Make sure --meme-no-pgc is set if MEME version >= 5.5.4 is installed! (default: False)")
    p_s.add_argument("--meme-no-pgc",
                   dest="meme_no_pgc",
                   default = False,
                   action = "store_true",
                   help = "Manually set MEME's FIMO --no-pgc option (required for MEME version >= 5.5.4). Make sure that MEME >= 5.5.4 is installed! (default: False)")
    p_s.add_argument("--plotly-js-mode",
                   dest="plotly_js_mode",
                   type=int,
                   default=1,
                   choices=[1, 2, 3, 4, 5, 6, 7],
                   help = "Define how to provide plotly .js file. 1: use online version via \"cdn\" (requires internet connection). 2: link to packaged plotly .js file. 3: copy plotly .js file to plots output folder. 4: include plotly .js code in plotly HTML. 5: put web version link and plotly plot codes into main HTML. 6: put local version link and plotly plot codes in main HTML. 7: put plotly js and plotly plot codes into main HTML! (default: 1)")
    p_s.add_argument("--sort-js-mode",
                   dest="sort_js_mode",
                   type=int,
                   default=1,
                   choices=[1, 2, 3],
                   help = "Define how to provide sorttable.js file. 1: link to packaged .js file. 2: copy .js file to plots output folder. 3: include .js code in HTML (default: 1)")

    """
    Batch mode.
    """
    p_b = subparsers.add_parser('batch',
                                help='Search motifs on > 1 dataset')
    p_b.set_defaults(which='batch')
    # Add required arguments group.
    p_bm = p_b.add_argument_group("required arguments")
    # Required arguments for batch.
    p_bm.add_argument("--bed",
                   dest="bed_files",
                   type=str,
                   metavar='str',
                   nargs='+',
                   required=True,
                   help="Provide either: a folder with BED files (e.g. --bed clipper_bed), a list of BED files to search for motifs, or a table file defining files and settings. If folder, RBP IDs should be part of BED file names, like: RBP1_...bed, RBP2_...bed. If list of BED files, define RBP IDs with --rbp-list. If table file, see manual for the correct format")
    p_bm.add_argument("--genome",
                   dest="in_genome",
                   type=str,
                   metavar='str',
                   required = True,
                   help = "Genomic sequences file (currently supported formats: FASTA)")
    p_bm.add_argument("--out",
                   dest="out_folder",
                   type=str,
                   metavar='str',
                   required=True,
                   help="Batch job results output folder")
    # Optional arguments for batch.
    p_b.add_argument("--rbp-list",
                   dest="list_rbp_ids",
                   type=str,
                   metavar='str',
                   nargs='+',
                   help="List of RBP names to define RBP motifs used for search. One --rbp-list RBP ID for each --bed BED file (NOTE: order needs to correspond to --bed-list)")
    p_b.add_argument("--data-list",
                   dest="list_data_ids",
                   type=str,
                   metavar='str',
                   nargs='+',
                   help="List of data IDs to describe datasets given by -bed-list (NOTE: order needs to correspond to --bed order). Alternatively, use --data-id to set method for all datasets")
    p_b.add_argument("--data-id",
                   dest="data_id",
                   type=str,
                   metavar='str',
                   default = "data_id",
                   help="Data ID to describe data for given datasets, e.g. --method-id k562_eclip, used in output tables and for generating the comparison reports (rbpbench compare)")
    p_b.add_argument("--method-list",
                   dest="list_method_ids",
                   type=str,
                   metavar='str',
                   nargs='+',
                   help="List of method IDs to describe datasets given by -bed-list (NOTE: order needs to correspond to --bed order). Alternatively, use --method-id to set method for all datasets")
    p_b.add_argument("--method-id",
                   dest="method_id",
                   type=str,
                   metavar='str',
                   default = "method_id",
                   help="Method ID to describe peak calling method for given datasets, e.g. --method-id clipper_idr, used in output tables and for generating the comparison reports (rbpbench compare)")
    p_b.add_argument("--run-id",
                   dest="run_id",
                   type=str,
                   metavar='str',
                   default = "run_id",
                   help="Run ID to describe rbpbench search job, e.g. --run-id RBP1_eCLIP_tool1, used in output tables and reports")
    p_b.add_argument("--ext",
                   dest="ext_up_down",
                   type=str,
                   metavar='str',
                   default="0",
                   help="Up- and downstream extension of --in sites in nucleotides (nt). Set e.g. --ext 30 for 30 nt on both sides, or --ext 20,10 for different up- and downstream extension (default: 0)")
    p_b.add_argument("--motif-db",
                   dest="motif_db",
                   type=int,
                   default=1,
                   choices=[1, 2, 3],
                   help="Built-in motif database to use. 1: human RBP motifs full (259 RBPs, 605 motifs, \"catrapid.omics.v2.1.human.6plus\"), 2: human RBP motifs full (low frequencies not rounded, \"catrapid.omics.v2.1.human.6plus.noround\"), 3: human RBP motifs eCLIP (107 RBPs, 316 motifs, \"s6_refined_ic010.human.rounded.encode_rbps\") (default: 1)")
    p_b.add_argument("--custom-db",
                   dest="custom_db",
                   type=str,
                   metavar='str',
                   default = False,
                   help = "Provide custom motif database folder")
    p_b.add_argument("--custom-db-id",
                   dest="custom_db_id",
                   type=str,
                   metavar='str',
                   default = "custom",
                   help = "Set ID/name for provided custom motif database via --custom-db  (default: \"custom\")")
    p_b.add_argument("--custom-db-meme-xml",
                   dest="custom_db_meme_xml",
                   type=str,
                   metavar='str',
                   default = False,
                   help = "Provide custom motif database MEME/DREME XML file containing sequence motifs")
    p_b.add_argument("--custom-db-cm",
                   dest="custom_db_cm",
                   type=str,
                   metavar='str',
                   default = False,
                   help = "Provide custom motif database covariance model (.cm) file containing covariance model(s)")
    p_b.add_argument("--custom-db-info",
                   dest="custom_db_info",
                   type=str,
                   metavar='str',
                   default = False,
                   help = "Provide custom motif database info table file containing RBP ID -> motif ID -> motif type assignments")
    p_b.add_argument("--regex",
                   dest="regex",
                   type=str,
                   metavar='str',
                   help="Define regular expression (regex) DNA motif to include in search, e.g. --regex AAACC, --regex 'C[ACGT]AC[AC]', .. NOTE that after motif hit found in region, search continues right after motif hit")
    p_b.add_argument("--regex-search-mode",
                   dest="regex_search_mode",
                   type=int,
                   default=1,
                   choices=[1, 2],
                   help="Define regex search mode. 1: when motif hit encountered, continue +1 after motif hit end position, 2: when motif hit encountered, continue +1 of motif hit start position (default: 1)")
    p_b.add_argument("--max-motif-dist",
                   dest="max_motif_dist",
                   type=int,
                   metavar='int',
                   default=20,
                   help="Set maximum motif distance for regex-RBP co-occurrence statistic in HTML report (default: 20)")

    p_b.add_argument("--fimo-nt-freqs",
                   dest="fimo_nt_freqs",
                   type=str,
                   metavar='str',
                   default = False,
                   help = "Provide FIMO nucleotide frequencies (FIMO option: --bifile) file (default: use internal frequencies file optimized for human transcripts)")
    p_b.add_argument("--fimo-pval",
                   dest="fimo_pval",
                   type=float,
                   metavar='float',
                   default=0.001,
                   help="FIMO p-value threshold (FIMO option: --thresh) (default: 0.001)")
    p_b.add_argument("--bed-score-col",
                   dest="bed_score_col",
                   type=int,
                   metavar='int',
                   default=5,
                   help="--in BED score column used for p-value calculations. BED score can be e.g. log2 fold change or -log10 p-value of the region (default: 5)")
    p_b.add_argument("--wrs-mode",
                   dest="wrs_mode",
                   type=int,
                   default=1,
                   choices=[1, 2],
                   help="Defines Wilcoxon rank sum test alternative hypothesis for testing whether motif-containing regions have significantly different scores. 1: test for higher (greater) scores, 2: test for lower (less) scores (default: 1)")
    p_b.add_argument("--fisher-mode",
                   dest="fisher_mode",
                   type=int,
                   default=1,
                   choices=[1, 2, 3],
                   help="Defines Fisher exact test alternative hypothesis for testing co-occurrences of RBP motifs. 1: greater, 2: two-sided, 3: less (default: 1)")
    p_b.add_argument("--unstranded",
                   dest="unstranded",
                   default = False,
                   action = "store_true",
                   help = "Set if --in BED regions are NOT strand-specific, i.e., to look for motifs on both strands of the provided regions. Note that the two strands of a region will still be counted as one region (change with --unstranded-ct) (default: False)")
    p_b.add_argument("--unstranded-ct",
                   dest="unstranded_ct",
                   default = False,
                   action = "store_true",
                   help = "Count each --in region twice for RBP hit statistics when --unstranded is enabled. By default, two strands of one region are counted as one region for RBP hit statistics")
    p_b.add_argument("--report",
                   dest="report",
                   default = False,
                   action = "store_true",
                   help = "Generate an .html report containing various plots to compare input datasets (default: False)")
    p_b.add_argument("--kmer-size",
                   dest="kmer_size",
                   type=int,
                   metavar='int',
                   default=5,
                   help="K-mer size for comparative plots (default: 5)")
    p_b.add_argument("--gtf",
                   dest="in_gtf",
                   type=str,
                   metavar='str',
                   default = False,
                   help = "Input GTF file with genomic annotations to generate genomic region annotation plots for each input BED file (output to HTML report). By default the most prominent transcripts will be extracted and used for functional annotation. Alternatively, provide a list of expressed transcripts via --tr-list (together with --gtf containing the transcripts). Note that only features on standard chromosomes (1,2,..,X,Y,MT) are currently used for annotation")
    p_b.add_argument("--tr-list",
                   dest="tr_list",
                   type=str,
                   metavar='str',
                   default = False,
                   help = "Supply file with transcript IDs (one ID per row) to define which transcripts to use from --gtf for genomic region annotations plots")
    p_b.add_argument("--tr-types",
                   dest="tr_types_list",
                   type=str,
                   metavar='str',
                   nargs='+',
                   help="List of transcript biotypes to consider for genomic region annotations plots. By default an internal selection of transcript biotypes is used (in addition to intron, CDS, UTR, intergenic). Note that provided biotype strings need to be in --gtf GTF file")
    p_b.add_argument("--gtf-feat-min-overlap",
                   dest="gtf_feat_min_overlap",
                   type=float,
                   metavar='float',
                   default=0.1,
                   help="Minimum amount of overlap required for a region to be assigned to a GTF feature (if less or no overlap, region will be assigned to \"intergenic\") (default: 0.1)")
    p_b.add_argument("--plot-abs-paths",
                   dest="plot_abs_paths",
                   default = False,
                   action = "store_true",
                   help = "Store plot files with absolute paths in HTML files. Default is relative paths (default: False)")
    p_b.add_argument("--plotly-js-mode",
                   dest="plotly_js_mode",
                   type=int,
                   default=1,
                   choices=[1, 2, 3, 4, 5, 6, 7],
                   help = "Define how to provide plotly .js file. 1: use online version via \"cdn\" (requires internet connection). 2: link to packaged plotly .js file. 3: copy plotly .js file to plots output folder. 4: include plotly .js code in plotly HTML. 5: put web version link and plotly plot codes into main HTML. 6: put local version link and plotly plot codes in main HTML. 7: put plotly js and plotly plot codes into main HTML! (default: 1)")
    p_b.add_argument("--sort-js-mode",
                   dest="sort_js_mode",
                   type=int,
                   default=1,
                   choices=[1, 2, 3],
                   help = "Define how to provide sorttable.js file. 1: link to packaged .js file. 2: copy .js file to plots output folder. 3: include .js code in HTML (default: 1)")
    p_b.add_argument("--meme-no-check",
                   dest="meme_disable_check",
                   default = False,
                   action = "store_true",
                   help = "Disable MEME version check. Make sure --meme-no-pgc is set if MEME version >= 5.5.4 is installed! (default: False)")
    p_b.add_argument("--meme-no-pgc",
                   dest="meme_no_pgc",
                   default = False,
                   action = "store_true",
                   help = "Manually set MEME's FIMO --no-pgc option (required for MEME version >= 5.5.4). Make sure that MEME >= 5.5.4 is installed! (default: False)")

    """
    Sequence search motifs mode.

    """
    p_ss = subparsers.add_parser('searchseq',
                                help='Search motifs in sequences')
    p_ss.set_defaults(which='searchseq')
    # Add required arguments group.
    p_ssm = p_ss.add_argument_group("required arguments")
    # Required arguments for searchseq.
    p_ssm.add_argument("--in",
                   dest="in_seqs",
                   type=str,
                   metavar='str',
                   required=True,
                   help="Input FASTA file with DNA/RNA sequences used for motif search")
    p_ssm.add_argument("--rbps",
                   dest="list_rbps",
                   type=str,
                   metavar='str',
                   nargs='+',
                   required=True,
                   help="List of RBP names to define RBP motifs used for search (--rbps rbp1 rbp2 .. ). To search with all available motifs, use --rbps ALL. NOTE: to search with user-provided motifs, set --rbps USER and provide --user-meme-xml and/or --user-cm")
    p_ssm.add_argument("--out",
                   dest="out_folder",
                   type=str,
                   metavar='str',
                   required=True,
                   help="Results output folder")
    # Optional arguments for searchseq.
    p_ss.add_argument("--data-id",
                   dest="data_id",
                   type=str,
                   metavar='str',
                   default = "data_id",
                   help="Dataset ID to describe dataset, e.g. --data-id PUM2_eCLIP_K562, used in output tables and for generating the comparison reports (rbpbench compare)")
    p_ss.add_argument("--method-id",
                   dest="method_id",
                   type=str,
                   metavar='str',
                   default = "method_id",
                   help="Method ID to describe peak calling method, e.g. --method-id clipper_idr, used in output tables and for generating the comparison reports (rbpbench compare)")
    p_ss.add_argument("--user-rbp-id",
                   dest="user_rbp_id",
                   type=str,
                   metavar='str',
                   default = False,
                   help = "Provide RBP ID belonging to provided sequence or structure motif(s) (mandatory for --rbps USER)")
    p_ss.add_argument("--user-meme-xml",
                   dest="user_meme_xml",
                   type=str,
                   metavar='str',
                   default = False,
                   help = "Provide MEME/DREME XML file containing sequence motif(s) to be used for the run (needs --rbps USER)")
    p_ss.add_argument("--user-cm",
                   dest="user_cm",
                   type=str,
                   metavar='str',
                   default = False,
                   help = "Provide covariance model (.cm) file containing covariance model(s) to be used for the run (needs --rbps USER)")
    p_ss.add_argument("--motif-db",
                   dest="motif_db",
                   type=int,
                   default=1,
                   choices=[1, 2, 3],
                   help="Built-in motif database to use. 1: human RBP motifs full (259 RBPs, 605 motifs, \"catrapid.omics.v2.1.human.6plus\"), 2: human RBP motifs full (low frequencies not rounded, \"catrapid.omics.v2.1.human.6plus.noround\"), 3: human RBP motifs eCLIP (107 RBPs, 316 motifs, \"s6_refined_ic010.human.rounded.encode_rbps\") (default: 1)")
    p_ss.add_argument("--custom-db",
                   dest="custom_db",
                   type=str,
                   metavar='str',
                   default = False,
                   help = "Provide custom motif database folder. Alternatively, provide single files via --custom-db-meme-xml, --custom-db-cm, --custom-db-info")
    p_ss.add_argument("--custom-db-id",
                   dest="custom_db_id",
                   type=str,
                   metavar='str',
                   default = "custom",
                   help = "Set ID/name for provided custom motif database via --custom-db  (default: \"custom\")")
    p_ss.add_argument("--custom-db-meme-xml",
                   dest="custom_db_meme_xml",
                   type=str,
                   metavar='str',
                   default = False,
                   help = "Provide custom motif database MEME/DREME XML file containing sequence motifs")
    p_ss.add_argument("--custom-db-cm",
                   dest="custom_db_cm",
                   type=str,
                   metavar='str',
                   default = False,
                   help = "Provide custom motif database covariance model (.cm) file containing covariance model(s)")
    p_ss.add_argument("--custom-db-info",
                   dest="custom_db_info",
                   type=str,
                   metavar='str',
                   default = False,
                   help = "Provide custom motif database info table file containing RBP ID -> motif ID -> motif type assignments")
    p_ss.add_argument("--fimo-nt-freqs",
                   dest="fimo_nt_freqs",
                   type=str,
                   metavar='str',
                   default = False,
                   help = "Provide FIMO nucleotide frequencies (FIMO option: --bifile) file (default: use internal frequencies file optimized for human transcripts)")
    p_ss.add_argument("--fimo-pval",
                   dest="fimo_pval",
                   type=float,
                   metavar='float',
                   default=0.001,
                   help="FIMO p-value threshold (FIMO option: --thresh) (default: 0.001)")
    p_ss.add_argument("--meme-no-check",
                   dest="meme_disable_check",
                   default = False,
                   action = "store_true",
                   help = "Disable MEME version check. Make sure --meme-no-pgc is set if MEME version >= 5.5.4 is installed! (default: False)")
    p_ss.add_argument("--meme-no-pgc",
                   dest="meme_no_pgc",
                   default = False,
                   action = "store_true",
                   help = "Manually set MEME's FIMO --no-pgc option (required for MEME version >= 5.5.4). Make sure that MEME >= 5.5.4 is installed! (default: False)")
    p_ss.add_argument("--make-uniq-headers",
                   dest="make_uniq_headers",
                   default = False,
                   action = "store_true",
                   help = "Make FASTA headers unique. By default, an error is thrown if identical FASTA headers are encountered (default: False)")
    p_ss.add_argument("--header-id",
                   dest="header_id",
                   type=str,
                   metavar='str',
                   default = "seq",
                   help = "Constant header ID part used if --make-uniq-headers set (default: \"seq\")")
    p_ss.add_argument("--plot-motifs",
                   dest="plot_motifs",
                   default = False,
                   action = "store_true",
                   help = "Visualize selected sequence motifs, by outputting sequence logos and motif hit statistics into .html file (default: False)")
    p_ss.add_argument("--plot-abs-paths",
                   dest="plot_abs_paths",
                   default = False,
                   action = "store_true",
                   help = "Store plot files with absolute paths in HTML files. Default is relative paths (default: False)")
    p_ss.add_argument("--sort-js-mode",
                   dest="sort_js_mode",
                   type=int,
                   default=1,
                   choices=[1, 2, 3],
                   help = "Define how to provide sorttable.js file. 1: link to packaged .js file. 2: copy .js file to plots output folder. 3: include .js code in HTML (default: 1)")

    """
    Regex motif search mode.
    
    """
    p_sr = subparsers.add_parser('searchregex',
                                help='Search regex in genomic sites or sequences')
    p_sr.set_defaults(which='searchregex')
    # Add required arguments group.
    p_srm = p_sr.add_argument_group("required arguments")
    # Required arguments for searchregex.
    p_srm.add_argument("--in",
                   dest="in_file",
                   type=str,
                   metavar='str',
                   required=True,
                   help="Input FASTA file with DNA/RNA sequences or BED file (>= 6 column format) with genomic regions used for regex search. NOTE that sequences will be converted to DNA and uppercased before search. If BED file, also provide --genome FASTA file")
    p_srm.add_argument("--regex",
                   dest="regex",
                   type=str,
                   metavar='str',
                   required=True,
                   help="Define regular expression (regex) DNA motif used for search, e.g. --regex AAAAA, --regex 'C[ACGT]AC[AC]', .. NOTE that after motif hit found in region, search continues right after motif hit")
    p_srm.add_argument("--out",
                   dest="out_folder",
                   type=str,
                   metavar='str',
                   required=True,
                   help="Results output folder")
    # Optional arguments for searchregex.
    p_sr.add_argument("--genome",
                   dest="in_genome",
                   type=str,
                   metavar='str',
                   help = "Genomic sequences FASTA file (required if --in is BED)")
    p_sr.add_argument("--make-uniq-headers",
                   dest="make_uniq_headers",
                   default = False,
                   action = "store_true",
                   help = "Make sequence IDs (FASTA header or BED column 4 IDs) unique. By default, an error is thrown if identical IDs are encountered (default: False)")
    p_sr.add_argument("--header-id",
                   dest="header_id",
                   type=str,
                   metavar='str',
                   default = "reg",
                   help = "Constant header ID part used if --make-uniq-headers set (default: \"reg\")")
    p_sr.add_argument("--regex-search-mode",
                   dest="regex_search_mode",
                   type=int,
                   default=1,
                   choices=[1, 2],
                   help="Define regex search mode. 1: when motif hit encountered, continue +1 after motif hit end position, 2: when motif hit encountered, continue +1 of motif hit start position (default: 1)")
    p_sr.add_argument("--add-zero-hits",
                   dest="add_zero_hits",
                   default = False,
                   action = "store_true",
                   help = "Also add regions with 0 hits to output BED file (hit count in column 5) (default: False)")


    """
    Search motifs in long regions mode.
    
    """
    p_sl = subparsers.add_parser('searchlong',
                                help='Search motifs in long genomic regions')
    p_sl.set_defaults(which='searchlong')
    # Add required arguments group.
    p_slm = p_sl.add_argument_group("required arguments")
    # Required arguments for searchlong.
    p_slm.add_argument("--in",
                   dest="in_file",
                   type=str,
                   metavar='str',
                   required=True,
                   help="Genomic regions file in BED format OR file with transcript IDs (one ID per row) to define genomic regions in which to search for motifs (requires --gtf)")
    p_slm.add_argument("--rbps",
                   dest="list_rbps",
                   type=str,
                   metavar='str',
                   nargs='+',
                   required=True,
                   help="List of RBP names to define RBP motifs used for search (--rbps rbp1 rbp2 .. ). To search with all available motifs, use --rbps ALL. NOTE: to search with user-provided motifs, set --rbps USER and provide --user-meme-xml and/or --user-cm")
    p_slm.add_argument("--genome",
                   dest="in_genome",
                   type=str,
                   metavar='str',
                   required = True,
                   help = "Genomic sequences file (currently supported formats: FASTA)")
    p_slm.add_argument("--out",
                   dest="out_folder",
                   type=str,
                   metavar='str',
                   required=True,
                   help="Results output folder")
    # Optional arguments for searchlong.
    p_sl.add_argument("--data-id",
                   dest="data_id",
                   type=str,
                   metavar='str',
                   default = "data_id",
                   help="Dataset ID")
    p_sl.add_argument("--method-id",
                   dest="method_id",
                   type=str,
                   metavar='str',
                   default = "method_id",
                   help="Method ID")
    p_sl.add_argument("--run-id",
                   dest="run_id",
                   type=str,
                   metavar='str',
                   default = "run_id",
                   help="Run ID")
    p_sl.add_argument("--user-rbp-id",
                   dest="user_rbp_id",
                   type=str,
                   metavar='str',
                   default = False,
                   help = "Provide RBP ID belonging to provided sequence or structure motif(s) (mandatory for --rbps USER)")
    p_sl.add_argument("--user-meme-xml",
                   dest="user_meme_xml",
                   type=str,
                   metavar='str',
                   default = False,
                   help = "Provide MEME/DREME XML file containing sequence motif(s) to be used for the run (needs --rbps USER)")
    p_sl.add_argument("--user-cm",
                   dest="user_cm",
                   type=str,
                   metavar='str',
                   default = False,
                   help = "Provide covariance model (.cm) file containing covariance model(s) to be used for the run (needs --rbps USER)")
    p_sl.add_argument("--motif-db",
                   dest="motif_db",
                   type=int,
                   default=1,
                   choices=[1, 2, 3],
                   help="Built-in motif database to use. 1: human RBP motifs full (259 RBPs, 605 motifs, \"catrapid.omics.v2.1.human.6plus\"), 2: human RBP motifs full (low frequencies not rounded, \"catrapid.omics.v2.1.human.6plus.noround\"), 3: human RBP motifs eCLIP (107 RBPs, 316 motifs, \"s6_refined_ic010.human.rounded.encode_rbps\") (default: 1)")
    p_sl.add_argument("--custom-db",
                   dest="custom_db",
                   type=str,
                   metavar='str',
                   default = False,
                   help = "Provide custom motif database folder. Alternatively, provide single files via --custom-db-meme-xml, --custom-db-cm, --custom-db-info")
    p_sl.add_argument("--custom-db-id",
                   dest="custom_db_id",
                   type=str,
                   metavar='str',
                   default = "custom",
                   help = "Set ID/name for provided custom motif database via --custom-db  (default: \"custom\")")
    p_sl.add_argument("--custom-db-meme-xml",
                   dest="custom_db_meme_xml",
                   type=str,
                   metavar='str',
                   default = False,
                   help = "Provide custom motif database MEME/DREME XML file containing sequence motifs")
    p_sl.add_argument("--custom-db-cm",
                   dest="custom_db_cm",
                   type=str,
                   metavar='str',
                   default = False,
                   help = "Provide custom motif database covariance model (.cm) file containing covariance model(s)")
    p_sl.add_argument("--custom-db-info",
                   dest="custom_db_info",
                   type=str,
                   metavar='str',
                   default = False,
                   help = "Provide custom motif database info table file containing RBP ID -> motif ID -> motif type assignments")
    p_sl.add_argument("--regex",
                   dest="regex",
                   type=str,
                   metavar='str',
                   help="Define regular expression (regex) DNA motif to include in search, e.g. --regex AAACC, --regex 'C[ACGT]AC[AC]', .. NOTE that after motif hit found in region, search continues right after motif hit")
    p_sl.add_argument("--regex-id",
                   dest="regex_id",
                   type=str,
                   metavar='str',
                   default = "regex",
                   help="Set regex ID used as RBP ID and database ID associated to -regex hits (default: \"regex\")")
    p_sl.add_argument("--motif-regex-id",
                   dest="motif_regex_id",
                   default = False,
                   action = "store_true",
                   help="Use --regex-id for motif ID as well. By default, regular expression string is used as motif ID for regex motif hits")
    p_sl.add_argument("--regex-search-mode",
                   dest="regex_search_mode",
                   type=int,
                   default=1,
                   choices=[1, 2],
                   help="Define regex search mode. 1: when motif hit encountered, continue +1 after motif hit end position, 2: when motif hit encountered, continue +1 of motif hit start position (default: 1)")
    p_sl.add_argument("--fimo-nt-freqs",
                   dest="fimo_nt_freqs",
                   type=str,
                   metavar='str',
                   default = False,
                   help = "Provide FIMO nucleotide frequencies (FIMO option: --bifile) file (default: use internal frequencies file optimized for human transcripts)")
    p_sl.add_argument("--fimo-pval",
                   dest="fimo_pval",
                   type=float,
                   metavar='float',
                   default=0.001,
                   help="FIMO p-value threshold (FIMO option: --thresh) (default: 0.001)")
    p_sl.add_argument("--plot-motifs",
                   dest="plot_motifs",
                   default = False,
                   action = "store_true",
                   help = "Visualize selected sequence motifs, by outputting sequence logos and motif hit statistics into a separate .html file (default: False)")
    p_sl.add_argument("--gtf",
                   dest="in_gtf",
                   type=str,
                   metavar='str',
                   default = False,
                   help = "Input GTF file with genomic annotations to generate genomic region annotation plots (output to motif statistics HTML). By default the most prominent transcripts will be extracted and used for functional annotation. Alternatively, provide a list of expressed transcripts via --tr-list (together with --gtf containing the transcripts). Note that only features on standard chromosomes (1,2,..,X,Y,MT) are currently used for annotation")
    p_sl.add_argument("--tr-list",
                   dest="tr_list",
                   type=str,
                   metavar='str',
                   default = False,
                   help = "Supply file with transcript IDs (one ID per row) to define which transcripts to use from --gtf for genomic region annotations plots")
    p_sl.add_argument("--tr-types",
                   dest="tr_types_list",
                   type=str,
                   metavar='str',
                   nargs='+',
                   help="List of transcript biotypes to consider for genomic region annotations plots. By default an internal selection of transcript biotypes is used (in addition to intron, CDS, UTR, intergenic). Note that provided biotype strings need to be in --gtf GTF file")
    p_sl.add_argument("--gtf-feat-min-overlap",
                   dest="gtf_feat_min_overlap",
                   type=float,
                   metavar='float',
                   default=0.1,
                   help="Minimum amount of overlap required for a region to be assigned to a GTF feature (if less or no overlap, region will be assigned to \"intergenic\") (default: 0.1)")
    p_sl.add_argument("--plot-abs-paths",
                   dest="plot_abs_paths",
                   default = False,
                   action = "store_true",
                   help = "Store plot files with absolute paths in HTML report. Default is relative paths (default: False)")
    p_sl.add_argument("--meme-no-check",
                   dest="meme_disable_check",
                   default = False,
                   action = "store_true",
                   help = "Disable MEME version check. Make sure --meme-no-pgc is set if MEME version >= 5.5.4 is installed! (default: False)")
    p_sl.add_argument("--meme-no-pgc",
                   dest="meme_no_pgc",
                   default = False,
                   action = "store_true",
                   help = "Manually set MEME's FIMO --no-pgc option (required for MEME version >= 5.5.4). Make sure that MEME >= 5.5.4 is installed! (default: False)")
    p_sl.add_argument("--sort-js-mode",
                   dest="sort_js_mode",
                   type=int,
                   default=1,
                   choices=[1, 2, 3],
                   help = "Define how to provide sorttable.js file. 1: link to packaged .js file. 2: copy .js file to plots output folder. 3: include .js code in HTML (default: 1)")








    """
    Search motifs in spliced transcripts and look for co-occurrences for a set RBP.

    AALAMO
    
    """
    p_scr = subparsers.add_parser('searchcorna',
                                help='Search motifs in spliced RNA (+ check co-occurrence)')
    p_scr.set_defaults(which='searchcorna')
    # Add required arguments group.
    p_scrm = p_scr.add_argument_group("required arguments")
    # Required arguments for searchcorna.
    p_scrm.add_argument("--rbps",
                   dest="list_rbps",
                   type=str,
                   metavar='str',
                   nargs='+',
                   required=True,
                   help="List of RBP names to define RBP motifs used for search (--rbps rbp1 rbp2 .. ). To search with all available motifs, use --rbps ALL. NOTE: to search with user-provided motifs, set --rbps USER and provide --user-meme-xml and/or --user-cm")
    p_scrm.add_argument("--gtf",
                   dest="in_gtf",
                   type=str,
                   metavar='str',
                   required = True,
                   help = "Input GTF file with genomic annotations to extract spliced transcript sequences. By default most prominent transcripts for all genes will be extracted and used for motif search. Alternatively, provide a list of transcripts via --tr-list (together with --gtf containing the transcripts). Note that only features on standard chromosomes (1,2,..,X,Y,MT) are currently used for annotation")
    p_scrm.add_argument("--genome",
                   dest="in_genome",
                   type=str,
                   metavar='str',
                   required = True,
                   help = "Genomic sequences file (currently supported formats: FASTA)")
    p_scrm.add_argument("--out",
                   dest="out_folder",
                   type=str,
                   metavar='str',
                   required=True,
                   help="Results output folder")
    # Optional arguments for searchcorna.
    p_scr.add_argument("--set-rbp-id",
                   dest="set_rbp_id",
                   type=str,
                   metavar='str',
                   default = None,
                   help = "Set reference RBP ID to take motif hits from and look for co-occurrence around these motif hit positions (control context length around hits with --ext). NOTE that RBP ID has to be part of --rbps list. Alternatively, supply and set --regex as reference RBP (in sum >= 1 RBP needs to be supplied, otherwise no co-occurrence statistics are produced)")
    p_scr.add_argument("--ext",
                   dest="ext_up_down",
                   type=str,
                   metavar='str',
                   default="40",
                   help="Up- and downstream extension in nucleotides (nt) of motif hit regions from RBP set via --set-rbp-id (default: 40)")
    p_scr.add_argument("--mrna-only",
                   dest="mrna_only",
                   default = False,
                   action = "store_true",
                   help="Only use mRNAs from --gtf for motif search, instead of all most prominent transcripts (regardless of whether they are mRNAs or not (default: False)")
    p_scr.add_argument("--data-id",
                   dest="data_id",
                   type=str,
                   metavar='str',
                   default = "data_id",
                   help="Dataset ID")
    p_scr.add_argument("--method-id",
                   dest="method_id",
                   type=str,
                   metavar='str',
                   default = "method_id",
                   help="Method ID")
    p_scr.add_argument("--run-id",
                   dest="run_id",
                   type=str,
                   metavar='str',
                   default = "run_id",
                   help="Run ID")
    p_scr.add_argument("--user-rbp-id",
                   dest="user_rbp_id",
                   type=str,
                   metavar='str',
                   default = False,
                   help = "Provide RBP ID belonging to provided sequence or structure motif(s) (mandatory for --rbps USER)")
    p_scr.add_argument("--user-meme-xml",
                   dest="user_meme_xml",
                   type=str,
                   metavar='str',
                   default = False,
                   help = "Provide MEME/DREME XML file containing sequence motif(s) to be used for the run (needs --rbps USER)")
    p_scr.add_argument("--user-cm",
                   dest="user_cm",
                   type=str,
                   metavar='str',
                   default = False,
                   help = "Provide covariance model (.cm) file containing covariance model(s) to be used for the run (needs --rbps USER)")
    p_scr.add_argument("--motif-db",
                   dest="motif_db",
                   type=int,
                   default=1,
                   choices=[1, 2, 3],
                   help="Built-in motif database to use. 1: human RBP motifs full (259 RBPs, 605 motifs, \"catrapid.omics.v2.1.human.6plus\"), 2: human RBP motifs full (low frequencies not rounded, \"catrapid.omics.v2.1.human.6plus.noround\"), 3: human RBP motifs eCLIP (107 RBPs, 316 motifs, \"s6_refined_ic010.human.rounded.encode_rbps\") (default: 1)")
    p_scr.add_argument("--custom-db",
                   dest="custom_db",
                   type=str,
                   metavar='str',
                   default = False,
                   help = "Provide custom motif database folder. Alternatively, provide single files via --custom-db-meme-xml, --custom-db-cm, --custom-db-info")
    p_scr.add_argument("--custom-db-id",
                   dest="custom_db_id",
                   type=str,
                   metavar='str',
                   default = "custom",
                   help = "Set ID/name for provided custom motif database via --custom-db  (default: \"custom\")")
    p_scr.add_argument("--custom-db-meme-xml",
                   dest="custom_db_meme_xml",
                   type=str,
                   metavar='str',
                   default = False,
                   help = "Provide custom motif database MEME/DREME XML file containing sequence motifs")
    p_scr.add_argument("--custom-db-cm",
                   dest="custom_db_cm",
                   type=str,
                   metavar='str',
                   default = False,
                   help = "Provide custom motif database covariance model (.cm) file containing covariance model(s)")
    p_scr.add_argument("--custom-db-info",
                   dest="custom_db_info",
                   type=str,
                   metavar='str',
                   default = False,
                   help = "Provide custom motif database info table file containing RBP ID -> motif ID -> motif type assignments")
    p_scr.add_argument("--regex",
                   dest="regex",
                   type=str,
                   metavar='str',
                   help="Define regular expression (regex) DNA motif to include in search, e.g. --regex AAACC, --regex 'C[ACGT]AC[AC]', .. NOTE that after motif hit found in region, search continues right after motif hit")
    p_scr.add_argument("--regex-id",
                   dest="regex_id",
                   type=str,
                   metavar='str',
                   default = "regex",
                   help="Set regex ID used as RBP ID and database ID associated to -regex hits (default: \"regex\")")
    p_scr.add_argument("--motif-regex-id",
                   dest="motif_regex_id",
                   default = False,
                   action = "store_true",
                   help="Use --regex-id for motif ID as well. By default, regular expression string is used as motif ID for regex motif hits")
    p_scr.add_argument("--regex-search-mode",
                   dest="regex_search_mode",
                   type=int,
                   default=1,
                   choices=[1, 2],
                   help="Define regex search mode. 1: when motif hit encountered, continue +1 after motif hit end position, 2: when motif hit encountered, continue +1 of motif hit start position (default: 1)")
    p_scr.add_argument("--fimo-nt-freqs",
                   dest="fimo_nt_freqs",
                   type=str,
                   metavar='str',
                   default = False,
                   help = "Provide FIMO nucleotide frequencies (FIMO option: --bifile) file (default: use internal frequencies file optimized for human transcripts)")
    p_scr.add_argument("--fimo-pval",
                   dest="fimo_pval",
                   type=float,
                   metavar='float',
                   default=0.001,
                   help="FIMO p-value threshold (FIMO option: --thresh) (default: 0.001)")
    p_scr.add_argument("--tr-list",
                   dest="tr_list",
                   type=str,
                   metavar='str',
                   default = False,
                   help = "Supply file with transcript IDs (one ID per row) to define which transcripts to use from --gtf")
    p_scr.add_argument("--plot-abs-paths",
                   dest="plot_abs_paths",
                   default = False,
                   action = "store_true",
                   help = "Store plot files with absolute paths in HTML report. Default is relative paths (default: False)")
    p_scr.add_argument("--meme-no-check",
                   dest="meme_disable_check",
                   default = False,
                   action = "store_true",
                   help = "Disable MEME version check. Make sure --meme-no-pgc is set if MEME version >= 5.5.4 is installed! (default: False)")
    p_scr.add_argument("--meme-no-pgc",
                   dest="meme_no_pgc",
                   default = False,
                   action = "store_true",
                   help = "Manually set MEME's FIMO --no-pgc option (required for MEME version >= 5.5.4). Make sure that MEME >= 5.5.4 is installed! (default: False)")
    p_scr.add_argument("--plotly-js-mode",
                   dest="plotly_js_mode",
                   type=int,
                   default=1,
                   choices=[1, 2, 3, 4, 5, 6, 7],
                   help = "Define how to provide plotly .js file. 1: use online version via \"cdn\" (requires internet connection). 2: link to packaged plotly .js file. 3: copy plotly .js file to plots output folder. 4: include plotly .js code in plotly HTML. 5: put web version link and plotly plot codes into main HTML. 6: put local version link and plotly plot codes in main HTML. 7: put plotly js and plotly plot codes into main HTML! (default: 1)")
    p_scr.add_argument("--sort-js-mode",
                   dest="sort_js_mode",
                   type=int,
                   default=1,
                   choices=[1, 2, 3],
                   help = "Define how to provide sorttable.js file. 1: link to packaged .js file. 2: copy .js file to plots output folder. 3: include .js code in HTML (default: 1)")









    """
    Search motifs in mRNA sequences (i.e., spliced mRNA transcripts).
    
    """
    p_smr = subparsers.add_parser('searchmrna',
                                help='Search and plot motif hits in mRNA regions')
    p_smr.set_defaults(which='searchmrna')
    # Add required arguments group.
    p_smrm = p_smr.add_argument_group("required arguments")
    # Required arguments for searchmrna.
    p_smrm.add_argument("--rbps",
                   dest="list_rbps",
                   type=str,
                   metavar='str',
                   nargs='+',
                   required=True,
                   help="List of RBP names to define RBP motifs used for search (--rbps rbp1 rbp2 .. ). To search with all available motifs, use --rbps ALL. NOTE: to search with user-provided motifs, set --rbps USER and provide --user-meme-xml and/or --user-cm")
    p_smrm.add_argument("--gtf",
                   dest="in_gtf",
                   type=str,
                   metavar='str',
                   required = True,
                   help = "Input GTF file with genomic annotations to extract mRNA sequences. By default the most prominent transcript will be extracted and used for each gene. Alternatively, provide a list of expressed transcripts via --tr-list (together with --gtf containing the transcripts). Note that only features on standard chromosomes (1,2,..,X,Y,MT) are currently used for annotation")
    p_smrm.add_argument("--genome",
                   dest="in_genome",
                   type=str,
                   metavar='str',
                   required = True,
                   help = "Genomic sequences file (currently supported formats: FASTA)")
    p_smrm.add_argument("--out",
                   dest="out_folder",
                   type=str,
                   metavar='str',
                   required=True,
                   help="Results output folder")
    # Optional arguments for searchmrna.
    p_smr.add_argument("--data-id",
                   dest="data_id",
                   type=str,
                   metavar='str',
                   default = "data_id",
                   help="Dataset ID")
    p_smr.add_argument("--method-id",
                   dest="method_id",
                   type=str,
                   metavar='str',
                   default = "method_id",
                   help="Method ID")
    p_smr.add_argument("--run-id",
                   dest="run_id",
                   type=str,
                   metavar='str',
                   default = "run_id",
                   help="Run ID")
    p_smr.add_argument("--user-rbp-id",
                   dest="user_rbp_id",
                   type=str,
                   metavar='str',
                   default = False,
                   help = "Provide RBP ID belonging to provided sequence or structure motif(s) (mandatory for --rbps USER)")
    p_smr.add_argument("--user-meme-xml",
                   dest="user_meme_xml",
                   type=str,
                   metavar='str',
                   default = False,
                   help = "Provide MEME/DREME XML file containing sequence motif(s) to be used for the run (needs --rbps USER)")
    p_smr.add_argument("--user-cm",
                   dest="user_cm",
                   type=str,
                   metavar='str',
                   default = False,
                   help = "Provide covariance model (.cm) file containing covariance model(s) to be used for the run (needs --rbps USER)")
    p_smr.add_argument("--motif-db",
                   dest="motif_db",
                   type=int,
                   default=1,
                   choices=[1, 2, 3],
                   help="Built-in motif database to use. 1: human RBP motifs full (259 RBPs, 605 motifs, \"catrapid.omics.v2.1.human.6plus\"), 2: human RBP motifs full (low frequencies not rounded, \"catrapid.omics.v2.1.human.6plus.noround\"), 3: human RBP motifs eCLIP (107 RBPs, 316 motifs, \"s6_refined_ic010.human.rounded.encode_rbps\") (default: 1)")
    p_smr.add_argument("--custom-db",
                   dest="custom_db",
                   type=str,
                   metavar='str',
                   default = False,
                   help = "Provide custom motif database folder. Alternatively, provide single files via --custom-db-meme-xml, --custom-db-cm, --custom-db-info")
    p_smr.add_argument("--custom-db-id",
                   dest="custom_db_id",
                   type=str,
                   metavar='str',
                   default = "custom",
                   help = "Set ID/name for provided custom motif database via --custom-db  (default: \"custom\")")
    p_smr.add_argument("--custom-db-meme-xml",
                   dest="custom_db_meme_xml",
                   type=str,
                   metavar='str',
                   default = False,
                   help = "Provide custom motif database MEME/DREME XML file containing sequence motifs")
    p_smr.add_argument("--custom-db-cm",
                   dest="custom_db_cm",
                   type=str,
                   metavar='str',
                   default = False,
                   help = "Provide custom motif database covariance model (.cm) file containing covariance model(s)")
    p_smr.add_argument("--custom-db-info",
                   dest="custom_db_info",
                   type=str,
                   metavar='str',
                   default = False,
                   help = "Provide custom motif database info table file containing RBP ID -> motif ID -> motif type assignments")
    p_smr.add_argument("--regex",
                   dest="regex",
                   type=str,
                   metavar='str',
                   help="Define regular expression (regex) DNA motif to include in search, e.g. --regex AAACC, --regex 'C[ACGT]AC[AC]', .. NOTE that after motif hit found in region, search continues right after motif hit")
    p_smr.add_argument("--regex-id",
                   dest="regex_id",
                   type=str,
                   metavar='str',
                   default = "regex",
                   help="Set regex ID used as RBP ID and database ID associated to -regex hits (default: \"regex\")")
    p_smr.add_argument("--motif-regex-id",
                   dest="motif_regex_id",
                   default = False,
                   action = "store_true",
                   help="Use --regex-id for motif ID as well. By default, regular expression string is used as motif ID for regex motif hits")
    p_smr.add_argument("--regex-search-mode",
                   dest="regex_search_mode",
                   type=int,
                   default=1,
                   choices=[1, 2],
                   help="Define regex search mode. 1: when motif hit encountered, continue +1 after motif hit end position, 2: when motif hit encountered, continue +1 of motif hit start position (default: 1)")
    p_smr.add_argument("--fimo-nt-freqs",
                   dest="fimo_nt_freqs",
                   type=str,
                   metavar='str',
                   default = False,
                   help = "Provide FIMO nucleotide frequencies (FIMO option: --bifile) file (default: use internal frequencies file optimized for human transcripts)")
    p_smr.add_argument("--fimo-pval",
                   dest="fimo_pval",
                   type=float,
                   metavar='float',
                   default=0.001,
                   help="FIMO p-value threshold (FIMO option: --thresh) (default: 0.001)")
    p_smr.add_argument("--tr-list",
                   dest="tr_list",
                   type=str,
                   metavar='str',
                   default = False,
                   help = "Supply file with transcript IDs (one ID per row) to define which transcripts to use from --gtf")
    p_smr.add_argument("--gtf-feat-min-overlap",
                   dest="gtf_feat_min_overlap",
                   type=float,
                   metavar='float',
                   default=0.1,
                   help="Minimum amount of overlap required for a motif hit to be assigned to a GTF feature (if less or no overlap, region will be assigned to \"intergenic\") (default: 0.1)")
    p_smr.add_argument("--plot-abs-paths",
                   dest="plot_abs_paths",
                   default = False,
                   action = "store_true",
                   help = "Store plot files with absolute paths in HTML report. Default is relative paths (default: False)")
    p_smr.add_argument("--meme-no-check",
                   dest="meme_disable_check",
                   default = False,
                   action = "store_true",
                   help = "Disable MEME version check. Make sure --meme-no-pgc is set if MEME version >= 5.5.4 is installed! (default: False)")
    p_smr.add_argument("--meme-no-pgc",
                   dest="meme_no_pgc",
                   default = False,
                   action = "store_true",
                   help = "Manually set MEME's FIMO --no-pgc option (required for MEME version >= 5.5.4). Make sure that MEME >= 5.5.4 is installed! (default: False)")
    p_smr.add_argument("--mrna-norm-mode",
                   dest="mrna_norm_mode",
                   type=int,
                   default=1,
                   choices=[1, 2],
                   help = "Define whether to use median or mean mRNA region lengths for plotting. 1: median. 2: mean (default: 1)")
    p_smr.add_argument("--sort-js-mode",
                   dest="sort_js_mode",
                   type=int,
                   default=1,
                   choices=[1, 2, 3],
                   help = "Define how to provide sorttable.js file. 1: link to packaged .js file. 2: copy .js file to plots output folder. 3: include .js code in HTML (default: 1)")













    """
    Optimal extension mode.
    """
    p_oe = subparsers.add_parser('optex',
                                  help='Investigate optimal extension')
    p_oe.set_defaults(which='optex')
    # Add required arguments group.
    p_oem = p_oe.add_argument_group("required arguments")
    # Required arguments.
    p_oem.add_argument("--in",
                   dest="in_sites",
                   type=str,
                   metavar='str',
                   required=True,
                   help="Genomic RBP binding sites (peak regions) file in BED format (also positives + negatives)")
    p_oem.add_argument("--rbp-id",
                   dest="rbp_id",
                   type=str,
                   metavar='str',
                   required=True,
                   help = "Provide RBP ID to define RBP motifs used for search")
    p_oem.add_argument("--genome",
                   dest="in_genome",
                   type=str,
                   metavar='str',
                   required = True,
                   help = "Genomic sequences file (currently supported formats: FASTA)")
    # Optional arguments.
    p_oe.add_argument("--user-meme-xml",
                   dest="user_meme_xml",
                   type=str,
                   metavar='str',
                   default = False,
                   help = "Provide MEME/DREME XML file containing sequence motif(s) to be used as search motifs")
    p_oe.add_argument("--user-cm",
                   dest="user_cm",
                   type=str,
                   metavar='str',
                   default = False,
                   help = "Provide covariance model (.cm) file containing covariance model(s) to be used as search motifs")
    p_oe.add_argument("--motif-db",
                   dest="motif_db",
                   type=int,
                   default=1,
                   choices=[1, 2, 3],
                   help="Built-in motif database to use. 1: human RBP motifs full (259 RBPs, 605 motifs, \"catrapid.omics.v2.1.human.6plus\"), 2: human RBP motifs full (low frequencies not rounded, \"catrapid.omics.v2.1.human.6plus.noround\"), 3: human RBP motifs eCLIP (107 RBPs, 316 motifs, \"s6_refined_ic010.human.rounded.encode_rbps\") (default: 1)")
    p_oe.add_argument("--fimo-nt-freqs",
                   dest="fimo_nt_freqs",
                   type=str,
                   metavar='str',
                   default = False,
                   help = "Provide FIMO nucleotide frequencies (FIMO option: --bifile) file (default: use internal frequencies file optimized for human transcripts)")
    p_oe.add_argument("--fimo-pval",
                   dest="fimo_pval",
                   type=float,
                   metavar='float',
                   default=0.001,
                   help="FIMO p-value threshold (FIMO option: --thresh) (default: 0.001)")
    p_oe.add_argument("--bed-score-col",
                   dest="bed_score_col",
                   type=int,
                   metavar='int',
                   default=5,
                   help="--in BED score column used for p-value calculations and finding optimal extension. BED score can be e.g. log2 fold change or -log10 p-value of the region (default: 5)")
    p_oe.add_argument("--ext-pval",
                   dest="ext_pval",
                   type=float,
                   metavar='float',
                   default=0.001,
                   help="Longest extension p-value (default: 0.05)")
    p_oe.add_argument("--ext-list",
                   dest="ext_list",
                   type=int,
                   metavar='int',
                   nargs='+',
                   help="List of extensions to test (e.g. --ext-list 0 10 20 30 40 50). Internally, all combinations will be tested")
    p_oe.add_argument("--meme-no-check",
                   dest="meme_disable_check",
                   default = False,
                   action = "store_true",
                   help = "Disable MEME version check. Make sure --meme-no-pgc is set if MEME version >= 5.5.4 is installed! (default: False)")
    p_oe.add_argument("--meme-no-pgc",
                   dest="meme_no_pgc",
                   default = False,
                   action = "store_true",
                   help = "Manually set MEME's FIMO --no-pgc option (required for MEME version >= 5.5.4). Make sure that MEME >= 5.5.4 is installed! (default: False)")
    """
    Info mode.
    """
    p_i = subparsers.add_parser('info',
                                  help='Print out RBP IDs in database')
    p_i.set_defaults(which='info')
    # Optional arguments.
    p_i.add_argument("--motif-db",
                   dest="motif_db",
                   type=int,
                   default=1,
                   choices=[1, 2, 3],
                   help="Built-in motif database to use. 1: human RBP motifs full (259 RBPs, 605 motifs, \"catrapid.omics.v2.1.human.6plus\"), 2: human RBP motifs full (low frequencies not rounded, \"catrapid.omics.v2.1.human.6plus.noround\"), 3: human RBP motifs eCLIP (107 RBPs, 316 motifs, \"s6_refined_ic010.human.rounded.encode_rbps\") (default: 1)")
    p_i.add_argument("--custom-db",
                   dest="custom_db",
                   type=str,
                   metavar='str',
                   default = False,
                   help = "Provide custom motif database folder and print included IDs")

    """
    Dist mode.
    """
    p_d = subparsers.add_parser('dist',
                                  help='Plot nt distribution at genomic positions')
    p_d.set_defaults(which='dist')
    # Add required arguments group.
    p_dm = p_d.add_argument_group("required arguments")
    # Required arguments.
    p_dm.add_argument("--in",
                   dest="in_sites",
                   type=str,
                   metavar='str',
                   required=True,
                   help="Genomic RBP binding sites (peak regions) file in BED format (can be single positions or extended regions). Use --cp-mode to define zero position for plotting")
    p_dm.add_argument("--genome",
                   dest="in_genome",
                   type=str,
                   metavar='str',
                   required = True,
                   help = "Genomic sequences file (currently supported formats: FASTA)")
    p_dm.add_argument("--out",
                   dest="out_folder",
                   type=str,
                   metavar='str',
                   required=True,
                   help="Distribution plot results output folder")
    # Optional arguments.
    p_d.add_argument("--cp-mode",
                   dest="cp_mode",
                   type=int,
                   default=1,
                   choices=[1, 2, 3],
                   help="Define which position of --in genomic sites to use as zero position for plotting. 1: upstream end position, 2: center position, 3: downstream end position (default: 1)")
    p_d.add_argument("--ext",
                   dest="ext_up_down",
                   type=int,
                   metavar='int',
                   default=10,
                   help="Up- and downstream extension of defined genomic positions (define via --cp-mode) in nucleotides (nt). Set e.g. --ext 20 for 20 nt on both sides (default: 10)")
    p_d.add_argument("--plot-pdf",
                   dest="plot_pdf",
                   default = False,
                   action = "store_true",
                   help = "Plot .pdf (default: .png)")


    """
    Compare mode.
    """
    p_c = subparsers.add_parser('compare',
                                  help='Compare different search results')
    p_c.set_defaults(which='compare')
    # Add required arguments group.
    p_cm = p_c.add_argument_group("required arguments")
    # Required arguments.
    p_cm.add_argument("--in",
                   dest="data_in",
                   type=str,
                   metavar='str',
                   nargs='+',
                   required=True,
                   help="Supply motif search results data, either as folders (--out folders of rbpbench search or batch), or as files (both RBP and motif hit stats files needed!). Order of files does NOT matter")
    p_cm.add_argument("--out",
                   dest="out_folder",
                   type=str,
                   metavar='str',
                   required=True,
                   help="Comparison results output folder")
    p_c.add_argument("--plot-abs-paths",
                   dest="plot_abs_paths",
                   default = False,
                   action = "store_true",
                   help = "Store plot files with absolute paths in HTML files. Default is relative paths (default: False)")
    p_c.add_argument("--sort-js-mode",
                   dest="sort_js_mode",
                   type=int,
                   default=1,
                   choices=[1, 2, 3],
                   help = "Define how to provide sorttable.js file. 1: link to packaged .js file. 2: copy .js file to plots output folder. 3: include .js code in HTML (default: 1)")
    return p


################################################################################

def specify_motif_db(motif_db_nr, db_path="./"):
    """
    Returns
    sequence motif database file
    structure motif database file
    motif database string

    motif_db_nr: motif database string
    1: catrapid.omics.v2.1.human.6plus
    2: catrapid.omics.v2.1.human.6plus.noround
    3: s6_refined_ic010.human.rounded.encode_rbps

    catRAPID_omics_v2.0_6plus_motifs.meme
    catRAPID_omics_v2.0_6plus_motifs.weak_rounded.meme
    s6_refined_ic010_rounded_ENCODE_RBPs.meme

    """

    seq_motifs_db_file = db_path + "/catRAPID_omics_v2.1_6plus_motifs.weak_rounded.meme"
    str_motifs_db_file = db_path + "/str_motifs.cm"
    rbp2ids_file = db_path + "/rbp_motif2name_ids.full.txt"
    motif_db_str = "catrapid.omics.v2.1.human.6plus"
    if motif_db_nr == 2:
        seq_motifs_db_file = db_path + "/catRAPID_omics_v2.1_6plus_motifs.meme"
        motif_db_str = "catrapid.omics.v2.1.human.6plus.noround"
    if motif_db_nr == 3:
        seq_motifs_db_file = db_path + "/s6_refined_ic010_rounded_ENCODE_RBPs.meme"
        rbp2ids_file = db_path + "/rbp_motif2name_ids.txt"
        motif_db_str = "s6_refined_ic010.human.rounded.encode_rbps"
    return seq_motifs_db_file, str_motifs_db_file, rbp2ids_file, motif_db_str


################################################################################

def specify_custom_motif_db(motif_db_path):
    """
    Define custom motif database, by providing a folder which has to contain 
    the following files:
    info.txt
        with columns motif_id, rbp_id, motif_type, organism
        ZRANB2_1	ZRANB2	meme_xml	human
        ZRANB2_2	ZRANB2	meme_xml	human
        RF00032	SLBP	cm	human

        organism column optional for now ...

    seq_motifs.meme
    str_motifs.cm
    
    """
    assert os.path.isdir(motif_db_path), "given --custom-motif-db path \"%s\" is not a valid path" %(motif_db_path) 
    seq_motifs_db_file = motif_db_path + "/seq_motifs.meme"
    str_motifs_db_file = motif_db_path + "/str_motifs.cm"
    rbp2ids_file = motif_db_path + "/info.txt"
    assert os.path.exists(seq_motifs_db_file) or os.path.exists(str_motifs_db_file), "custom database folder \"%s\" needs to contain seq_motifs.meme and/or str_motifs.cm file" %(motif_db_path)
    assert os.path.exists(rbp2ids_file), "custom database folder \"%s\" needs to contain info.txt file" %(motif_db_path)
    return seq_motifs_db_file, str_motifs_db_file, rbp2ids_file


################################################################################

def main_search(args):
    """
    Search motifs.

    """

    print("Running for you in SEARCH mode ... ")


    assert os.path.exists(args.in_sites), "--in file \"%s\" not found" % (args.in_sites)
    # Check --in BED format.
    if not args.unstranded:
        benchlib.bed_check_format(args.in_sites)
    # More checks.
    if args.upset_plot_max_degree is not None:
        assert args.upset_plot_max_degree >= args.upset_plot_min_degree, "set --upset-plot-max-degree needs to be >= --upset-plot-min-degree"
    if args.tr_list:
        assert args.in_gtf, "set --tr-list requires --gtf GTF file"
    assert benchlib.boundary_check(args.gtf_feat_min_overlap, 1E-9, 1.0), "set --gtf-feat-min-overlap expected to be >= 1E-9 and <= 1.0"
    # if args.in_gtf:
    #     assert args.report, "set --gtf requires --report to be effective"
    assert args.upset_plot_min_rbp_count >= 0, "set --upset-plot-min-rbp-count needs to be >= 0"
    if args.add_motif_annot:
        assert args.in_gtf, "set --add-motif-annot requires --gtf GTF file"
        assert args.plot_motifs, "set --add-motif-annot requires --plot-motifs"

    # Is MEME >= v5 installed?
    if not args.meme_disable_check:
        assert benchlib.is_tool("meme"), "meme not in PATH"
        check, meme_version = benchlib.check_tool_version("meme -version", "5.0")
        assert check, "RBPBench requires meme version >= 5.0 (installed version: %s)" %(meme_version)

    # Check if MEME version is >= 5.5.4 (need to add fimo --no-pgc option to produce same results!).
    fimo_params = "--norc --verbosity 1 --skip-matched-sequence --text"
    if not args.meme_disable_check:
        check, meme_version = benchlib.check_tool_version("meme -version", "5.5.4")
        if check:
            fimo_params = "--norc --verbosity 1 --skip-matched-sequence --text --no-pgc"
    if args.meme_no_pgc:
        fimo_params = "--norc --verbosity 1 --skip-matched-sequence --text --no-pgc"

    # Regex check.
    if args.regex:
        assert benchlib.is_valid_regex(args.regex), "given --regex \"%s\" is not a valid regular expression. Please provide valid expression" % (args.regex)

    """
    Library path.
    """
    benchlib_path = os.path.dirname(benchlib.__file__)
    db_path = benchlib_path + "/content"

    """
    FIMO nt frequencies.
    """
    fimo_freqs_file = db_path + "/fimo_nt_freqs.txt"
    if args.fimo_nt_freqs:
        fimo_freqs_file = args.fimo_nt_freqs
    assert os.path.exists(fimo_freqs_file), "set FIMO nucleotide frequencies file \"%s\" not found" % (fimo_freqs_file)

    """
    Motif database.
    """
    seq_motifs_db_file, str_motifs_db_file, rbp2ids_file, motif_db_str = specify_motif_db(args.motif_db, 
                                                                            db_path=db_path)
    # Custom motif database: folder given.
    if args.custom_db:
        assert not args.custom_db_meme_xml, "--custom-db folder set incompatible with --custom-db-meme-xml. Provide custom motif database either via folder (--custom-db) or as single files"
        assert not args.custom_db_cm, "--custom-db folder set incompatible with --custom-db-cm. Provide custom motif database either via folder (--custom-db) or as single files"
        assert not args.custom_db_info, "--custom-db folder set incompatible with --custom-db-info. Provide custom motif database either via folder (--custom-db) or as single files"
        seq_motifs_db_file, str_motifs_db_file, rbp2ids_file = specify_custom_motif_db(args.custom_db)
        motif_db_str = args.custom_db_id
    # Custom motif database: single files given.
    if args.custom_db_meme_xml or args.custom_db_cm or args.custom_db_info:
        motif_db_str = args.custom_db_id
        assert not args.custom_db, "single custom motif database files provided not compatible with --custom-db. Provide custom motif database either via folder (--custom-db) or as single files"
        assert args.custom_db_info, "--custom-db-info needed to define custom motif database"
        rbp2ids_file = args.custom_db_info
        assert args.custom_db_meme_xml or args.custom_db_cm, "--custom-db-meme-xml and/or --custom-db-cm needed to define custom motif database"
        if args.custom_db_meme_xml:
            seq_motifs_db_file = args.custom_db_meme_xml
        else:
            seq_motifs_db_file = ""  # setting to empty string results in os.path.exists -> False.
        if args.custom_db_cm:
            str_motifs_db_file = args.custom_db_cm
        else:
            str_motifs_db_file = ""

    args.motif_db_str = motif_db_str

    """
    Get ID mappings

    name2ids_dic:
    RBP name -> motif IDs mapping
    id2type_dic:
    motif ID -> motif type (cm, meme_xml)
    id2org_dic (ignore for now):
    motif ID -> organism ID (so far only "human")

    """
    name2ids_dic, id2type_dic = benchlib.get_rbp_id_mappings(rbp2ids_file)
    # Motif ID -> RBP name (== RBP ID) mapping.
    id2name_dic = {}
    for rbp_id in name2ids_dic:
        for motif_id in name2ids_dic[rbp_id]:
            id2name_dic[motif_id] = rbp_id

    """
    Get MEME XML database motif blocks dictionary.

    """
    seq_motif_blocks_dic = {}
    if os.path.exists(seq_motifs_db_file):
        seq_motif_blocks_dic = benchlib.read_in_xml_motifs(seq_motifs_db_file,
                                                           empty_check=True)
    for motif_id in seq_motif_blocks_dic:
        assert motif_id in id2name_dic, "MEME XML motif ID %s not found in prior mapping. Please contact developers!" %(motif_id)

    """
    Get covariance model database motif blocks dictionary.

    """
    str_motif_blocks_dic = {}
    if os.path.exists(str_motifs_db_file):
        str_motif_blocks_dic = benchlib.read_in_cm_blocks(str_motifs_db_file, 
                                                          empty_check=True)
    for motif_id in str_motif_blocks_dic:
        assert motif_id in id2name_dic, "Covariance model accession ID %s not found in prior mapping. Please contact developers!" %(motif_id)

    # Remove special chars from run ID.
    args.data_id = benchlib.remove_special_chars_from_str(args.data_id)
    assert args.data_id, "empty string after removing special chars from --data-id. Please provide alphanumeric string for data ID (- or _ are okay as well)"
    args.method_id = benchlib.remove_special_chars_from_str(args.method_id)
    assert args.method_id, "empty string after removing special chars from --method-id. Please provide alphanumeric string for method ID (- or _ are okay as well)"
    # Run ID definition.
    run_id = "run_id"
    if args.run_id:
        run_id = benchlib.remove_special_chars_from_str(args.run_id)
        assert run_id, "empty string after removing special chars from --run-id. Please provide alphanumeric string for run ID (- or _ are okay as well)"
    # else:
    #     random_id = uuid.uuid4()
    #     run_id = str(random_id)

    # hash_len = max(len(run_id), len(args.data_id), len(args.method_id))
    # print("###################" + "#"*hash_len)
    print("Run ID:     ", run_id)
    print("Data ID:    ", args.data_id)
    print("Method ID:  ", args.method_id)
    # print("###################" + "#"*hash_len)

    """
    Output folders + files.

    """
    if not os.path.exists(args.out_folder):
        os.makedirs(args.out_folder)

    filtered_sites_bed = args.out_folder + "/in_sites.filtered.bed"
    filtered_sites_fa = args.out_folder + "/in_sites.filtered.fa"
    seq_motifs_xml = args.out_folder + "/seq_motifs.xml"
    str_motifs_cm = args.out_folder + "/str_motifs.cm"
    fimo_res_tsv = args.out_folder + "/fimo_results.tsv"
    cmsearch_res_txt = args.out_folder + "/cmsearch_results.txt"

    rbp_stats_out = args.out_folder + "/rbp_hit_stats.tsv"
    motif_stats_out = args.out_folder + "/motif_hit_stats.tsv"
    con_res_out_tsv = args.out_folder + "/contingency_table_results.tsv"
    settings_file = args.out_folder + "/settings.find_motifs.out"
    rbp_reg_occ_table_out = args.out_folder + "/rbp_region_occupancies.tsv"

    # Output unique motif hits.
    motif_hits_bed_out = args.out_folder + "/motif_hits.rbpbench_search.bed"

    # Temp files.
    # random_id = uuid.uuid1()
    # tmp_out_bed = args.out_folder + "/" + str(random_id) + ".filtered_in.bed"
    out_tmp_bed = args.out_folder + "/rbp_motif_hit_regions.tmp.bed"
    cmstat_tmp_out = args.out_folder + "/cmstat_out.tmp.txt"

    # Delete if existing folder.
    if os.path.exists(fimo_res_tsv):
        os.remove(fimo_res_tsv)
    if os.path.exists(cmsearch_res_txt):
        os.remove(cmsearch_res_txt)


    """
    Load RBP data based on --rbps (+ optionally USER data).

    """

    rbp_in_dic = {}
    for rbp_id in args.list_rbps:
        rbp_in_dic[rbp_id] = 1

    # RBPs for motif search.
    loaded_rbps_dic = {}

    # USER set?
    user_motifs = False
    user_rbp_id = False
    if "USER" in rbp_in_dic:
        user_motifs = True
    else:
        assert not args.user_meme_xml, "--user-meme-xml provided but --rbps USER not set. Please add USER to --rbps list to search for user-supplied motifs"
        assert not args.user_cm, "--user-cm provided but --rbps USER not set. Please add USER to --rbps list to search for user-supplied motifs"
        assert not args.user_rbp_id, "--user-rbp-id set but --rbps USER not set. Please add USER to --rbps list to search for user-supplied motifs"

    # If ALL set, load all RBPs (+ optinally USER).
    if "ALL" in rbp_in_dic:
        if len(rbp_in_dic) == 2:
            assert user_motifs, "set --rbps ALL, --rbps ALL USER, or individual RBPs (+ optinally USER) --rbps RBP1 RBP2 ... USER"
        if len(rbp_in_dic) > 2:
            assert False, "set --rbps ALL, --rbps ALL USER, or individual RBPs (+ optinally USER) --rbps RBP1 RBP2 ... USER"
        print("--rbps ALL selected. Loading all database motifs ... ")
        for rbp_id in name2ids_dic:
            loaded_rbps_dic[rbp_id] = motif_db_str

    else:
        # Load individual RBPs.
        for rbp_id in rbp_in_dic:
            if rbp_id != "USER":
                """
                Check if RBP ID in database.
                Suggest similar RBPs based on string similarity (edit distance).

                """
                if rbp_id not in name2ids_dic:
                    db_rbp_list = []
                    for db_rbp_id in name2ids_dic:
                        db_rbp_list.append(db_rbp_id)
                    pair_dist_dic = benchlib.calc_edit_dist_query_list(rbp_id, db_rbp_list)
                    max_c = 10
                    c = 0
                    suggested_rbps = []
                    for key, value in sorted(pair_dist_dic.items(), key=lambda item: item[1], reverse=False):
                        if c >= max_c:
                            break
                        c += 1
                        suggested_rbps.append(key)
                    suggested_rbps_str = ",".join(suggested_rbps)
                    assert False, "provided --rbps ID %s not in internal motif database (%s). Please provide RBP name present in database. Did you mean (any of) the following database ID(s) (top 10 hits based on string similarity): %s ?" %(rbp_id, motif_db_str, suggested_rbps_str)
                # assert rbp_id in name2ids_dic, "provided --rbps ID %s not in internal motif database. Please provide RBP name present in database" %(rbp_id)
                loaded_rbps_dic[rbp_id] = motif_db_str

    # Motif IDs for search.
    loaded_motif_ids_dic = {}
    for rbp_id in loaded_rbps_dic:
        for motif_id in name2ids_dic[rbp_id]:
            loaded_motif_ids_dic[motif_id] = motif_db_str

    """
    Check and load provided USER data.

    """

    if user_motifs:
        print("--rbps USER selected. Check + load provided USER motifs ... ")
        assert args.user_rbp_id, "--rbps USER demands --user-rbp-id to be set to connect the supplied motif(s) with an RBP ID"
        assert args.user_meme_xml or args.user_cm, "--rbps USER requires a provided sequence or structure motif file (via --user-meme-xml AND/OR --user-cm)"

        # Reformat user_rbp_id. 
        user_rbp_id = benchlib.remove_special_chars_from_str(args.user_rbp_id)
        assert user_rbp_id, "empty string after removing special chars from --user-rbp-id. Please provide alphanumeric string for RBP ID (- or _ are okay as well)"

        assert user_rbp_id not in loaded_rbps_dic, "user RBP ID %s already selected from database. Please deselect respective database RBP ID or provide unique user RBP ID via --user-rbp-id" %(user_rbp_id)
        loaded_rbps_dic[user_rbp_id] = "user"
        # In case user_rbp_id in database, reset motif IDs associated to user_rbp_id.
        name2ids_dic[user_rbp_id] = []
        print("RBP ID for user-supplied motifs:", user_rbp_id)

        user_seq_motif_blocks_dic = {}
        if args.user_meme_xml:
            assert os.path.exists(args.user_meme_xml), "--user-meme-xml file \"%s\" not found" % (args.user_meme_xml)
            user_seq_motif_blocks_dic = benchlib.read_in_xml_motifs(args.user_meme_xml, empty_check=False)
            assert user_seq_motif_blocks_dic, "no motifs read in from provided --user-meme-xml. Make sure to supply sequence motifs in MEME XML format!"
            # Check if motif ID already loaded.
            for acc_id in user_seq_motif_blocks_dic:
                assert acc_id not in loaded_motif_ids_dic, "user-supplied MEME XML motif ID %s already selected, i.e., ID is already associated with selected database RBP %s. Please change user motif ID to a unique motif ID or deselect the respective RBP" %(acc_id, id2name_dic[acc_id])
                loaded_motif_ids_dic[acc_id] = "user"
                # Add user to database blocks (overwrite if same ID encountered).
                seq_motif_blocks_dic[acc_id] = user_seq_motif_blocks_dic[acc_id]
                name2ids_dic[user_rbp_id].append(acc_id)
                id2type_dic[acc_id] = "meme_xml"
                id2name_dic[acc_id] = user_rbp_id

        user_str_motif_blocks_dic = {}
        if args.user_cm:
            assert os.path.exists(args.user_cm), "--user-cm file \"%s\" not found" % (args.user_cm)
            # Check for valid format.
            acc_ids_dic = benchlib.check_cm_file(args.user_cm, cmstat_tmp_out, empty_check=False)
            # Read in covariance model blocks.
            user_str_motif_blocks_dic = benchlib.read_in_cm_blocks(args.user_cm)
            for acc_id in acc_ids_dic:
                assert acc_id in user_str_motif_blocks_dic, "accession ID %s not in blocks dictionary. Please contact developers!" %(acc_id)
            # Check if motif ID already loaded.
            for acc_id in user_str_motif_blocks_dic:
                assert acc_id not in loaded_motif_ids_dic, "user-supplied covariance model accession (ACC) ID %s already selected, i.e., ID is already associated with selected database RBP %s. Please change to a unique accession ID or deselect the respective RBP" %(acc_id, id2name_dic[acc_id])
                loaded_motif_ids_dic[acc_id] = "user"
                # Add user to database blocks (overwrite if same ID encountered).
                str_motif_blocks_dic[acc_id] = user_str_motif_blocks_dic[acc_id]
                name2ids_dic[user_rbp_id].append(acc_id)
                id2type_dic[acc_id] = "cm"
                id2name_dic[acc_id] = user_rbp_id

    """
    Check if loaded RBP IDs have motifs.

    """
    for rbp_id in loaded_rbps_dic:
        for motif_id in name2ids_dic[rbp_id]:
            found = 0
            if motif_id in seq_motif_blocks_dic:
                found += 1
            if motif_id in str_motif_blocks_dic:
                found += 1
            assert found, "no motifs loaded for RBP ID \"%s\". Please provide the respective motifs file" %(rbp_id)


    """
    If --regex is set:
    Treat regex as sequence motif / fimo type.
    rbp_id: regex, motif_id: regex, motif_db: regex

    """

    regex_id = args.regex_id
    regex = args.regex
    
    if args.regex:

        # Remove , ; from given regex, to avoid motif_id format conflicts.
        regex = benchlib.remove_special_chars_from_str(args.regex,
                                                       reg_ex="[,;]")
        
        assert regex, "empty string after removing special chars from --regex. Please provide a valid regex with DNA letters"

        regex_id = benchlib.remove_special_chars_from_str(args.regex_id)

        assert regex_id, "empty string after removing special chars from --regex-id. Please provide alphanumeric string for regex ID (- or _ are okay as well)"
        assert regex_id not in name2ids_dic, "--regex set but a different RBP ID with name \"%s\" was found. Please provide a different RBP ID or --regex-id" %(regex_id)

        if args.motif_regex_id:
            assert regex_id not in id2type_dic, "--regex set but a different motif ID with name \"%s\" was found. Please provide a different motif ID or --regex-id" %(regex_id)

            id2name_dic[regex_id] = regex_id    # motif_id -> rbp_id
            id2type_dic[regex_id] = "regex"  # motif_id -> motif type string; motif type string can be regex, cm, meme_xml
            loaded_motif_ids_dic[regex_id] = regex_id  # motif_id -> motif_db_str
            name2ids_dic[regex_id] = [regex_id]  # rbp_id -> motif_ids

        else:
            assert regex not in id2type_dic, "--regex set but a different motif ID with name \"%s\" was found. Please provide a different motif ID or use --motif-regex-id" %(regex_id)

            id2name_dic[regex] = regex_id    # motif_id -> rbp_id
            id2type_dic[regex] = "regex"  # motif_id -> motif type string; motif type string can be regex, cm, meme_xml
            loaded_motif_ids_dic[regex] = regex_id  # motif_id -> motif_db_str
            name2ids_dic[regex_id] = [regex]  # rbp_id -> motif_ids

        loaded_rbps_dic[regex_id] = regex_id  # rbp_id -> motif_db_str

        """
        Dictionaries that use motif_id as keys.
        loaded_motif_ids_dic
        name2ids_dic
        id2name_dic
        id2type_dic
        """

    """
    If --set-rbp-id set, check if it is part of loaded RBP IDs.

    """

    if args.set_rbp_id is not None:
        assert args.set_rbp_id in loaded_rbps_dic, "given --set-rbp-id \"%s\" is not part of loaded RBP IDs. Please provide --set-rbp-id that is part of loaded RBPs (user-defined or database RBP ID)" %(args.set_rbp_id)



    """
    Load RBP data, store in RBP() class.

    """

    # Store motif IDs for search.
    search_rbps_dic = {}
    seq_rbps_dic = {}
    str_rbps_dic = {}
    motif_id2idx_dic = {} # motif ID -> list index.
    args.internal_id = []

    for rbp_id in loaded_rbps_dic:
    
        internal_id = base64.urlsafe_b64encode(os.urandom(6)).decode()
        args.internal_id.append(internal_id)
        rbp = benchlib.RBP(rbp_id, internal_id)

        for motif_id in name2ids_dic[rbp_id]:
        
            assert motif_id in loaded_motif_ids_dic, "motif_id %s not in loaded_motif_ids_dic" %(motif_id)

            if id2type_dic[motif_id] == "meme_xml":
                rbp.seq_motif_ids.append(motif_id)
                motif_id2idx_dic[motif_id] = len(rbp.seq_motif_ids) - 1
                rbp.seq_motif_hits.append(0)
                seq_rbps_dic[rbp_id] = 1
            elif id2type_dic[motif_id] == "regex":
                rbp.seq_motif_ids.append(motif_id)
                motif_id2idx_dic[motif_id] = len(rbp.seq_motif_ids) - 1
                rbp.seq_motif_hits.append(0)
                seq_rbps_dic[rbp_id] = 1
            elif id2type_dic[motif_id] == "cm":
                rbp.str_motif_ids.append(motif_id)
                motif_id2idx_dic[motif_id] = len(rbp.str_motif_ids) - 1
                rbp.str_motif_hits.append(0)
                str_rbps_dic[rbp_id] = 1
            else:
                assert False, "unknown motif type (\"%s\") set for motif_id %s" %(id2type_dic[motif_id], motif_id)

        search_rbps_dic[rbp_id] = rbp


    print("# of RBP IDs for search:    ", len(loaded_rbps_dic))
    print("# of motif IDs for search:  ", len(loaded_motif_ids_dic))

    """
    Get chromosome IDs from --genome.
    """
    print("Get --genome FASTA headers ... ")
    chr_ids_dic = benchlib.get_fasta_headers(args.in_genome)

    """
    Filter / extend --in genomic regions BED file.

    """

    # Process extension info.
    ext_parts = args.ext_up_down.split(",")
    c_ext_parts = len(ext_parts)
    ext_up = 0
    ext_down = 0
    if c_ext_parts == 1:
        ext_up = int(ext_parts[0])
        ext_down = int(ext_parts[0])
    elif c_ext_parts == 2:
        ext_up = int(ext_parts[0])
        ext_down = int(ext_parts[1]) 
    else:
        assert False, "invalid --ext argument provided (correct format: --ext 10 OR --ext 20,10)"

    # Unstranded option.
    if args.unstranded:
        print("WARNING: --unstranded enabled. Using both strands for each --in BED region ... ")
        if ext_up != ext_down:
            print("asymmetric --ext and --unstranded set. Extend plus strand and use corresponding minus strand ... ")

    # Filter / extend --in BED.
    print("Preprocess --in sites ... ")
    reg2sc_dic = {}  # Used to store region scores for Wilcoxon rank-sum test.
    bed_chr_ids_dic = {}
    reg_stats_dic = benchlib.bed_filter_extend_bed(args.in_sites, filtered_sites_bed,
                                          ext_up=ext_up,
                                          ext_down=ext_down,
                                          remove_dupl=True,
                                          reg2sc_dic=reg2sc_dic,
                                          score_col=args.bed_score_col,
                                          chr_ids_dic=chr_ids_dic,
                                          bed_chr_ids_dic=bed_chr_ids_dic,
                                          use_region_ids=True,
                                          unstranded=args.unstranded)

    print("# --in regions pre-filtering:  ", reg_stats_dic["c_in"])
    print("# --in regions post-filtering: ", reg_stats_dic["c_out"])
    print("# regions with invalid chr_id: ", reg_stats_dic["c_chr_filter"])
    print("# duplicated regions removed:  ", reg_stats_dic["c_dupl_filter"])

    assert reg_stats_dic["c_out"], "no --in BED sites remain after chromosome ID filtering. If caused by invalid chr_id filtering, make sure chromosome IDs in --genome FASTA and --in BED files are compatible (i.e., \"chr1\" vs. \"1\" notation)"

    """
    Guess chromosome ID style.

    chr_style:
        1: chr1, chr2, ..., chrX, chrM
        2: 1, 2, ... , X, MT

    """
    chr_style = 0  # no changes to chromosome IDs in GTF files.
    
    if "1" in chr_ids_dic:
        assert "chr1" not in chr_ids_dic, "inconsistent chromosome IDs in --genome FASTA file (both chr1 and 1)"
    if "chr1" in chr_ids_dic:
        assert "1" not in chr_ids_dic, "inconsistent chromosome IDs in --genome FASTA file (both chr1 and 1)"
    if "chr1" in chr_ids_dic:
        chr_style = 1
    if "1" in chr_ids_dic:
        chr_style = 2

    """
    Calculate effective size of genomic regions.
    
    """
    print("Calculate effective genomic region size ... ")
    eff_reg_size = benchlib.get_uniq_gen_size(filtered_sites_bed)


    print("Called region length sum:      ", reg_stats_dic["reg_len_sum"])
    print("Effective region length sum:   ", eff_reg_size)

    """
    Get genomic region sequences from --genome.

    Output FASTA header format:
    >chr8:9772198-9772297(+)

    No need to convert sequences to uppercase, as FIMO works on both 
    lower- and uppercase (as long as DNA / RNA is set correct).

    """
    print("Extract sequences from --genome ... ")
    benchlib.bed_extract_sequences_from_fasta(filtered_sites_bed, 
                                              args.in_genome, filtered_sites_fa,
                                              print_warnings=True)


    """
    Get FASTA sequences and sequence lengths.
    """

    out_seqs_dic = benchlib.read_fasta_into_dic(filtered_sites_fa,
                                       dna=True,
                                       all_uc=True,
                                       id_check=True,
                                       empty_check=False,
                                       skip_n_seqs=False)

    assert out_seqs_dic, "no sequences extracted from FASTA file for --in BED sites. Make sure to use compatible FASTA/BED files!"

    # Get region strands/polarities for motif distance calculations.
    reg2pol_dic = benchlib.extract_pol_from_seq_ids(out_seqs_dic)

    # Effective number of regions used for motif search.
    c_regions = len(out_seqs_dic)
    """
    --unstranded option and not --unstranded-ct

    chr8:9772198-9772297(+)
    """
    if args.unstranded and not args.unstranded_ct:
        # Check if sequences are even.
        assert not len(out_seqs_dic) % 2, "# of --in regions should be an even number since --unstranded is set. Please contact developers"
        c_regions = len(out_seqs_dic) // 2
    
    # Called region size.
    called_reg_size = 0
    len_list = []
    for seq_id in out_seqs_dic:
        seq_len = len(out_seqs_dic[seq_id])
        called_reg_size += seq_len
        len_list.append(seq_len)

    # Length statistics.
    reg_len_median = statistics.median(len_list)
    reg_len_mean = statistics.mean(len_list)
    reg_len_mean = round(reg_len_mean, 2)
    reg_len_min = min(len_list)
    reg_len_max = max(len_list)

    """
    ====================================
    RUN SEQUENCE MOTIF SEARCH WITH FIMO.
    ====================================
    
    """
    fimo_hits_list = []
    call_dic = {}

    if seq_rbps_dic:

        """
        Print motifs to file.

        """

        print("Output motifs to XML ... ")
        out_str, c_added_motifs = benchlib.blocks_to_xml_string(seq_motif_blocks_dic, loaded_motif_ids_dic)

        benchlib.output_string_to_file(out_str, seq_motifs_xml)


        """
        Run FIMO on sequences + motifs.

        """

        print("Run FIMO ... ")
        benchlib.run_fast_fimo(filtered_sites_fa, seq_motifs_xml, fimo_res_tsv,
                    pval_thr=args.fimo_pval,
                    nt_freqs_file=fimo_freqs_file,
                    call_dic=call_dic,
                    params=fimo_params,
                    error_check=False)

        """
        Read in FIMO hits.

        """

        assert os.path.exists(fimo_res_tsv), "FIMO output file fimo.tsv %s does not exist! There must have been an error while running FIMO (invalid xml file provided?)" %(fimo_res_tsv)

        print("Read in FIMO results ... ")
        fimo_hits_list = benchlib.read_in_fimo_results(fimo_res_tsv)

        c_fimo_hits = len(fimo_hits_list)
        print("# of FIMO motif hits:", c_fimo_hits)

        """
        If --regex is set, search for regex hits in sequences (stored in out_seqs_dic).

        """
        if args.regex:

            step_size_one = False
            if args.regex_search_mode == 1:
                step_size_one = False
            elif args.regex_search_mode == 2:
                step_size_one = True
            else:
                assert False, "invalid --regex-search-mode %i set" %(args.regex_search_mode)

            print("Run search for --regex \"%s\" ... " %(regex))
            regex_hits_list = benchlib.get_regex_hits(regex, regex_id, out_seqs_dic,
                                                      step_size_one=step_size_one,
                                                      use_motif_regex_id=args.motif_regex_id)

            c_regex_hits = len(regex_hits_list)
            print("# of regex hits:", c_regex_hits)

            # Add regex hits to fimo_hits_list.
            fimo_hits_list += regex_hits_list


    """
    =========================================
    RUN STRUCTURE MOTIF SEARCH WITH CMSEARCH.
    =========================================

    """
    cmsearch_hits_list = []

    if str_rbps_dic:
        
        print("Output covariance models to .cm ... ")
        benchlib.output_cm_blocks_to_file(str_motif_blocks_dic, loaded_motif_ids_dic, str_motifs_cm)

        # Run cmsearch.
        print("Run cmsearch ... ")
        benchlib.run_cmsearch(filtered_sites_fa, str_motifs_cm, cmsearch_res_txt,
                        error_check=False,
                        call_dic=call_dic,
                        params="-g --tformat fasta --toponly --incT 1 -T 1 --default") # or add --anytrunc and remove --g
        # Read in hits.
        print("Read in cmsearch results ... ")
        cmsearch_hits_list, c_cms_hits = benchlib.read_in_cmsearch_results(cmsearch_res_txt, 
                                                                           check=True)

        print("# of cmsearch motif hits:", c_cms_hits)


    """
    Store for each RBP the regions with motif hits (and hit counts), using
    dictionary of dictionaries regions_with_motifs_dic.
    This tells us, how many input regions have motif hits, separated by RBP.
    Also store for each RBP the unique motif hit regions (and hit counts), using
    dictionary of dictionaries unique_motifs_dic.

    regions_with_motifs_dic:
        Dictionary of dictionaries, format:
        {rbp_id1 -> {'region1': motif_c_region1, 'region2': motif_c_region2}, rbp_id2 -> {'region1': motif_c_region1}}
    unique_motifs_dic:
        Dictionary of dictionaries, format:
        {rbp_id1 -> {'motif_region1': c_motif_region1, 'motif_region2': c_motif_region2}, rbp_id2 -> .. }

    """

    regions_with_motifs_dic = {}
    unique_motifs_dic = {}

    # Store regions with sequence motifs.
    for fh in fimo_hits_list:

        rbp_id = id2name_dic[fh.motif_id]

        if rbp_id in regions_with_motifs_dic:
            # fh.seq_name : FASTA header (== --in genomic sequence region).
            if fh.seq_name in regions_with_motifs_dic[rbp_id]:
                regions_with_motifs_dic[rbp_id][fh.seq_name] += 1
            else:
                regions_with_motifs_dic[rbp_id][fh.seq_name] = 1
        else:
            regions_with_motifs_dic[rbp_id] = {}
            regions_with_motifs_dic[rbp_id][fh.seq_name] = 1

        fh_str = repr(fh) # genomic motif region string.

        # Unique motif regions for each RBP.
        if rbp_id in unique_motifs_dic:
            if fh_str in unique_motifs_dic[rbp_id]:
                unique_motifs_dic[rbp_id][fh_str] += 1
            else:
                unique_motifs_dic[rbp_id][fh_str] = 1
        else:
            unique_motifs_dic[rbp_id] = {}
            unique_motifs_dic[rbp_id][fh_str] = 1

    # Store regions with structure motifs.
    for cmsh in cmsearch_hits_list:

        rbp_id = id2name_dic[cmsh.motif_id]

        if rbp_id in regions_with_motifs_dic:
            # cmsh.seq_name : FASTA header (== --in genomic sequence region).
            if cmsh.seq_name in regions_with_motifs_dic[rbp_id]:
                regions_with_motifs_dic[rbp_id][cmsh.seq_name] += 1
            else:
                regions_with_motifs_dic[rbp_id][cmsh.seq_name] = 1
        else:
            regions_with_motifs_dic[rbp_id] = {}
            regions_with_motifs_dic[rbp_id][cmsh.seq_name] = 1

        cmsh_str = repr(cmsh) # genomic motif region string.

        # Unique motif regions for each RBP.
        if rbp_id in unique_motifs_dic:
            if cmsh_str in unique_motifs_dic[rbp_id]:
                unique_motifs_dic[rbp_id][cmsh_str] += 1
            else:
                unique_motifs_dic[rbp_id][cmsh_str] = 1
        else:
            unique_motifs_dic[rbp_id] = {}
            unique_motifs_dic[rbp_id][cmsh_str] = 1

    """
    Store infos for each RBP in RBP class.

    search_rbps_dic[rbp_id] = rbp_class
    RBP class arguments:
            name: str,
            seq_motif_ids = None,
            str_motif_ids = None,
            c_hit_reg = 0, # # regions with motif hits.
            perc_hit_reg = 0.0, # % hit regions over all regions (i.e. how many input regions contain >= 1 RBP motif).
            c_motif_hits = 0, # # motif hits.
            c_uniq_motif_hits = 0, # # unique motif hits.
            c_uniq_motif_nts = 0, # # unique motif nucleotides.
            perc_uniq_motif_nts_eff_reg = 0.0, # % unique motif nts over effective region length.
            perc_uniq_motif_nts_cal_reg = 0.0, # % unique motif nts over called region length.
            uniq_motif_hits_eff_1000nt = 0.0, # unique motif hits per effective 1000 nt.
            uniq_motif_hits_cal_1000nt = 0.0, # unique motif hits per called 1000 nt.
            ks_pval = 1.0, # Kolmogorov-Smirnov (KS) statistic p-value (are higher scoring sites enriched with motifs).
            ks_stat = 0.0,
            organism: Optional[str] = None

    Number of sequences for FIMO / cmsearch: 
    c_regions

    """
    # Set number of no-hit regions.
    for rbp_id in search_rbps_dic:
        search_rbps_dic[rbp_id].c_no_hit_reg = c_regions

    for rbp_id in regions_with_motifs_dic:
        # Number of --in regions with RBP motif hits.
        c_hit_reg = len(regions_with_motifs_dic[rbp_id])
        # Count hit regions if --unstranded and not --unstranded-ct.
        if args.unstranded and not args.unstranded_ct:
            c_hit_reg = 0
            seen_ids_dic = {}
            for seq_id in regions_with_motifs_dic[rbp_id]:
                core_id = benchlib.reg_get_core_id(seq_id)
                if core_id not in seen_ids_dic:
                    c_hit_reg += 1
                    seen_ids_dic[core_id] = 1

        # Number of motif hits on --in regions in total.
        c_motif_hits = 0
        for reg_id in regions_with_motifs_dic[rbp_id]:
            c_motif_hits += regions_with_motifs_dic[rbp_id][reg_id]
        search_rbps_dic[rbp_id].c_hit_reg = c_hit_reg
        search_rbps_dic[rbp_id].c_no_hit_reg = c_regions - c_hit_reg
        search_rbps_dic[rbp_id].c_motif_hits = c_motif_hits

        # % hit regions over all regions (i.e. how many input regions contain >= 1 RBP motif).
        search_rbps_dic[rbp_id].perc_hit_reg = (search_rbps_dic[rbp_id].c_hit_reg / c_regions) * 100

    """
    Get unique motif hits.

    unique_motifs_dic:
        Dictionary of dictionaries, format:
        {rbp_id1 -> {'motif_region1': c_motif_region1, 'motif_region2': c_motif_region2}, rbp_id2 -> .. }
    """

    for rbp_id in unique_motifs_dic:
        c_uniq_motif_hits = len(unique_motifs_dic[rbp_id])
        search_rbps_dic[rbp_id].c_uniq_motif_hits = c_uniq_motif_hits
        # Store individual motif unique hits.
        for motif_str_repr in unique_motifs_dic[rbp_id]:
            motif_id = benchlib.get_motif_id_from_str_repr(motif_str_repr)
            idx = motif_id2idx_dic[motif_id]
            if id2type_dic[motif_id] == "meme_xml":
                search_rbps_dic[rbp_id].seq_motif_hits[idx] += 1
            elif id2type_dic[motif_id] == "regex":
                search_rbps_dic[rbp_id].seq_motif_hits[idx] += 1
            elif id2type_dic[motif_id] == "cm":
                search_rbps_dic[rbp_id].str_motif_hits[idx] += 1
            else:
                assert False, "unknown motif type (\"%s\") set for motif_id %s" %(id2type_dic[motif_id], motif_id)

    """
    Number of motif nucleotides over called + effective region size.

    """

    print("Calculate effective motif region sizes for each RBP ... ")
    for rbp_id in unique_motifs_dic:
        # Output unique motif hit regions (sequence or structure) to BED for RBP rbp_id.
        benchlib.output_motif_hits_to_bed(rbp_id, unique_motifs_dic, out_tmp_bed,
                                          one_based_start=True)
        # Calculate effective motif region size.
        eff_motif_reg_size = benchlib.get_uniq_gen_size(out_tmp_bed)

        # Number of unique motif nucleotides.
        search_rbps_dic[rbp_id].c_uniq_motif_nts = eff_motif_reg_size
        # % unique motif nts over effective region length.
        search_rbps_dic[rbp_id].perc_uniq_motif_nts_eff_reg = (eff_motif_reg_size / eff_reg_size) * 100
        # % unique motif nts over called region length.
        search_rbps_dic[rbp_id].perc_uniq_motif_nts_cal_reg = (eff_motif_reg_size / called_reg_size) * 100
        # Number of unique motif hits per effective 1000 nt.
        search_rbps_dic[rbp_id].uniq_motif_hits_eff_1000nt  = search_rbps_dic[rbp_id].c_uniq_motif_hits / (eff_reg_size / 1000)
        # Number of unique motif hits per called 1000 nt.
        search_rbps_dic[rbp_id].uniq_motif_hits_cal_1000nt  = search_rbps_dic[rbp_id].c_uniq_motif_hits / (called_reg_size / 1000)

    """
    # Print RBP object stats.
    for rbp_id in search_rbps_dic:
        print(search_rbps_dic[rbp_id].__dict__)

    """

    # print(search_rbps_dic["AGGF1"].__dict__)
    print("# --in regions for motif search:", c_regions)
    print("Called genomic region size:     ", called_reg_size)
    print("Effective genomic region size:  ", eff_reg_size)


    """
    Some motif enrichment tests.

    Kolmogorov-Smirnov test:
    conda install -c conda-forge scipy
    from scipy.stats import ks_2samp
    scipy.stats.ks_2samp()
    https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.ks_2samp.html
    Performs the two-sample Kolmogorov-Smirnov test for goodness of fit.    
    This test compares the underlying continuous distributions F(x) and G(x) of 
    two independent samples. See Notes for a description of the available null 
    and alternative hypotheses.

    Changing log2 FC to FC results in same p-values ...

    alternative: two-sided, greater, less
    
    Alternatively:
    Wilcoxon signed-rank test:
    https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.wilcoxon.html
    alternative: two-sided, greater, less
    This however needs same input sizes (x,y)
    Alternatively, use Wilcoxon rank-sum test (Mann-Whitney U test)

    
    """

    # print("Calculate Kolmogorov-Smirnov (KS) statistics ... ")
    print("Calculate Wilcoxon rank-sum test statistics ... ")

    # Wilcoxon rank-sum test / Mann Whitney U test mode.
    wrs_alt_hypo = "greater"
    if args.wrs_mode == 1:
        wrs_alt_hypo = "greater"
        print("Check if motif-containing regions have significantly higher scores ... ")
    elif args.wrs_mode == 2:
        wrs_alt_hypo = "less"
        print("Check if motif-containing regions have significantly lower scores ... ")
    else:
        assert False, "Invalid Wilcoxon rank-sum (Mann Whitney U) test mode: %i" %(args.wrs_mode)

    # Check if all scores same (e.g. 0).
    reg_scores_dic = {}
    for reg_id in reg2sc_dic:
        reg_scores_dic[reg2sc_dic[reg_id]] = 1
    if len(reg_scores_dic) == 1:
        print("WARNING: all site scores identical. Reported p-values meaningless! (i.e., equal 1.0)")

    wc_pval_dic = {}
    for rbp_id in regions_with_motifs_dic:
        hit_reg_scores = []
        non_hit_reg_scores = []
        seen_ids_dic = {}
        # CHECK?
        for reg_id in reg2sc_dic:
            reg_sc = reg2sc_dic[reg_id]  # float value.

            # If --unstranded, count regions only once as hit or no hit.
            if args.unstranded and not args.unstranded_ct:
                core_id = benchlib.reg_get_core_id(reg_id)
                reg_id1 = core_id + "(+)"
                reg_id2 = core_id + "(-)"
                if core_id not in seen_ids_dic:
                    if reg_id1 in regions_with_motifs_dic[rbp_id] or reg_id2 in regions_with_motifs_dic[rbp_id]:
                        hit_reg_scores.append(reg_sc)
                    else:
                        non_hit_reg_scores.append(reg_sc)
                    seen_ids_dic[core_id] = 1

            else:
                if reg_id in regions_with_motifs_dic[rbp_id]:
                    hit_reg_scores.append(reg_sc)
                else:
                    non_hit_reg_scores.append(reg_sc)

        # print("rbp_id:", rbp_id)
        # print("hit_reg_scores:", hit_reg_scores)
        # print("non_hit_reg_scores:", non_hit_reg_scores)
        # print("# hit regions:    ", len(hit_reg_scores))
        # print("# non-hit regions:", len(non_hit_reg_scores))

        # Calculate the KS statistic and p-value
        # ks_stat, ks_pval = ks_2samp(hit_reg_scores, non_hit_reg_scores, alternative="less")

        wc_pval = 1.0
        # In case no regions without motif hits.
        if not non_hit_reg_scores:
            print("WARNING: all input regions contain %s motifs. Adding dummy scores (median) ... " %(rbp_id))
            dummy_val = statistics.median(hit_reg_scores)
            hit_reg_scores.append(dummy_val)
            non_hit_reg_scores.append(dummy_val)

        # Wilcoxon rank-sum test (Mann-Whitney U test).
        if unique_motifs_dic[rbp_id]:
            wc_stat, wc_pval = mannwhitneyu(hit_reg_scores, non_hit_reg_scores, alternative=wrs_alt_hypo)
            # wc_stat_less, wc_pval_less = mannwhitneyu(hit_reg_scores, non_hit_reg_scores, alternative="less")

            #print("hit_reg_scores:", hit_reg_scores)
            #print("non_hit_reg_scores:", non_hit_reg_scores)
            # search_rbps_dic[rbp_id].ks_pval = ks_pval
            search_rbps_dic[rbp_id].wc_pval = wc_pval
            # search_rbps_dic[rbp_id].wc_pval_less = wc_pval_less
            wc_pval_dic[rbp_id] = wc_pval

        # print("KS p-value (%s):" %(rbp_id), p_value)


    # Print out RBPs sorted by Wilcoxon p-value.
    sorted_wc_pval_dic = dict(sorted(wc_pval_dic.items(), key=lambda item: item[1], reverse=False))
    print("Compact hit stats (RBP ID, # unique hits, Wilcoxon p-value):")
    for rbp_id, p_value in sorted_wc_pval_dic.items():
        # print("KS p-value (%s):" %(rbp_id), p_value)
        # print(rbp_id, ":", p_value)
        c_hits = search_rbps_dic[rbp_id].c_uniq_motif_hits
        # ks_pval = search_rbps_dic[rbp_id].ks_pval
        # wc_pval_less = search_rbps_dic[rbp_id].wc_pval_less
        # print("RBP:", rbp_id, "# hits:", c_uniq_motif_hits, "KS p-value:", p_value)
        # print("%s\t%i\t%s\t%s" %(rbp_id, c_hits, str(p_value), str(wc_pval_less)))
        print("%s\t%i\t%s" %(rbp_id, c_hits, str(p_value)))
    print("")
    """
    Output RBP hit stats (ie one row per RBP).

    Output clowns:
    rbp_id
    c_regions
    called_reg_size
    effective_reg_size
    c_reg_with_hits
    perc_reg_with_hits
    c_motif_hits
    c_uniq_motif_hits
    c_uniq_motif_nts
    perc_uniq_motif_nts_cal_reg
    perc_uniq_motif_nts_eff_reg
    uniq_motif_hits_cal_1000nt
    uniq_motif_hits_eff_1000nt
    wc_pval
    seq_motif_ids
    seq_motif_hits
    str_motif_ids
    str_motif_hits

    """

    rbp_list = []

    OUTSTATS = open(rbp_stats_out, "w")
    rbp_stats_header = "data_id\tmethod_id\trun_id\tmotif_db\trbp_id\tc_regions\tmean_reg_len\tmedian_reg_len\tmin_reg_len\tmax_reg_len\t"
    rbp_stats_header += "called_reg_size\teffective_reg_size\tc_reg_with_hits\tperc_reg_with_hits\t"
    rbp_stats_header += "c_motif_hits\tc_uniq_motif_hits\tc_uniq_motif_nts\tperc_uniq_motif_nts_cal_reg\tperc_uniq_motif_nts_eff_reg\tuniq_motif_hits_cal_1000nt\t"
    rbp_stats_header += "uniq_motif_hits_eff_1000nt\twc_pval\tseq_motif_ids\tseq_motif_hits\tstr_motif_ids\tstr_motif_hits\tinternal_id\n"
    OUTSTATS.write(rbp_stats_header)

    for rbp_id in search_rbps_dic:

        # print(search_rbps_dic[rbp_id].__dict__)
        rbp_list.append(rbp_id)

        motif_db_out = loaded_rbps_dic[rbp_id]

        c_reg_with_hits = search_rbps_dic[rbp_id].c_hit_reg
        perc_reg_with_hits = search_rbps_dic[rbp_id].perc_hit_reg
        c_motif_hits = search_rbps_dic[rbp_id].c_motif_hits
        c_uniq_motif_hits = search_rbps_dic[rbp_id].c_uniq_motif_hits
        c_uniq_motif_nts = search_rbps_dic[rbp_id].c_uniq_motif_nts
        perc_uniq_motif_nts_cal_reg = search_rbps_dic[rbp_id].perc_uniq_motif_nts_cal_reg
        perc_uniq_motif_nts_eff_reg = search_rbps_dic[rbp_id].perc_uniq_motif_nts_eff_reg
        uniq_motif_hits_cal_1000nt = search_rbps_dic[rbp_id].uniq_motif_hits_cal_1000nt
        uniq_motif_hits_eff_1000nt = search_rbps_dic[rbp_id].uniq_motif_hits_eff_1000nt
        wc_pval = search_rbps_dic[rbp_id].wc_pval
        internal_id = search_rbps_dic[rbp_id].internal_id

        seq_motif_hits = ",".join(str(hc) for hc in search_rbps_dic[rbp_id].seq_motif_hits)
        str_motif_hits = ",".join(str(hc) for hc in search_rbps_dic[rbp_id].str_motif_hits)
        seq_motif_ids = ",".join(search_rbps_dic[rbp_id].seq_motif_ids)
        str_motif_ids = ",".join(search_rbps_dic[rbp_id].str_motif_ids)
        if not seq_motif_hits:
            seq_motif_hits = "-"
        if not str_motif_hits:
            str_motif_hits = "-"
        if not seq_motif_ids:
            seq_motif_ids = "-"
        if not str_motif_ids:
            str_motif_ids = "-"

        row_str = args.data_id + "\t"
        row_str += args.method_id + "\t"
        row_str += run_id + "\t"
        row_str += motif_db_out + "\t"
        row_str += rbp_id + "\t"

        row_str += str(c_regions) + "\t"

        row_str += str(reg_len_mean) + "\t"
        row_str += str(reg_len_median) + "\t"
        row_str += str(reg_len_min) + "\t"
        row_str += str(reg_len_max) + "\t"

        row_str += str(called_reg_size) + "\t"
        row_str += str(eff_reg_size) + "\t"

        row_str += str(c_reg_with_hits) + "\t"
        row_str += str(perc_reg_with_hits) + "\t"

        row_str += str(c_motif_hits) + "\t"
        row_str += str(c_uniq_motif_hits) + "\t"
        row_str += str(c_uniq_motif_nts) + "\t"
        row_str += str(perc_uniq_motif_nts_cal_reg) + "\t"
        row_str += str(perc_uniq_motif_nts_eff_reg) + "\t"
        row_str += str(uniq_motif_hits_cal_1000nt) + "\t"
        row_str += str(uniq_motif_hits_eff_1000nt) + "\t"
        row_str += str(wc_pval) + "\t"
        row_str += seq_motif_ids + "\t"
        row_str += seq_motif_hits + "\t"
        row_str += str_motif_ids + "\t"
        row_str += str_motif_hits + "\t"
        row_str += internal_id + "\n"

        OUTSTATS.write(row_str)

    OUTSTATS.close()

    """
    Region ID list.
    
    """
    reg_ids_list = []
    reg_ids_dic = {}
    if args.unstranded and not args.unstranded_ct:
        for seq_id, seq in sorted(out_seqs_dic.items()):
            core_id = benchlib.reg_get_core_id(seq_id)
            reg_ids_list.append(core_id)
            reg_ids_dic[core_id] = 1
    else:
        for seq_id, seq in sorted(out_seqs_dic.items()):
            reg_ids_list.append(seq_id)
            reg_ids_dic[seq_id] = 1

    rbp_list.sort()
    len_rbp_list = len(rbp_list)
    # Store rbp_id -> for each region if hit: 1, else: 0, i.e.: [1,0,0,0,0]
    reg_hits_dic = {}
    add_count = False # Add # of motif hits in region or just add 1 (if False)

    # RBP ID to index mapping.
    rbp2idx_dic = {}
    idx2rbp_dic = {}
    print("Get RBP region occupancies ... ")
    for idx, rbp_id in enumerate(rbp_list):
        rbp2idx_dic[rbp_id] = idx
        idx2rbp_dic[idx] = rbp_id
        # Region has hits yes(1)/no(0).
        hit_list = []
        for reg_id in reg_ids_list:
            if args.unstranded and not args.unstranded_ct:
                reg_id1 = reg_id + "(+)"
                reg_id2 = reg_id + "(-)"
                if rbp_id in regions_with_motifs_dic and (reg_id1 in regions_with_motifs_dic[rbp_id] or reg_id2 in regions_with_motifs_dic[rbp_id]):
                    hit_list.append(1)
                else:
                    hit_list.append(0)
            else:
                if rbp_id in regions_with_motifs_dic and reg_id in regions_with_motifs_dic[rbp_id]:
                    if add_count:
                        hit_list.append(regions_with_motifs_dic[rbp_id][reg_id])
                    else:
                        hit_list.append(1)
                else:
                    hit_list.append(0)
        reg_hits_dic[rbp_id] = hit_list

    """
    Output occupancies.

    reg_hits_dic[rbp_id] = [0,1,0,0, ...]
    reg_ids_list = [reg_id1, reg_id2, ... ]

    rbp2regidx_dic:
        # rbp_id -> 0-based indexes of occupied regions, e.g. [0, 3, 12, 88, 114] 

    """
    rbp2regidx_dic = {}
    OUTOCC = open(rbp_reg_occ_table_out,"w")

    occ_header = "#region_id \ rbp_id"
    for rbp_id, hit_list in sorted(reg_hits_dic.items()):
        occ_header += "\t%s" %(rbp_id)
        rbp2regidx_dic[rbp_id] = []
        for idx, label in enumerate(hit_list):
            if label:  # if occupied (i.e. 1-label).
                rbp2regidx_dic[rbp_id].append(idx)
    OUTOCC.write("%s\n" %(occ_header))
    for idx, reg_id in enumerate(reg_ids_list):
        occ_row = "%s" %(reg_id)
        for rbp_id, hit_list in sorted(reg_hits_dic.items()):
            occ_row += "\t%i" %(hit_list[idx])
        OUTOCC.write("%s\n" %(occ_row))
    OUTOCC.close()

    # occ_header = "#rbp_id \ region_id"
    # for reg_id in reg_ids_list:
    #     occ_header += "\t%s" %(reg_id)
    # OUTOCC.write("%s\n" %(occ_header))
    # for rbp_id in reg_hits_dic:
    #     rbp2regidx_dic[rbp_id] = []
    #     occ_row = "%s" %(rbp_id)
    #     for idx, label in enumerate(reg_hits_dic[rbp_id]):
    #         occ_row += "\t%i" %(label)
    #         if label:  # if occupied (i.e. 1-label).
    #             rbp2regidx_dic[rbp_id].append(idx)
    #     OUTOCC.write("%s\n" %(occ_row))
    # OUTOCC.close()

    """
    Store RBP binding information for each input region.
    Format region_rbp_binds_dic:
    region_id -> [False, True, False ... ]
    with list number of RBP IDs (len_rbp_list), alphabetically sorted.
    Format region_rbp_motif_pos_dic:
    Region ID -> "motif_id,start_1based,end_1based,p_value/-(bit_score)"
    E.g.
    region_rbp_motif_pos_dic["reg1"] = ["rbp1_m1,98,102,0.01", "rbp1_m1,110,115,0.1", "rbp1_m2,110,115,0.05", "rbp2_m1,115,120,0.02", "rbp3_m1,90,95,0.01"]
    region2motif_hits_dic:
    region_id -> [motif_hit1, motif_hit2, ...] with motif_hit format: "motif_id,seq_start,seq_end,p_value/-(bit_score)"

    """
    region_rbp_binds_dic = {}
    region_rbp_motif_pos_dic = {}
    region2motif_hits_dic = {}  # For plotting.
    rid2rbpidx2hcp_dic = {}  # region_id -> rbp_idx -> motif hit center position(s)

    # Checks (make sure use_region_ids=True in bed_filter_extend_bed() function).
    for reg_id in out_seqs_dic:
        assert reg_id in reg2sc_dic, "region ID \"%s\" from out_seqs_dic not found in reg2sc_dic" %(reg_id)
        if args.unstranded and not args.unstranded_ct:
            core_id = benchlib.reg_get_core_id(reg_id)  # If --unstranded (and not --unstranded-ct), get core ID to count region as one.
            if core_id not in region_rbp_binds_dic:
                region_rbp_binds_dic[core_id] = [False]*len_rbp_list
                region_rbp_motif_pos_dic[core_id] = []
                rid2rbpidx2hcp_dic[core_id] = {}
        else:
            region_rbp_binds_dic[reg_id] = [False]*len_rbp_list
            region_rbp_motif_pos_dic[reg_id] = []
            region2motif_hits_dic[reg_id] = []
            rid2rbpidx2hcp_dic[reg_id] = {}

    """
    Output motif region stats (1 row for each motif hit).
    Report ALL motif hits,
    plus report how many times one genomic motif hit occurs (uniq_count). 

    """

    OUTSTATS = open(motif_stats_out,"w")

    motif_stats_header = "data_id\tmethod_id\trun_id\tmotif_db\tregion_id\trbp_id\tmotif_id\tchr_id\tgen_s\tgen_e\tstrand\tregion_s\tregion_e\tregion_len\t"
    motif_stats_header += "uniq_count\tfimo_score\tfimo_pval\tcms_score\tcms_eval\tinternal_id\n"
    OUTSTATS.write(motif_stats_header)

    # Unique motif regions BED.
    motif_reg_dic = {}

    # hit_id = "%s:%s-%s(%s),%s" %(cols[7], cols[8], cols[9], cols[10], cols[6])

    for fh in fimo_hits_list:

        rbp_id = id2name_dic[fh.motif_id]
        region_id = fh.seq_name
        region_len = benchlib.get_length_from_seq_name(fh.seq_name)
        # genomic motif region string.
        fh_str = repr(fh)
        uniq_count = unique_motifs_dic[rbp_id][fh_str]
        # Store binding info of RBP in region.
        rbp_idx = rbp2idx_dic[rbp_id]

        # Motif hit string.
        motif_str = "%s,%i,%i,%s" %(fh.motif_id, fh.start, fh.end, str(fh.pval))
        motif_str_plot = "%s,%i-%i,%s" %(fh.motif_id, fh.seq_s, fh.seq_e, str(fh.pval))

        # Center position of motif hit.
        motif_hit_s = fh.seq_s - 1
        motif_hit_e = fh.seq_e
        center_pos = benchlib.get_center_position(motif_hit_s, motif_hit_e)
        
        if args.unstranded and not args.unstranded_ct:
            core_id = benchlib.reg_get_core_id(region_id)
            region_rbp_binds_dic[core_id][rbp_idx] = True
            region_rbp_motif_pos_dic[core_id].append(motif_str)
            region2motif_hits_dic[core_id].append(motif_str_plot)
            if rbp_idx not in rid2rbpidx2hcp_dic[core_id]:
                rid2rbpidx2hcp_dic[core_id][rbp_idx] = [center_pos]
            else:
                rid2rbpidx2hcp_dic[core_id][rbp_idx].append(center_pos)
        else:
            region_rbp_binds_dic[region_id][rbp_idx] = True
            region_rbp_motif_pos_dic[region_id].append(motif_str)
            region2motif_hits_dic[region_id].append(motif_str_plot)
            if rbp_idx not in rid2rbpidx2hcp_dic[region_id]:
                rid2rbpidx2hcp_dic[region_id][rbp_idx] = [center_pos]
            else:
                rid2rbpidx2hcp_dic[region_id][rbp_idx].append(center_pos)

        motif_db_out = loaded_motif_ids_dic[fh.motif_id]

        internal_id = search_rbps_dic[rbp_id].internal_id

        # Store motif hit as BED.
        hit_id = "%s:%s-%s(%s),%s" %(fh.chr_id, str(fh.start), str(fh.end), fh.strand, fh.motif_id)
        if hit_id not in motif_reg_dic:
            bed_row = "%s\t%i\t%i\t%s,%s;%i;%s,%s\t0\t%s\t%s\t%s\t-1.0\t-1.0" %(fh.chr_id, fh.start-1, fh.end, rbp_id, fh.motif_id, uniq_count, args.method_id, args.data_id, fh.strand, str(fh.score), str(fh.pval))
            motif_reg_dic[hit_id] = bed_row

        row_str = args.data_id + "\t"
        row_str += args.method_id + "\t"
        row_str += run_id + "\t"
        row_str += motif_db_out + "\t"
        row_str += region_id + "\t"
        row_str += rbp_id + "\t"
        row_str += fh.motif_id + "\t"
        row_str += fh.chr_id + "\t"
        row_str += str(fh.start) + "\t"  # 1-based.
        row_str += str(fh.end) + "\t"
        row_str += fh.strand + "\t"
        row_str += str(fh.seq_s) + "\t"  # 1-based.
        row_str += str(fh.seq_e) + "\t"
        row_str += str(region_len) + "\t"
        row_str += str(uniq_count) + "\t"
        row_str += str(fh.score) + "\t"
        row_str += str(fh.pval) + "\t"
        row_str += "-\t"
        row_str += "-\t"
        row_str += internal_id + "\n"

        OUTSTATS.write(row_str)

    for cmsh in cmsearch_hits_list:

        rbp_id = id2name_dic[cmsh.motif_id]
        region_id = cmsh.seq_name
        region_len = benchlib.get_length_from_seq_name(cmsh.seq_name)
        # genomic motif region string.
        cmsh_str = repr(cmsh) 
        uniq_count = unique_motifs_dic[rbp_id][cmsh_str]
        # Store binding info of RBP in region.
        rbp_idx = rbp2idx_dic[rbp_id]

        # Motif hit string.
        motif_str = "%s,%i,%i,%s" %(cmsh.motif_id, cmsh.start, cmsh.end, str(-1*cmsh.score))
        motif_str_plot = "%s,%i-%i,%s" %(cmsh.motif_id, cmsh.seq_s, cmsh.seq_e, str(cmsh.score))

        # Center position of motif hit.
        motif_hit_s = cmsh.seq_s - 1
        motif_hit_e = cmsh.seq_e
        center_pos = benchlib.get_center_position(motif_hit_s, motif_hit_e)
        
        if args.unstranded and not args.unstranded_ct:
            core_id = benchlib.reg_get_core_id(region_id)
            region_rbp_binds_dic[core_id][rbp_idx] = True
            region_rbp_motif_pos_dic[core_id].append(motif_str)
            region2motif_hits_dic[core_id].append(motif_str_plot)
            if rbp_idx not in rid2rbpidx2hcp_dic[core_id]:
                rid2rbpidx2hcp_dic[core_id][rbp_idx] = [center_pos]
            else:
                rid2rbpidx2hcp_dic[core_id][rbp_idx].append(center_pos)
        else:
            region_rbp_binds_dic[region_id][rbp_idx] = True
            region_rbp_motif_pos_dic[region_id].append(motif_str)
            region2motif_hits_dic[region_id].append(motif_str_plot)
            if rbp_idx not in rid2rbpidx2hcp_dic[region_id]:
                rid2rbpidx2hcp_dic[region_id][rbp_idx] = [center_pos]
            else:
                rid2rbpidx2hcp_dic[region_id][rbp_idx].append(center_pos)

        motif_db_out = loaded_motif_ids_dic[cmsh.motif_id]

        internal_id = search_rbps_dic[rbp_id].internal_id

        # Store motif hit as BED.
        hit_id = "%s:%s-%s(%s),%s" %(cmsh.chr_id, str(cmsh.start), str(cmsh.end), cmsh.strand, cmsh.motif_id)
        if hit_id not in motif_reg_dic:
            bed_row = "%s\t%i\t%i\t%s,%s;%i;%s,%s\t0\t%s\t%s\t%s\t-1.0\t-1.0" %(cmsh.chr_id, cmsh.start-1, cmsh.end, rbp_id, cmsh.motif_id, uniq_count, args.method_id, args.data_id, cmsh.strand, str(cmsh.score), str(cmsh.e_value))
            motif_reg_dic[hit_id] = bed_row

        row_str = args.data_id + "\t"
        row_str += args.method_id + "\t"
        row_str += run_id + "\t"
        row_str += motif_db_out + "\t"
        row_str += region_id + "\t"
        row_str += rbp_id + "\t"
        row_str += cmsh.motif_id + "\t"
        row_str += cmsh.chr_id + "\t"
        row_str += str(cmsh.start) + "\t"
        row_str += str(cmsh.end) + "\t"
        row_str += cmsh.strand + "\t"
        row_str += str(cmsh.seq_s) + "\t"
        row_str += str(cmsh.seq_e) + "\t"
        row_str += str(region_len) + "\t"
        row_str += str(uniq_count) + "\t"
        row_str += "-\t"
        row_str += "-\t"
        row_str += str(cmsh.score) + "\t"
        row_str += str(cmsh.e_value) + "\t"
        row_str += internal_id + "\n"
        #print("region_id:", region_id)
        #print("evalue:", cmsh.e_value)
        #print(row_str)

        OUTSTATS.write(row_str)

    OUTSTATS.close()

    """
    Output motif hits as BED.

    The motif hits written to motif_hits_bed_out are unique motif hits already. 
    If same hit occurs > 1, this is recorded in BED column 4 with format:
    rbp_id,motif_id;uniq_count;method_id,data_id
    These also include regex hits, as they are part of fimo hits.
    
    """

    OUTBED = open(motif_hits_bed_out,"w")
    for hit_id in motif_reg_dic:
        OUTBED.write("%s\n" %(motif_reg_dic[hit_id]))
    OUTBED.close()


    """
    Significance testing:
    Check for co-occurrences of motifs from different RBPs in regions.
    Use 2x2 contingency tables, and some test for significance,
    e.g. Fisher exact or Chi-squared

    region_rbp_binds_dic format:
    'chr20:62139082-62139128(-)': [False, False, False]
    ...
    rbp2idx_dic
    idx2rbp_dic

    from itertools import combinations
    Number of combinations (draw k from n elements, no order, no repetition)
    Binomialcoefficient: n over k, where n = #RBPs, and k = 2
    rbp_pairs = list(combinations(rbp_list, 2))

    make_contingency_table_2x2(region_labels_dic, idx1, idx2):
    https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.fisher_exact.html
                   List 1              Not in List 1
    List 2         A                   B
    Not in List 2  C                   D

    table = [[A, B], [C, D]]

    from scipy.stats import chi2_contingency
    stat, p, dof, expected = chi2_contingency(table)
    Note that chi2_contingency does not tolerate zero elements.

    """

    # Store p-values in 2d-list.
    pval_ll = []  # p-values (Fisher exact test).
    or_ll = []  # odds ratios.
    pval_cont_lll = []

    for rbp_id in rbp_list:
        pval_ll.append([1.0]*len_rbp_list)
        pval_cont_lll.append([]*len_rbp_list)
        # pval_cont_lll.append([["1.0","-", "-"]]*len_rbp_list)
        or_ll.append([0.0]*len_rbp_list)

    for i in range(len_rbp_list):
        for j in range(len_rbp_list):
            # Storing [p-value_str, pair_str, table_str, correlation_str].
            pval_cont_lll[i].append(["1.0","-", "-", "-", "-", "-", "-"])  

    # Add p-values of 1.0 in diagonal.
    # for idx, rbp_id in enumerate(rbp_list):
    #     pval_ll[idx][idx] = 1.0
    #     pval_cont_lll[idx][idx] = 1.0

    rbp_pairs = list(combinations(rbp_list, 2))
    con_pval_dic = {}
    con_table_dic = {}
    pair_str_dic = {}

    # print("rbp2idx_dic:", rbp2idx_dic)
    # print("region_rbp_binds_dic:", region_rbp_binds_dic)
    # print("len(region_rbp_binds_dic):", len(region_rbp_binds_dic))
    # true_c = 0
    # for reg_id in region_rbp_binds_dic:
    #     for label in region_rbp_binds_dic[reg_id]:
    #         if label:
    #             true_c += 1
    # print("# TRUEs:", true_c)

    c_regions_with_hits = 0
    for reg_id in region_rbp_binds_dic:
        reg_hit = False
        for label in region_rbp_binds_dic[reg_id]:
            if label:
                reg_hit = True
        if reg_hit:
            c_regions_with_hits += 1
    print("# regions with hits (all motifs):", c_regions_with_hits)

    fisher_alt_hypo = "greater"
    if args.fisher_mode == 1:
        fisher_alt_hypo = "greater"
        print("Fisher mode = 1, reporting significantly overrepresented co-occurrences ... ")
    elif args.fisher_mode == 2:
        fisher_alt_hypo = "two-sided"
        print("Fisher mode = 2, reporting significantly over- AND underrepresented co-occurrences ... ")
    elif args.fisher_mode == 3:
        fisher_alt_hypo = "less"
        print("Fisher mode = 3, reporting significantly underrepresented co-occurrences ... ")
    else:
        assert False, "Invalid Fisher mode: %i" %(args.fisher_mode)

    p_val_list = []  # Fisher exact test p-values.

    print("Compute motif region co-occurrences between RBP pairs ... ")
    for pair in rbp_pairs:
        pair = list(pair)
        pair.sort()

        idx1 = rbp2idx_dic[pair[0]]
        idx2 = rbp2idx_dic[pair[1]]
        # pair_list = [pair[0], pair[1]]
        # pair_list.sort()
        pair_str = ",".join(pair)
        # pair_str_dic[pair_str] = [pair_list[0], pair_list[1]]
        pair_str_dic[pair_str] = [pair[0], pair[1]]

        # avg_min_dist and perc_close_hits = "-" if no common hit regions.
        table, avg_min_dist, perc_close_hits = benchlib.make_contingency_table_2x2_v2(
                                                       region_rbp_binds_dic, idx1, idx2,
                                                       rid2rbpidx2hcp_dic,
                                                       max_motif_dist=args.max_motif_dist)

        odds_ratio, p_value = fisher_exact(table, alternative=fisher_alt_hypo)

        # if p_value == 0:
        #   p_value = 2.2e-308
        #   print("PVALUE ZERO! (%s, odds_ratio: %s)" %(str(p_value), str(odds_ratio)))
        #   print("pair_str:", pair_str)
        #   print("table_str:", table_str)

        # con_pval_dic[pair_str] = p_value
        con_table_dic[pair_str] = table
        table_str = str(table)

        # print(pair_str, table_str, p_value)
        # print("Pair:", pair_str, "Odds ratio:", odds_ratio,"Fisher p-value:", p_value)

        # Corrected p-value.
        # corr_p_val = p_value * mult_test_corr_factor

        p_value_plotted = p_value
        p_val_list.append(p_value)
        # if p_value > cooc_pval_thr:
        #     p_value_plotted = 1.0

        pval_ll[idx1][idx2] = p_value_plotted
        pval_ll[idx2][idx1] = p_value_plotted
        pval_cont_lll[idx2][idx1][0] = str(p_value)
        pval_cont_lll[idx2][idx1][1] = str(p_value_plotted)
        pval_cont_lll[idx2][idx1][2] = pair_str
        pval_cont_lll[idx2][idx1][3] = table_str
        pval_cont_lll[idx2][idx1][4] = avg_min_dist
        pval_cont_lll[idx2][idx1][5] = perc_close_hits

        # pval_cont_lll[idx2][idx1][0] = str(p_value)
        # pval_cont_lll[idx2][idx1][1] = pair_str
        # pval_cont_lll[idx2][idx1][2] = table_str
        or_ll[idx1][idx2] = odds_ratio
        or_ll[idx2][idx1] = odds_ratio

    """
    Multiple testing correction.

    """

    cooc_pval_thr = args.cooc_pval_thr

    if args.cooc_pval_mode == 1:  # Bonferroni correction.

        # Multiple testing correction factor.
        mult_test_corr_factor = 1
        if len_rbp_list > 1:
            mult_test_corr_factor = (len_rbp_list*(len_rbp_list-1))/2

        cooc_pval_thr = args.cooc_pval_thr / mult_test_corr_factor

    elif args.cooc_pval_mode == 2:  # BH correction.

        pvals_corrected = false_discovery_control(p_val_list, method='bh')

        for i in range(len(p_val_list)):
            p_val_list[i] = pvals_corrected[i]

    elif args.cooc_pval_mode == 3:  # No correction.

        cooc_pval_thr = args.cooc_pval_thr

    else:
        assert False, "Invalid co-occurrence p-value mode (--cooc-pval-mode) set: %i" %(args.cooc_pval_mode)


    # Update + filter p-values.

    pv_idx = 0
    
    for pair in rbp_pairs:
        pair = list(pair)
        pair.sort()

        idx1 = rbp2idx_dic[pair[0]]
        idx2 = rbp2idx_dic[pair[1]]

        pair_str = ",".join(pair)

        p_value = p_val_list[pv_idx]

        p_value_plotted = p_value

        if p_value > cooc_pval_thr:
            p_value_plotted = 1.0

        pval_ll[idx1][idx2] = p_value_plotted
        pval_ll[idx2][idx1] = p_value_plotted
        pval_cont_lll[idx2][idx1][0] = str(p_value)
        pval_cont_lll[idx2][idx1][1] = str(p_value_plotted)

        con_pval_dic[pair_str] = p_value

        pv_idx += 1


    """
    Print out RBPs sorted by KS p-value.

    """ 
    sorted_con_pval_dic = dict(sorted(con_pval_dic.items(), key=lambda item: item[1], reverse=False))

    print("Co-occurrence contingency table format: [A, B], [C, D]")
    print("A: RBP1 AND RBP2")
    print("B: NOT RBP1 AND RBP2")
    print("C: RBP1 AND NOT RBP2")
    print("D: NOT RBP1 AND NOT RBP2")

    if args.cooc_pval_mode == 1:
        print("Significance threshold: %s (Bonferroni corrected)" %(str(cooc_pval_thr)))
    elif args.cooc_pval_mode == 2:
        print("Significance threshold: %s (on Benjamini-Hochberg corrected p-values)" %(str(cooc_pval_thr)))
    elif args.cooc_pval_mode == 3:
        print("Significance threshold: %s" %(str(cooc_pval_thr)))
    else:
        assert False, "Invalid co-occurrence p-value mode (--cooc-pval-mode) set: %i" %(args.cooc_pval_mode)

    print("Co-occurrence of motifs (RBP IDs (RBP1,RBP2), # hits, contingency table, Fisher p-value)")

    c_reported = 0

    for pair_str, p_value in sorted_con_pval_dic.items():
        if p_value > cooc_pval_thr:
            break
        c_reported += 1
        rbp1 = pair_str_dic[pair_str][0]
        rbp2 = pair_str_dic[pair_str][1]
        con_table = con_table_dic[pair_str]
        rbp1_hits = search_rbps_dic[rbp1].c_uniq_motif_hits
        rbp2_hits = search_rbps_dic[rbp2].c_uniq_motif_hits
        print("%s\t%i,%i\t%s\t%s" %(pair_str, rbp1_hits, rbp2_hits, str(con_table), str(p_value)))

    if not c_reported:
        print("NO SIGNIFICANT CO-OCCURRENCES FOUND!")

    print("")

    # Print table to file.
    benchlib.output_con_table_results(con_res_out_tsv, pval_ll, rbp_list)


    """
    If --report set, calcuate correlations.

    Setting add_count = True changes correlations a bit (use motif hit counts 
    instead of 1 for any number of hits)

    """

    if args.report:

        print("Calculate correlations ... ")
        # Correlation between RBPs dataframe.
        df = DataFrame(reg_hits_dic, columns=rbp_list)
        df_corr = df.corr(method='pearson')

        for i,rbp_i in enumerate(rbp_list):
            for j,rbp_j in enumerate(rbp_list):
                if j > i:
                    pval_ll[i][j] = None

        # Fisher p-value dataframe.
        df_pval = DataFrame(pval_ll, columns=rbp_list, index=rbp_list)

        # Write None to upper-diagonal entries.
        for i,rbp_i in enumerate(rbp_list):
            for j,rbp_j in enumerate(rbp_list):
                if j > i:
                    # df_corr.loc[rbp_i][rbp_j] = None  # FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!
                    df_corr.loc[rbp_i, rbp_j] = None
                else:
                    # Round correlation values if != 1.0.
                    if df_corr.loc[rbp_i][rbp_j] == 1.0:
                        pval_cont_lll[i][j][6] = str(df_corr.loc[rbp_i][rbp_j])
                    else:
                        pval_cont_lll[i][j][6] = "{:.8f}".format(df_corr.loc[rbp_i][rbp_j])

        for i,rbp_i in enumerate(rbp_list):
            for j,rbp_j in enumerate(rbp_list):
                if j > i:
                    df_pval.loc[rbp_i, rbp_j] = None

        # for i in range(len(rbp_list)):
        #     for j in range(len(rbp_list)):
        #         if j > i:
        #             df_corr.iloc[i][j] = None

        # for i in range(len(rbp_list)):
        #     for j in range(len(rbp_list)):
        #         if j > i:
        #             df_pval.iloc[i][j] = None

        # print("df_pval:", df_pval)
        # Log transform p-values.
        benchlib.log_tf_df(df_pval, convert_zero_pv=True, rbp_list=rbp_list)
        # print("df_pval:", df_pval)

        # print("df:", df)
        # print("df.corr():", df.corr(method='pearson'))
        # print("reg_hits_dic[SLBP]:", reg_hits_dic["SLBP"])

        # Plot correlations.
        # motif_db
        # import plotly.express as px
        # fig = px.imshow(df_corr)
        # fig.show()


    """
    If --gtf set, get transcript infos and determine RNA region type for 
    each region (select one with biggest overlap). 

    Next steps:
    1)
    Extract most prominent transcripts (or use --tr-list ones).
    2)
    Overlap transcript exons+introns with regions.
    3)
    For exonic hit, further overlapping operations necessary to determine 
    RNA type /region type (ncRNA, CDS, UTR ...).

    """
    reg2annot_dic = {}
    reg_annot_table_file = None

    if args.in_gtf and c_regions_with_hits:

        reg_annot_table_file = args.out_folder + "/" + "region_annotations.tsv"

        # Get gene infos.
        print("Read in gene features from --gtf ... ")
        tr2gid_dic = {}
        tr_types_dic = {}  # Store transcript biotypes in GTF file.
        gid2gio_dic = benchlib.gtf_read_in_gene_infos(args.in_gtf,
                                                        tr2gid_dic=tr2gid_dic,
                                                        tr_types_dic=tr_types_dic,
                                                        check_chr_ids_dic=chr_ids_dic,
                                                        chr_style=chr_style,
                                                        empty_check=False)
        assert gid2gio_dic, "no gene infos read in from --gtf. Please provide a valid/compatible GTF file (e.g. from Ensembl or ENCODE)"
        c_gene_infos = len(gid2gio_dic)
        print("# gene features read in from --gtf:", c_gene_infos)

        # If --tr-list given.
        tr_ids_dic = {}
        if args.tr_list:
            tr_ids_dic = benchlib.read_ids_into_dic(args.tr_list,
                                                    check_dic=False)
            assert tr_ids_dic, "no IDs read in from provided --tr-list file. Please provide a valid IDs file (one ID per row)"
            for tr_id in tr_ids_dic:
                assert tr_id in tr2gid_dic, "transcript ID \"%s\" from provided --tr-list file does not appear in --gtf file. Please provide compatible files" %(tr_id)
                tr_ids_dic[tr_id] = tr2gid_dic[tr_id]
            print("# of transcript IDs (read in from --tr-list): ", len(tr_ids_dic))
        else:
            # Get most prominent transcripts from gene infos.
            tr_ids_dic = benchlib.select_mpts_from_gene_infos(gid2gio_dic,
                                    basic_tag=False,  # do not be strict (only_tsl=False too).
                                    ensembl_canonical_tag=False,
                                    prior_basic_tag=True,  # Prioritize basic tag transcript.
                                    only_tsl=False)
            assert tr_ids_dic, "most prominent transcript selection from gene infos failed. Please contact developers"
            print("# of transcript IDs (most prominent transcripts): ", len(tr_ids_dic))

        # Check exon order (return True if minus strand exon 1 is most downstream, not most upstream, which is the correct way).
        print("Check minus-strand exon order in --gtf ... ")
        correct_min_ex_order = benchlib.gtf_check_exon_order(args.in_gtf)
        if correct_min_ex_order:
            print("Correct order encountered ... ")
        else:
            print("Reverse order encountered ... ")
        # Get transcript infos.
        print("Read in transcript infos from --gtf ... ")
        tid2tio_dic = benchlib.gtf_read_in_transcript_infos(args.in_gtf, 
                                                            tr_ids_dic=tr_ids_dic,
                                                            correct_min_ex_order=correct_min_ex_order,
                                                            chr_style=chr_style,
                                                            empty_check=False)

        assert tid2tio_dic, "no transcript infos read in from --gtf. Please provide a valid/compatible GTF file (e.g. from Ensembl or ENCODE)"

        # (in)sanity checks.
        for tr_id in tr_ids_dic:
            assert tr_id in tid2tio_dic, "transcript ID %s not in tid2tio_dic"
        for tr_id in tid2tio_dic:
            assert tr_id in tr_ids_dic, "transcript ID %s not in tr_ids_dic"

        c_tr_infos = len(tid2tio_dic)
        print("# transcript features read in from --gtf:", c_tr_infos)

        # Extract exon + intron regions of selected transcripts from transcript infos.
        print("Output intron annotations to BED ... ")
        intron_exon_out_bed = args.out_folder + "/intron_exon_regions.tmp.bed"
        benchlib.output_transcript_info_intron_exon_to_bed(tid2tio_dic, intron_exon_out_bed,
                                            output_mode=3,  # only introns.
                                            report_counts=True,
                                            add_tr_id=True,
                                            empty_check=False)

        # Custom transcript biotypes for upset plot.
        custom_annot_dic = None
        if args.tr_types_list:
            for tr_type in args.tr_types_list:
                assert tr_type in tr_types_dic, "given transcript biotype ID \"%s\" not found in GTF file"
                custom_annot_dic[tr_type] = tr_type

        # Append detailed exon annotations (CDS, UTR, transcript biotypes) to intron annotations.
        print("Output exon annotations to BED ... ")
        benchlib.output_exon_annotations(tid2tio_dic, intron_exon_out_bed,
                                            custom_annot_dic=custom_annot_dic,
                                            append=True)

        # Overlap with input regions.
        print("Overlap annotations with input regions ... ")
        params = "-s -wo -f %s" %(str(args.gtf_feat_min_overlap))
        overlap_annotations_bed = args.out_folder + "/overlap_region_annotations.tmp.bed"
        benchlib.bed_intersect_files(filtered_sites_bed, intron_exon_out_bed, 
                                        overlap_annotations_bed,
                                        params=params)
        
        reg2annot_dic = benchlib.get_region_annotations(overlap_annotations_bed,
                                                        reg_ids_dic=reg_ids_dic)

        # Output assignments.
        print("Output region annotations ... ")
        
        OUTRAN = open(reg_annot_table_file, "w")
        OUTRAN.write("region_id\tgene_id\tgene_name\ttranscript_id\tregion_annotation\ttranscript_biotype\n")

        for reg_id in reg2annot_dic:
            annot = reg2annot_dic[reg_id][0]
            tr_id = reg2annot_dic[reg_id][1]
            gene_id = "-"
            gene_name = "-"
            tr_biotype = "-"
            if tr_id:
                gene_id = tr2gid_dic[tr_id]
                gene_info = gid2gio_dic[gene_id]
                tr_biotype = tid2tio_dic[tr_id].tr_biotype
                gene_name = gene_info.gene_name
            else:
                tr_id = "-"
            OUTRAN.write("%s\t%s\t%s\t%s\t%s\t%s\n" %(reg_id, gene_id, gene_name, tr_id, annot, tr_biotype))
        OUTRAN.close()
        
    elif args.in_gtf and not c_regions_with_hits:
        print("No need to read in --gtf since no motif hits found .. ")

    """
    Motif annotations if --plot-motifs and --gtf set.

    """

    rbp2motif2annot2c_dic = {}  # rbp_id -> motif_id -> annot -> count

    if args.plot_motifs and args.in_gtf and c_regions_with_hits and args.add_motif_annot:

        # Overlap motif hit BED with genomic annotation regions.
        print("Overlap annotations with motif hit regions ... ")

        params = "-s -wo -f %s" %(str(args.gtf_feat_min_overlap))
        overlap_motif_hit_annotations_bed = args.out_folder + "/overlap_motif_hit_annotations.tmp.bed"
        benchlib.bed_intersect_files(motif_hits_bed_out, intron_exon_out_bed, 
                                     overlap_motif_hit_annotations_bed,
                                     params=params)

        motif_hit2annot_dic = benchlib.get_region_annotations(
                                            overlap_motif_hit_annotations_bed,
                                            motif_hits=True,
                                            reg_ids_dic=motif_reg_dic)

        for motif_hit in motif_hit2annot_dic:
            # motif_hit format: "chr1:10-15(+),motif_id". Get motif_id.
            motif_id = motif_hit.split(",")[1]
            annot = motif_hit2annot_dic[motif_hit][0]
            # tr_id = motif_hit2annot_dic[motif_hit][1]
            rbp_id = id2name_dic[motif_id]
            if rbp_id not in rbp2motif2annot2c_dic:
                rbp2motif2annot2c_dic[rbp_id] = {}
            if motif_id not in rbp2motif2annot2c_dic[rbp_id]:
                rbp2motif2annot2c_dic[rbp_id][motif_id] = {}
            if annot not in rbp2motif2annot2c_dic[rbp_id][motif_id]:
                rbp2motif2annot2c_dic[rbp_id][motif_id][annot] = 1
            else:
                rbp2motif2annot2c_dic[rbp_id][motif_id][annot] += 1

    """
    Get annotation to color dictionary, which is needed for region annotation plots in HTML reports.

    """

    annot2color_dic = {}

    if reg2annot_dic or rbp2motif2annot2c_dic:

        annot_dic = {}

        if reg2annot_dic:
            for reg_id in reg2annot_dic:
                annot = reg2annot_dic[reg_id][0]
                if annot not in annot_dic:
                    annot_dic[annot] = 1
                else:
                    annot_dic[annot] += 1

        if rbp2motif2annot2c_dic:
            for rbp_id in rbp2motif2annot2c_dic:
                for motif_id in rbp2motif2annot2c_dic[rbp_id]:
                    for annot in rbp2motif2annot2c_dic[rbp_id][motif_id]:
                        if annot not in annot_dic:
                            annot_dic[annot] = 1
                        else:
                            annot_dic[annot] += 1

        # hex_colors = get_hex_colors_list(min_len=len(annot_with_hits_dic))
        hex_colors = benchlib.get_hex_colors_list(min_len=len(annot_dic))

        idx = 0
        for annot in sorted(annot_dic, reverse=False):
            # hc = hex_colors[idx]
            # print("Assigning hex color %s to annotation %s ... " %(hc, annot))
            annot2color_dic[annot] = hex_colors[idx]
            idx += 1


    """
    Generate HTML report (--report).
    
    """

    html_report_out = args.out_folder + "/" + "report.rbpbench_search.html"
    if args.plot_abs_paths:
        html_report_out = os.path.abspath(args.out_folder) + "/" + "report.rbpbench_search.html"

    # If HTML file already exists, remove it.
    if os.path.exists(html_report_out):
        os.remove(html_report_out)

    if args.report:

        seq_len_df = None
        if not args.disable_len_dist_plot:

            # Sequences dataframe for plotting sequence lengths violin plot.
            sequences = []
            seq_ids = []
            for seq_id in out_seqs_dic:
                seq_ids.append(seq_id)
                sequences.append(out_seqs_dic[seq_id])

            motif_hits = []
            for seq_id in seq_ids:
                # region2motif_hits_dic[seq_id].sort()
                # If list empty, append "-".
                if not region2motif_hits_dic[seq_id]:
                    motif_hits.append("-")
                else:
                    motif_hits.append(benchlib.join_motif_hits(
                                    region2motif_hits_dic[seq_id],
                                    motifs_per_line=3,
                                    line_break_char="<br>"))
                    # motif_hits.append("\n".join(region2motif_hits_dic[seq_id]))

            seq_len_df = DataFrame({
                'Sequence ID': seq_ids,
                'Sequence Length': [len(seq) for seq in sequences],
                'Sequence': [benchlib.insert_line_breaks(seq, line_len=60) for seq in sequences],
                'Motif hits': motif_hits
            })

        plots_subfolder = "html_report_plots"
        benchlib_path = os.path.dirname(benchlib.__file__)

        print("Create report ... ")
        benchlib.search_generate_html_report(df_pval, pval_cont_lll,
                                         search_rbps_dic,
                                         id2name_dic, name2ids_dic,
                                         region_rbp_motif_pos_dic,
                                         reg2pol_dic,
                                         args.out_folder,
                                         benchlib_path,
                                         rbp2regidx_dic,
                                         reg_ids_list,
                                         fisher_mode=args.fisher_mode,
                                         wrs_mode=args.wrs_mode,
                                         seq_len_df=seq_len_df,
                                         set_rbp_id=args.set_rbp_id,
                                         motif_db_str=motif_db_str,
                                         regex_id=regex_id,
                                         seq_motif_blocks_dic=seq_motif_blocks_dic,
                                         max_motif_dist=args.max_motif_dist,
                                         motif_distance_plot_range=args.motif_distance_plot_range,
                                         motif_min_pair_count=args.motif_min_pair_count,
                                         rbp_min_pair_count=args.rbp_min_pair_count,
                                         reg2annot_dic=reg2annot_dic,
                                         annot2color_dic=annot2color_dic,
                                         upset_plot_min_degree=args.upset_plot_min_degree,
                                         upset_plot_max_degree=args.upset_plot_max_degree,
                                         upset_plot_min_subset_size=args.upset_plot_min_subset_size,
                                         upset_plot_max_subset_rank=args.upset_plot_max_subset_rank,
                                         upset_plot_min_rbp_count=args.upset_plot_min_rbp_count,
                                         upset_plot_max_rbp_rank=args.upset_plot_max_rbp_rank,
                                         add_all_reg_bar=args.add_all_reg_bar,
                                         html_report_out=html_report_out,
                                         plot_abs_paths=args.plot_abs_paths,
                                         sort_js_mode=args.sort_js_mode,
                                         plotly_js_mode=args.plotly_js_mode,
                                         cooc_pval_thr=cooc_pval_thr,
                                         cooc_pval_mode=args.cooc_pval_mode,
                                         plots_subfolder=plots_subfolder)


    """
    Motif plots and motif hit statistics HTML.

    """
    html_motif_plots_out = args.out_folder + "/" + "motif_plots.rbpbench_search.html"
    if args.plot_abs_paths:
        html_motif_plots_out = os.path.abspath(args.out_folder) + "/" + "motif_plots.rbpbench_search.html"
    # If HTML file already exists, remove it.
    if os.path.exists(html_motif_plots_out):
        os.remove(html_motif_plots_out)

    if args.plot_motifs:
        
        print("Generate motif plots HTML ... ")
        
        plots_subfolder = "html_motif_plots"
        benchlib_path = os.path.dirname(benchlib.__file__)

        benchlib.search_generate_html_motif_plots(search_rbps_dic, seq_motif_blocks_dic, 
                                         str_motif_blocks_dic, args.out_folder, 
                                         benchlib_path, loaded_motif_ids_dic,
                                         motif_db_str=motif_db_str,
                                         rbp2motif2annot2c_dic=rbp2motif2annot2c_dic,
                                         annot2color_dic=annot2color_dic,
                                         regex_id=regex_id,
                                         sort_js_mode=args.sort_js_mode,
                                         html_report_out=html_motif_plots_out,
                                         plot_abs_paths=args.plot_abs_paths,
                                         plots_subfolder=plots_subfolder)


    """
    Output parameter settings.

    """
    # Output mode settings.
    print("Output parameter settings ... ")
    SETOUT = open(settings_file, "w")
    for arg in vars(args):
        SETOUT.write("%s\t%s\n" %(arg, str(getattr(args, arg))))
    for call in call_dic:
        SETOUT.write("%s\t%s\n" %(call, call_dic[call]))
    SETOUT.close()

    """
    Take out the trash.

    """
    print("Delete .tmp files ... ")
    if os.path.exists(out_tmp_bed):
        os.remove(out_tmp_bed)
    if os.path.exists(cmstat_tmp_out):
        os.remove(cmstat_tmp_out)


    """
    Inform about outputs.

    """
    print("")
    print("OUTPUT FILES")
    print("============")
    print("")
    print("Run parameter settings:\n%s" %(settings_file))
    print("Co-occurrence p-values for each RBP pair .tsv:\n%s" %(con_res_out_tsv))
    print("Filtered input regions .bed:\n%s" %(filtered_sites_bed))
    print("Filtered input regions .fa:\n%s" %(filtered_sites_fa))
    print("Motif hits .bed:\n%s" %(motif_hits_bed_out))
    print("RBP region occupancies .tsv:\n%s" %(rbp_reg_occ_table_out))
    print("RBP hit stats .tsv:\n%s" %(rbp_stats_out))
    print("Motif hit stats .tsv:\n%s" %(motif_stats_out))
    if reg_annot_table_file is not None:
        print("Region annotations .tsv:\n%s" %(reg_annot_table_file))
    if args.plot_motifs:
        print("Motif plots and hit statistics .html:\n%s" %(html_motif_plots_out))
    if args.report:
        print("Search report .html:\n%s" %(html_report_out))
    print("")


################################################################################

def main_batch(args):
    """
    Batch search motifs.

    """

    print("Running for you in BATCH mode ... ")


    """
    Check input --bed BED files.

    """
    bed_path = False
    bed_list = []

    if len(args.bed_files) == 1:
        if os.path.isdir(args.bed_files[0]):
            bed_path = args.bed_files[0]
            bed_files = benchlib.dir_get_files(bed_path, file_ending="bed")
            assert bed_files, "no BED files (.bed file extension expected) found in given --bed %s folder" %(bed_path)
            for bed_file in bed_files:
                bed_list.append(bed_file)
        elif os.path.isfile(args.bed_files[0]):
            bed_list.append(args.bed_files[0])
        else:
            assert False, "given --bed argument %s is not a file or a folder" %(args.bed_files[0])
    elif len(args.bed_files) > 1:
        for bed_file in args.bed_files:
            if os.path.isfile(bed_file):
                bed_list.append(bed_file)
            else:
                assert False, "given --bed argument %s is not a file. > 1 --bed argument was provided, so each element is expected to be a file" %(bed_file)
        # Demand RBP list to be provided.
        assert args.list_rbp_ids, "single BED files provided via --bed, but --rbp-list is not set. Please provide RBP IDs for each BED file in matching order"
    else:
        assert False, "no --bed arguments supplied"
    assert bed_list, "bed_list empty"

    # Is MEME >= v5 installed?
    if not args.meme_disable_check:
        assert benchlib.is_tool("meme"), "meme not in PATH"
        check, meme_version = benchlib.check_tool_version("meme -version", "5.0")
        assert check, "RBPBench requires meme version >= 5.0 (installed version: %s)" %(meme_version)

    # Check if MEME version is >= 5.5.4 (need to add fimo --no-pgc option to produce same results!).
    fimo_params = "--norc --verbosity 1 --skip-matched-sequence --text"
    if not args.meme_disable_check:
        check, meme_version = benchlib.check_tool_version("meme -version", "5.5.4")
        if check:
            fimo_params = "--norc --verbosity 1 --skip-matched-sequence --text --no-pgc"
    if args.meme_no_pgc:
        fimo_params = "--norc --verbosity 1 --skip-matched-sequence --text --no-pgc"

    # --report / --gtf checks.
    if args.tr_list:
        assert args.in_gtf, "--tr-list set, but --gtf not set. Please provide --gtf file"
    assert benchlib.boundary_check(args.gtf_feat_min_overlap, 1E-9, 1.0), "set --gtf-feat-min-overlap expected to be >= 1E-9 and <= 1.0"
    if args.in_gtf:
        assert os.path.exists(args.in_gtf), "set --gtf file not found"
        assert args.report, "--gtf set but not --report. --report needed to generate region annotation plots"
    assert benchlib.boundary_check(args.kmer_size, 1, 6), "set --kmer-size expected to be >= 1 and <= 6"

    # Regex check.
    regex = False

    if args.regex:
        assert benchlib.is_valid_regex(args.regex), "given --regex \"%s\" is not a valid regular expression. Please provide valid expression" % (args.regex)

        # Remove , ; from given regex, to avoid motif_id format conflicts.
        regex = benchlib.remove_special_chars_from_str(args.regex,
                                                       reg_ex="[,;]")
        
        assert regex, "empty string after removing special chars from --regex. Please provide a valid regex with DNA letters"


    """
    Check other list inputs and store.

    """

    rbp_ids_list = []
    if args.list_rbp_ids:
        assert not bed_path, "--rbp-list expects BED files provided in same order with --bed, not as BED folder"
        assert len(args.list_rbp_ids) == len(bed_list), "number of --rbp-list arguments != number of --bed arguments"
        for rbp_id in args.list_rbp_ids:
            # new_rbp_id = benchlib.remove_special_chars_from_str(rbp_id)
            # assert new_rbp_id, "empty string after removing special chars from --rbp-list argument %s. Please provide valid RBP ID (i.e., RBP ID from database)" %(rbp_id)
            rbp_ids_list.append(rbp_id)

    data_ids_list = []
    if args.list_data_ids:
        assert not bed_path, "--data-list expects BED files provided in same order with --bed, not as BED folder"
        assert len(args.list_data_ids) == len(bed_list), "number of --data-list arguments != number of --bed arguments"
        for data_id in args.list_data_ids:
            new_data_id = benchlib.remove_special_chars_from_str(data_id)
            assert new_data_id, "empty string after removing special chars from --data-list argument %s. Please provide alphanumeric string (- or _ are okay as well)" %(data_id)
            data_ids_list.append(new_data_id)
    else:
        args.data_id = benchlib.remove_special_chars_from_str(args.data_id)
        assert args.data_id, "empty string after removing special chars from --data-id. Please provide alphanumeric string for data ID (- or _ are okay as well)"

    method_ids_list = []
    if args.list_method_ids:
        assert not bed_path, "--method-list expects BED files provided in same order with --bed, not as BED folder"
        assert len(args.list_method_ids) == len(bed_list), "number of --method-list arguments != number of --bed arguments"
        for method_id in args.list_method_ids:
            new_method_id = benchlib.remove_special_chars_from_str(method_id)
            assert new_method_id, "empty string after removing special chars from --method-list argument %s. Please provide alphanumeric string (- or _ are okay as well)" %(method_id)
            method_ids_list.append(new_method_id)
    else:
        args.method_id = benchlib.remove_special_chars_from_str(args.method_id)
        assert args.method_id, "empty string after removing special chars from --method-id. Please provide alphanumeric string for method ID (- or _ are okay as well)"

    if not bed_path and len(bed_list) == 1:
        # Check if file is a table file and not a BED file.
        if benchlib.check_table_file(bed_list[0]):
            print("Table file provided via --bed ... ")
            print("Read in table file infos (including RBP, method, data IDs + BED file paths) ... ")
            dataset_list = benchlib.read_in_table_file(bed_list[0])
            rbp_ids_list = []
            method_ids_list = []
            data_ids_list = []
            bed_list = []
            for dataset in dataset_list:
                rbp_ids_list.append(dataset[0])
                method_ids_list.append(dataset[1])
                data_ids_list.append(dataset[2])
                bed_list.append(dataset[3])

    """
    Extracting RBP IDs from BED file names.

    """

    if not rbp_ids_list:
        print("No --rbp-list provided. Extracting RBP IDs from --bed file names ... ")

        for bed_file in bed_list:
            rbp_id = False
            if re.search(".+\.bed", bed_file):
                m = re.search("(.+)\.bed", bed_file)
                fn = m.group(1)
                fnp = fn.split("_")
                rbp_id = fnp[0]
            else:
                assert False, "BED file %s with invalid ending (.bed expected)" %(bed_file)
            assert rbp_id, "no RBP ID extracted from BED file name %s" %(bed_file)
            rbp_ids_list.append(rbp_id)

    assert rbp_ids_list, "no RBP IDs list after pre-processing"
    assert len(rbp_ids_list) == len(bed_list), "number of RBP IDs != number of --bed files"

    """
    Library path.
    """
    benchlib_path = os.path.dirname(benchlib.__file__)
    db_path = benchlib_path + "/content"


    """
    FIMO nt frequencies.
    """
    fimo_freqs_file = db_path + "/fimo_nt_freqs.txt" # CONDA2SET
    if args.fimo_nt_freqs:
        fimo_freqs_file = args.fimo_nt_freqs
    assert os.path.exists(fimo_freqs_file), "set FIMO nucleotide frequencies file \"%s\" not found" % (fimo_freqs_file)

    """
    Motif database.
    """
    seq_motifs_db_file, str_motifs_db_file, rbp2ids_file, motif_db_str = specify_motif_db(args.motif_db, 
                                                                                          db_path=db_path)

    # Custom motif database: folder given.
    if args.custom_db:
        assert not args.custom_db_meme_xml, "--custom-db folder set incompatible with --custom-db-meme-xml. Provide custom motif database either via folder (--custom-db) or as single files"
        assert not args.custom_db_cm, "--custom-db folder set incompatible with --custom-db-cm. Provide custom motif database either via folder (--custom-db) or as single files"
        assert not args.custom_db_info, "--custom-db folder set incompatible with --custom-db-info. Provide custom motif database either via folder (--custom-db) or as single files"
        seq_motifs_db_file, str_motifs_db_file, rbp2ids_file = specify_custom_motif_db(args.custom_db)
        motif_db_str = args.custom_db_id
    # Custom motif database: single files given.
    if args.custom_db_meme_xml or args.custom_db_cm or args.custom_db_info:
        motif_db_str = args.custom_db_id
        assert not args.custom_db, "single custom motif database files provided not compatible with --custom-db. Provide custom motif database either via folder (--custom-db) or as single files"
        assert args.custom_db_info, "--custom-db-info needed to define custom motif database"
        rbp2ids_file = args.custom_db_info
        assert args.custom_db_meme_xml or args.custom_db_cm, "--custom-db-meme-xml and/or --custom-db-cm needed to define custom motif database"
        if args.custom_db_meme_xml:
            seq_motifs_db_file = args.custom_db_meme_xml
        else:
            seq_motifs_db_file = ""  # setting to empty string results in os.path.exists -> False.
        if args.custom_db_cm:
            str_motifs_db_file = args.custom_db_cm
        else:
            str_motifs_db_file = ""

    args.motif_db_str = motif_db_str

    """
    Get ID mappings

    name2ids_dic:
    RBP name -> motif IDs mapping
    id2type_dic:
    motif ID -> motif type (cm, meme_xml)
    id2org_dic (ignore for now):
    motif ID -> organism ID (so far only "human")

    """
    name2ids_dic, id2type_dic = benchlib.get_rbp_id_mappings(rbp2ids_file)
    # Motif ID -> RBP name (== RBP ID) mapping.
    id2name_dic = {}
    for rbp_id in name2ids_dic:
        for motif_id in name2ids_dic[rbp_id]:
            id2name_dic[motif_id] = rbp_id


    """
    Get MEME XML database motif blocks dictionary.

    """
    seq_motif_blocks_dic = {}
    if os.path.exists(seq_motifs_db_file):
        seq_motif_blocks_dic = benchlib.read_in_xml_motifs(seq_motifs_db_file,
                                                           empty_check=True)
    for motif_id in seq_motif_blocks_dic:
        assert motif_id in id2name_dic, "MEME XML motif ID %s not found in prior mapping. Please contact developers!" %(motif_id)

    """
    Get covariance model database motif blocks dictionary.

    """
    str_motif_blocks_dic = {}
    if os.path.exists(str_motifs_db_file):
        str_motif_blocks_dic = benchlib.read_in_cm_blocks(str_motifs_db_file,
                                                          empty_check=True)
    for motif_id in str_motif_blocks_dic:
        assert motif_id in id2name_dic, "Covariance model accession ID %s not found in prior mapping. Please contact developers!" %(motif_id)

    """
    Check if RBP IDs are in database.

    """
    for rbp_id in rbp_ids_list:
        assert rbp_id in name2ids_dic, "given RBP ID \"%s\" not in motif database. Please provide valid RBP IDs (either via --rbp-list or as part of BED names if --bed folder is provided)" %(rbp_id)

    for rbp_id in rbp_ids_list:
        for motif_id in name2ids_dic[rbp_id]:
            found = 0
            if motif_id in seq_motif_blocks_dic:
                found += 1
            if motif_id in str_motif_blocks_dic:
                found += 1
            assert found, "no motifs loaded for RBP ID \"%s\". Please provide the respective motifs file" %(rbp_id)

    """
    Run ID definition.

    Use internal_id instead (to connect RBP and motif stats tables)
    import os
    import base64
    base64.urlsafe_b64encode(os.urandom(6)).decode()
    https://stackoverflow.com/questions/13484726/safe-enough-8-character-short-unique-random-string
    
    """

    run_id = "run_id"
    if args.run_id:
        run_id = benchlib.remove_special_chars_from_str(args.run_id)
        assert run_id, "empty string after removing special chars from --run-id. Please provide alphanumeric string for run ID (- or _ are okay as well)"
    # else:
    #     random_id = uuid.uuid4()
    #     run_id = str(random_id)
    print("Run ID:", run_id)

    """
    Output folders + files.

    """
    if not os.path.exists(args.out_folder):
        os.makedirs(args.out_folder)

    filtered_sites_bed = args.out_folder + "/in_sites.filtered.bed"
    filtered_sites_fa = args.out_folder + "/in_sites.filtered.fa"
    seq_motifs_xml = args.out_folder + "/seq_motifs.xml"
    str_motifs_cm = args.out_folder + "/str_motifs.cm"
    fimo_res_tsv = args.out_folder + "/fimo_results.tsv"
    cmsearch_res_txt = args.out_folder + "/cmsearch_results.txt"

    rbp_stats_out = args.out_folder + "/rbp_hit_stats.tsv"
    motif_stats_out = args.out_folder + "/motif_hit_stats.tsv"
    # con_res_out_tsv = args.out_folder + "/contingency_table_results.tsv"
    settings_file = args.out_folder + "/settings.find_motifs.out"

    # Output unique motif hits.
    motif_hits_bed_out = args.out_folder + "/motif_hits.rbpbench_batch.bed"

    # Temp files.
    # random_id = uuid.uuid1()
    # tmp_out_bed = args.out_folder + "/" + str(random_id) + ".filtered_in.bed"
    out_tmp_bed = args.out_folder + "/rbp_motif_hit_regions.tmp.bed"
    cmstat_tmp_out = args.out_folder + "/cmstat_out.tmp.txt"

    # Delete if existing folder.
    if os.path.exists(fimo_res_tsv):
        os.remove(fimo_res_tsv)
    if os.path.exists(cmsearch_res_txt):
        os.remove(cmsearch_res_txt)

    """
    Get chromosome IDs from --genome.
    """
    print("Get --genome FASTA headers ... ")
    chr_ids_dic = benchlib.get_fasta_headers(args.in_genome)


    """
    Guess chromosome ID style.

    chr_style:
        1: chr1, chr2, ..., chrX, chrM
        2: 1, 2, ... , X, MT

    """
    chr_style = 0  # no changes to chromosome IDs in GTF files.
    
    if "1" in chr_ids_dic:
        assert "chr1" not in chr_ids_dic, "inconsistent chromosome IDs in --genome FASTA file (both chr1 and 1)"
    if "chr1" in chr_ids_dic:
        assert "1" not in chr_ids_dic, "inconsistent chromosome IDs in --genome FASTA file (both chr1 and 1)"
    if "chr1" in chr_ids_dic:
        chr_style = 1
    if "1" in chr_ids_dic:
        chr_style = 2


    """
    Region extensions.

    """

    ext_parts = args.ext_up_down.split(",")
    c_ext_parts = len(ext_parts)
    ext_up = 0
    ext_down = 0
    if c_ext_parts == 1:
        ext_up = int(ext_parts[0])
        ext_down = int(ext_parts[0])
    elif c_ext_parts == 2:
        ext_up = int(ext_parts[0])
        ext_down = int(ext_parts[1]) 
    else:
        assert False, "invalid --ext argument provided (correct format: --ext 10 OR --ext 20,10)"


    """
    If --gtf file, read in GTF info.

    """
    intron_exon_out_bed = args.out_folder + "/intron_exon_regions.tmp.bed"

    tr_ids_dic = {}  # Store (most prominent / representative) transcript ID -> gene ID.
    all_sets_occ_tr_ids_dic = {}  # Store only transcript IDs which are occupied in any dataset.

    # For gene/representative transcript region occupancy PCA plot.
    id2occ_list_dic = {}  # internal ID -> transcript/gene occupancy labels list.
    occ_mode = 1  # 1: binary occupancy, 2: continuous value occupancy.
    occ_all_tr = False  # Store all transcript occupancy values for PCA plot.
    id2occ_tr_ids_dic = {}  # internal ID -> transcript ID -> occupancy value.

    if args.in_gtf:
    
        # Get gene infos.
        print("Read in gene features from --gtf ... ")
        tr2gid_dic = {}
        tr_types_dic = {}  # Store transcript biotypes in GTF file.
        gid2gio_dic = benchlib.gtf_read_in_gene_infos(args.in_gtf,
                                                        tr2gid_dic=tr2gid_dic,
                                                        tr_types_dic=tr_types_dic,
                                                        check_chr_ids_dic=chr_ids_dic,
                                                        chr_style=chr_style,
                                                        empty_check=False)

        assert gid2gio_dic, "no gene infos read in from --gtf. Please provide a valid/compatible GTF file (e.g. from Ensembl or ENCODE)"
        c_gene_infos = len(gid2gio_dic)
        print("# gene features read in from --gtf:", c_gene_infos)

        # If --tr-list given.
        if args.tr_list:
            tr_ids_dic = benchlib.read_ids_into_dic(args.tr_list,
                                                    check_dic=False)
            assert tr_ids_dic, "no IDs read in from provided --tr-list file. Please provide a valid IDs file (one ID per row)"
            for tr_id in tr_ids_dic:
                assert tr_id in tr2gid_dic, "transcript ID \"%s\" from provided --tr-list file does not appear in --gtf file. Please provide compatible files" %(tr_id)
                tr_ids_dic[tr_id] = tr2gid_dic[tr_id]
            print("# of transcript IDs (read in from --tr-list): ", len(tr_ids_dic))
        else:
            # Get most prominent transcripts from gene infos.
            tr_ids_dic = benchlib.select_mpts_from_gene_infos(gid2gio_dic,
                                    basic_tag=False,  # do not be strict (only_tsl=False too).
                                    ensembl_canonical_tag=False,
                                    prior_basic_tag=True,  # Prioritize basic tag transcript.
                                    only_tsl=False)
            assert tr_ids_dic, "most prominent transcript selection from gene infos failed. Please contact developers"
            print("# of transcript IDs (most prominent transcripts): ", len(tr_ids_dic))

        # Check exon order (return True if minus strand exon 1 is most downstream, not most upstream, which is the correct way).
        print("Check minus-strand exon order in --gtf ... ")
        correct_min_ex_order = benchlib.gtf_check_exon_order(args.in_gtf)
        if correct_min_ex_order:
            print("Correct order encountered ... ")
        else:
            print("Reverse order encountered ... ")
        # Get transcript infos.
        print("Read in transcript infos from --gtf ... ")
        tid2tio_dic = benchlib.gtf_read_in_transcript_infos(args.in_gtf, 
                                                            tr_ids_dic=tr_ids_dic,
                                                            correct_min_ex_order=correct_min_ex_order,
                                                            chr_style=chr_style,
                                                            empty_check=False)

        assert tid2tio_dic, "no transcript infos read in from --gtf. Please provide a valid/compatible GTF file (e.g. from Ensembl or ENCODE)"

        # (in)sanity checks.
        for tr_id in tr_ids_dic:
            assert tr_id in tid2tio_dic, "transcript ID %s not in tid2tio_dic"
        for tr_id in tid2tio_dic:
            assert tr_id in tr_ids_dic, "transcript ID %s not in tr_ids_dic"

        c_tr_infos = len(tid2tio_dic)
        print("# transcript features read in from --gtf:", c_tr_infos)

        # Extract exon + intron regions of selected transcripts from transcript infos.
        print("Output intron annotations to BED ... ")
        benchlib.output_transcript_info_intron_exon_to_bed(tid2tio_dic, intron_exon_out_bed,
                                            output_mode=3,  # only introns.
                                            report_counts=True,
                                            add_tr_id=True,
                                            empty_check=False)

        # Custom transcript biotypes for upset plot.
        custom_annot_dic = None
        if args.tr_types_list:
            for tr_type in args.tr_types_list:
                assert tr_type in tr_types_dic, "given transcript biotype ID \"%s\" not found in GTF file"
                custom_annot_dic[tr_type] = tr_type

        # Append detailed exon annotations (CDS, UTR, transcript biotypes) to intron annotations.
        print("Output exon annotations to BED ... ")
        benchlib.output_exon_annotations(tid2tio_dic, intron_exon_out_bed,
                                            custom_annot_dic=custom_annot_dic,
                                            append=True)


    """
    Output files + write headers.

    """
    # RBP batch stats file.
    OUTRBPSTATS = open(rbp_stats_out,"w")
    rbp_stats_header = "data_id\tmethod_id\trun_id\tmotif_db\trbp_id\tc_regions\tmean_reg_len\tmedian_reg_len\tmin_reg_len\tmax_reg_len\t"
    rbp_stats_header += "called_reg_size\teffective_reg_size\tc_reg_with_hits\tperc_reg_with_hits\t"
    rbp_stats_header += "c_motif_hits\tc_uniq_motif_hits\tc_uniq_motif_nts\tperc_uniq_motif_nts_cal_reg\tperc_uniq_motif_nts_eff_reg\tuniq_motif_hits_cal_1000nt\t"
    rbp_stats_header += "uniq_motif_hits_eff_1000nt\twc_pval\tseq_motif_ids\tseq_motif_hits\tstr_motif_ids\tstr_motif_hits\tinternal_id\n"
    OUTRBPSTATS.write(rbp_stats_header)

    # Motif batch stats file.
    OUTMTFSTATS = open(motif_stats_out,"w")
    motif_stats_header = "data_id\tmethod_id\trun_id\tmotif_db\tregion_id\trbp_id\tmotif_id\tchr_id\tgen_s\tgen_e\tstrand\tregion_s\tregion_e\tregion_len\t"
    motif_stats_header += "uniq_count\tfimo_score\tfimo_pval\tcms_score\tcms_eval\tinternal_id\n"
    OUTMTFSTATS.write(motif_stats_header)

    args.internal_id = []

    # Unique motif regions BED.
    motif_reg_dic = {}

    # Unstranded option.
    if args.unstranded:
        print("WARNING: --unstranded enabled. Using both strands for each --in BED region ... ")
        if ext_up != ext_down:
            print("asymmetric --ext and --unstranded set. Extend plus strand and use corresponding minus strand ... ")

    print("Run motif search for each dataset ... ")

    """
    Hypothesis test modes.

    """
    # Wilcoxon rank-sum test / Mann Whitney U test mode.
    wrs_alt_hypo = "greater"
    if args.wrs_mode == 1:
        wrs_alt_hypo = "greater"
        # print("Check if motif-containing regions have significantly higher scores ... ")
    elif args.wrs_mode == 2:
        wrs_alt_hypo = "less"
        # print("Check if motif-containing regions have significantly lower scores ... ")
    else:
        assert False, "Invalid Wilcoxon rank-sum (Mann Whitney U) test mode: %i" %(args.wrs_mode)

    # Fisher exact test mode.
    fisher_alt_hypo = "greater"
    if args.fisher_mode == 1:
        fisher_alt_hypo = "greater"
        # print("Fisher mode = 1, reporting significantly overrepresented co-occurrences ... ")
    elif args.fisher_mode == 2:
        fisher_alt_hypo = "two-sided"
        # print("Fisher mode = 2, reporting significantly over- AND underrepresented co-occurrences ... ")
    elif args.fisher_mode == 3:
        fisher_alt_hypo = "less"
        # print("Fisher mode = 3, reporting significantly underrepresented co-occurrences ... ")
    else:
        assert False, "Invalid Fisher mode: %i" %(args.fisher_mode)

    """
    Run motif search for each BED / RBP ID combination.

    """
    call_dic = {}
    annot_dic = {}  # Store all occurring annotations as keys.
    id2c_regions_dic = {}  # Internal ID to number of sequences / regions in input BED file + numbers with hits, so format: [c_all, c_with_hits]
    id2reg_annot_dic = {}  # Store internal ID to region annotation dictionary (all sites, with and without hits).
    id2hit_reg_annot_dic = {}  # Store internal ID to region annotation dictionary (only sites with hits).
    id2infos_dic = {}  # Store internal ID to list containing RBP ID, data ID, method ID, database ID, BED file path.
    id2regex_stats_dic = {}  # Store internal ID to regex stats dictionary.
    # id2kmer_dic = {}  # Store internal ID to k-mer dictionary.
    c_all_hits = 0  # Sum up hits for all RBPs.
    kmer_freqs_ll = []  # For PCA plot.
    dataset_ids_list = []  # For PCA plot.
    add_motif_db_info = False  # Whether to add the motif database string to the dataset IDs in the plots.
    # dataset_idx = 0  # For PCA plot.
    seq_len_stats_ll = []  # For sequence length stats in --report.

    for idx, bed_file in enumerate(bed_list):

        rbp_id = rbp_ids_list[idx]
        bed_file_path = bed_file
        if bed_path:
            bed_file_path = bed_path + "/" + bed_file

        data_id = args.data_id
        if data_ids_list:
            data_id = data_ids_list[idx]
        method_id = args.method_id
        if method_ids_list:
            method_id = method_ids_list[idx]

        # Motif IDs for search.
        loaded_motif_ids_dic = {}
        for motif_id in name2ids_dic[rbp_id]:
            loaded_motif_ids_dic[motif_id] = motif_db_str

        # Store motif IDs for search.
        # search_rbps_dic = {}
        seq_rbps_dic = {}
        str_rbps_dic = {}
        motif_id2idx_dic = {} # motif ID -> list index.

        print("")
        print("RBP ID:        ", rbp_id)
        print("BED file:      ", bed_file)
        print("# of motif IDs:", len(loaded_motif_ids_dic))
        print("Motif IDs:     ", loaded_motif_ids_dic)
        internal_id = base64.urlsafe_b64encode(os.urandom(6)).decode()
        args.internal_id.append(internal_id)
        print("Data ID:       ", data_id)
        print("Method ID:     ", method_id)
        print("Internal ID:   ", internal_id)

        id2infos_dic[internal_id] = [rbp_id, data_id, method_id, motif_db_str, bed_file_path]

        rbp = benchlib.RBP(rbp_id, internal_id)

        for motif_id in name2ids_dic[rbp_id]:
            if id2type_dic[motif_id] == "meme_xml":
                rbp.seq_motif_ids.append(motif_id)
                motif_id2idx_dic[motif_id] = len(rbp.seq_motif_ids) - 1
                rbp.seq_motif_hits.append(0)
                seq_rbps_dic[rbp_id] = 1
            else:
                rbp.str_motif_ids.append(motif_id)
                motif_id2idx_dic[motif_id] = len(rbp.str_motif_ids) - 1
                rbp.str_motif_hits.append(0)
                str_rbps_dic[rbp_id] = 1

        """
        Filter / extend --in genomic regions BED file.

        """
        print("Preprocess --in sites ... ")
        reg2sc_dic = {}
        reg_stats_dic = benchlib.bed_filter_extend_bed(bed_file_path, filtered_sites_bed,
                                            ext_up=ext_up,
                                            ext_down=ext_down,
                                            remove_dupl=True,
                                            reg2sc_dic=reg2sc_dic,
                                            score_col=args.bed_score_col,
                                            chr_ids_dic=chr_ids_dic,
                                            use_region_ids=True,
                                            unstranded=args.unstranded)

        print("# --in regions pre-filtering:  ", reg_stats_dic["c_in"])
        print("# --in regions post-filtering: ", reg_stats_dic["c_out"])
        print("# regions with invalid chr_id: ", reg_stats_dic["c_chr_filter"])
        print("# duplicated regions removed:  ", reg_stats_dic["c_dupl_filter"])
        assert reg_stats_dic["c_out"], "no --in BED sites remain after chromosome ID filtering"

        """
        Calculate effective size of genomic regions.
        
        """
        print("Calculate effective genomic region size ... ")
        eff_reg_size = benchlib.get_uniq_gen_size(filtered_sites_bed)


        print("Called region length sum:      ", reg_stats_dic["reg_len_sum"])
        print("Effective region length sum:   ", eff_reg_size)

        """
        Get genomic region sequences from --genome.

        """
        print("Extract sequences from --genome ... ")
        benchlib.bed_extract_sequences_from_fasta(filtered_sites_bed, 
                                                  args.in_genome, filtered_sites_fa,
                                                  print_warnings=True)

        """
        Get FASTA sequences and sequence lengths.
        """

        out_seqs_dic = benchlib.read_fasta_into_dic(filtered_sites_fa,
                                                    dna=True,
                                                    all_uc=True,
                                                    id_check=True,
                                                    empty_check=False,
                                                    skip_n_seqs=False)

        assert out_seqs_dic, "no sequences extracted from FASTA file for --in BED sites. Make sure to use compatible FASTA/BED files!"

        # Effective number of regions used for motif search.
        c_regions = len(out_seqs_dic)
        if args.unstranded and not args.unstranded_ct:
            # Check if sequences are even.
            assert not len(out_seqs_dic) % 2, "# of --in regions should be an even number since --unstranded is set. Please contact developers"
            c_regions = len(out_seqs_dic) // 2

        # Called region size.
        called_reg_size = 0
        len_list = []
        for seq_id in out_seqs_dic:
            seq_len = len(out_seqs_dic[seq_id])
            called_reg_size += seq_len
            len_list.append(seq_len)

        # Length statistics.
        reg_len_median = statistics.median(len_list)
        reg_len_mean = statistics.mean(len_list)
        reg_len_mean = round(reg_len_mean, 2)
        reg_len_min = min(len_list)
        reg_len_max = max(len_list)

        """
        ====================================
        RUN SEQUENCE MOTIF SEARCH WITH FIMO.
        ====================================

        """
        fimo_hits_list = []

        if seq_rbps_dic:

            """
            Print motifs to file.

            """

            print("Output motifs to XML ... ")
            out_str, c_added_motifs = benchlib.blocks_to_xml_string(seq_motif_blocks_dic, loaded_motif_ids_dic)

            benchlib.output_string_to_file(out_str, seq_motifs_xml)

            """
            Run FIMO on sequences + motifs.

            """

            print("Run FIMO ... ")
            benchlib.run_fast_fimo(filtered_sites_fa, seq_motifs_xml, fimo_res_tsv,
                        pval_thr=args.fimo_pval,
                        nt_freqs_file=fimo_freqs_file,
                        call_dic=call_dic,
                        params=fimo_params,
                        error_check=False)

            """
            Read in FIMO hits.

            """

            assert os.path.exists(fimo_res_tsv), "FIMO output file fimo.tsv %s does not exist! There must have been an error while running FIMO (invalid xml file provided?)" %(fimo_res_tsv)

            print("Read in FIMO results ... ")
            fimo_hits_list = benchlib.read_in_fimo_results(fimo_res_tsv)

            c_fimo_hits = len(fimo_hits_list)
            print("# of FIMO motif hits:", c_fimo_hits)


        """
        =========================================
        RUN STRUCTURE MOTIF SEARCH WITH CMSEARCH.
        =========================================

        """
        cmsearch_hits_list = []

        if str_rbps_dic:
            
            print("Output covariance models to .cm ... ")
            benchlib.output_cm_blocks_to_file(str_motif_blocks_dic, loaded_motif_ids_dic, str_motifs_cm)

            # Run cmsearch.
            print("Run cmsearch ... ")
            benchlib.run_cmsearch(filtered_sites_fa, str_motifs_cm, cmsearch_res_txt,
                                  error_check=False,
                                  call_dic=call_dic,
                                  params="-g --tformat fasta --toponly --incT 1 -T 1 --default")
            # Read in hits.
            print("Read in cmsearch results ... ")
            cmsearch_hits_list, c_cms_hits = benchlib.read_in_cmsearch_results(cmsearch_res_txt)

            print("# of cmsearch motif hits:", c_cms_hits)

        """
        ==========================
        ADDITIONAL --regex SEARCH.
        ==========================

        regions_with_regex_dic:
            region -> regex_c_region

        unique_regex_dic:
            regex_region -> c_regex_region
        """

        regions_with_regex_dic = {}
        unique_regex_dic = {}
        # Dictionaries needed for Fisher test.
        region_rbp_binds_dic = {}
        # RBP idx: 0, regex idx: 1
        rid2rbpidx2hcp_dic = {}  # region_id -> rbp_idx -> motif hit center position(s)

        if args.regex:

            step_size_one = False
            if args.regex_search_mode == 1:
                step_size_one = False
            elif args.regex_search_mode == 2:
                step_size_one = True
            else:
                assert False, "invalid --regex-search-mode %i set" %(args.regex_search_mode)

            print("Run search for --regex \"%s\" ... " %(regex))
            regex_hits_list = benchlib.get_regex_hits(regex, regex, out_seqs_dic,
                                                      step_size_one=step_size_one,
                                                      use_motif_regex_id=True)

            # Store regions with regex motif hits.
            for rh in regex_hits_list:

                if rh.seq_name in regions_with_regex_dic:
                    regions_with_regex_dic[rh.seq_name] += 1
                else:
                    regions_with_regex_dic[rh.seq_name] = 1 

                rh_str = repr(rh) # genomic regex region string.

                if rh_str in unique_regex_dic:
                    unique_regex_dic[rh_str] += 1
                else:
                    unique_regex_dic[rh_str] = 1

            # Init dictionaries for Fisher test.
            for reg_id in out_seqs_dic:
                assert reg_id in reg2sc_dic, "region ID \"%s\" from out_seqs_dic not found in reg2sc_dic" %(reg_id)
                if args.unstranded and not args.unstranded_ct:
                    core_id = benchlib.reg_get_core_id(reg_id)  # If --unstranded (and not --unstranded-ct), get core ID to count region as one.
                    if core_id not in region_rbp_binds_dic:
                        region_rbp_binds_dic[core_id] = [False, False]
                        rid2rbpidx2hcp_dic[core_id] = {}
                else:
                    region_rbp_binds_dic[reg_id] = [False, False]
                    rid2rbpidx2hcp_dic[reg_id] = {}

            # Populate dictionaties fimo + cmsearch + regex hits.
            rbp_idx = 0

            for fh in fimo_hits_list:

                region_id = fh.seq_name

                # Center position of motif hit.
                motif_hit_s = fh.seq_s - 1
                motif_hit_e = fh.seq_e
                center_pos = benchlib.get_center_position(motif_hit_s, motif_hit_e)

                if args.unstranded and not args.unstranded_ct:
                    core_id = benchlib.reg_get_core_id(region_id)
                    region_rbp_binds_dic[core_id][rbp_idx] = True

                    if rbp_idx not in rid2rbpidx2hcp_dic[core_id]:
                        rid2rbpidx2hcp_dic[core_id][rbp_idx] = [center_pos]
                    else:
                        rid2rbpidx2hcp_dic[core_id][rbp_idx].append(center_pos)
                else:
                    region_rbp_binds_dic[region_id][rbp_idx] = True

                    if rbp_idx not in rid2rbpidx2hcp_dic[region_id]:
                        rid2rbpidx2hcp_dic[region_id][rbp_idx] = [center_pos]
                    else:
                        rid2rbpidx2hcp_dic[region_id][rbp_idx].append(center_pos)

            for cmsh in cmsearch_hits_list:

                region_id = cmsh.seq_name

                # Center position of motif hit.
                motif_hit_s = cmsh.seq_s - 1
                motif_hit_e = cmsh.seq_e
                center_pos = benchlib.get_center_position(motif_hit_s, motif_hit_e)

                if args.unstranded and not args.unstranded_ct:
                    core_id = benchlib.reg_get_core_id(region_id)
                    region_rbp_binds_dic[core_id][rbp_idx] = True

                    if rbp_idx not in rid2rbpidx2hcp_dic[core_id]:
                        rid2rbpidx2hcp_dic[core_id][rbp_idx] = [center_pos]
                    else:
                        rid2rbpidx2hcp_dic[core_id][rbp_idx].append(center_pos)
                else:
                    region_rbp_binds_dic[region_id][rbp_idx] = True

                    if rbp_idx not in rid2rbpidx2hcp_dic[region_id]:
                        rid2rbpidx2hcp_dic[region_id][rbp_idx] = [center_pos]
                    else:
                        rid2rbpidx2hcp_dic[region_id][rbp_idx].append(center_pos)

            rbp_idx = 1
            for rh in regex_hits_list:

                region_id = rh.seq_name

                # Center position of motif hit.
                motif_hit_s = rh.seq_s - 1
                motif_hit_e = rh.seq_e
                center_pos = benchlib.get_center_position(motif_hit_s, motif_hit_e)

                if args.unstranded and not args.unstranded_ct:
                    core_id = benchlib.reg_get_core_id(region_id)
                    region_rbp_binds_dic[core_id][rbp_idx] = True

                    if rbp_idx not in rid2rbpidx2hcp_dic[core_id]:
                        rid2rbpidx2hcp_dic[core_id][rbp_idx] = [center_pos]
                    else:
                        rid2rbpidx2hcp_dic[core_id][rbp_idx].append(center_pos)
                else:
                    region_rbp_binds_dic[region_id][rbp_idx] = True

                    if rbp_idx not in rid2rbpidx2hcp_dic[region_id]:
                        rid2rbpidx2hcp_dic[region_id][rbp_idx] = [center_pos]
                    else:
                        rid2rbpidx2hcp_dic[region_id][rbp_idx].append(center_pos)


        """
        Store regions with motif hits (and hit counts).
        This tells us, how many input regions have motif hits (+ how many hits).

        Also store the unique motif hit regions (and hit counts).

        regions_with_motifs_dic:
            region -> motif_c_region

        unique_motifs_dic:
            motif_region -> c_motif_region

        """

        regions_with_motifs_dic = {}
        unique_motifs_dic = {}

        # Store regions with sequence motifs.
        for fh in fimo_hits_list:

            if fh.seq_name in regions_with_motifs_dic:
                regions_with_motifs_dic[fh.seq_name] += 1
            else:
                regions_with_motifs_dic[fh.seq_name] = 1 

            fh_str = repr(fh) # genomic motif region string.

            if fh_str in unique_motifs_dic:
                unique_motifs_dic[fh_str] += 1
            else:
                unique_motifs_dic[fh_str] = 1

        # Store regions with structure motifs.
        for cmsh in cmsearch_hits_list:

            if cmsh.seq_name in regions_with_motifs_dic:
                regions_with_motifs_dic[cmsh.seq_name] += 1
            else:
                regions_with_motifs_dic[cmsh.seq_name] = 1 

            cmsh_str = repr(cmsh) # genomic motif region string.

            if cmsh_str in unique_motifs_dic:
                unique_motifs_dic[cmsh_str] += 1
            else:
                unique_motifs_dic[cmsh_str] = 1

        """
        Store infos in RBP object.

        """
        # number of --in regions with RBP motif hits.
        c_hit_reg = len(regions_with_motifs_dic)
        if args.unstranded and not args.unstranded_ct:
            c_hit_reg = 0
            seen_ids_dic = {}
            for seq_id in regions_with_motifs_dic:
                core_id = benchlib.reg_get_core_id(seq_id)
                if core_id not in seen_ids_dic:
                    c_hit_reg += 1
                    seen_ids_dic[core_id] = 1

        # number of motif hits on --in regions in total.
        c_motif_hits = 0
        for reg_id in regions_with_motifs_dic:
            c_motif_hits += regions_with_motifs_dic[reg_id]
        
        rbp.c_hit_reg = c_hit_reg
        rbp.c_motif_hits = c_motif_hits
        # % hit regions over all regions (i.e. how many input regions contain >= 1 RBP motif).
        rbp.perc_hit_reg = (rbp.c_hit_reg / c_regions) * 100

        # Store number of regions for internal ID.
        id2c_regions_dic[internal_id] = [c_regions, c_hit_reg]

        """
        Get unique motif hits.

        """
        rbp.c_uniq_motif_hits = len(unique_motifs_dic)
        # Store individual motif unique hits.
        for motif_str_repr in unique_motifs_dic:
            motif_id = benchlib.get_motif_id_from_str_repr(motif_str_repr)
            idx = motif_id2idx_dic[motif_id]
            if id2type_dic[motif_id] == "meme_xml":
                rbp.seq_motif_hits[idx] += 1
            else:
                rbp.str_motif_hits[idx] += 1

        """
        Number of motif nucleotides over called + effective region size.

        """

        print("Calculate effective motif region sizes ... ")

        # Output unique motif hit regions (sequence or structure) to BED.
        eff_motif_reg_size = 0
        if unique_motifs_dic:
            benchlib.batch_output_motif_hits_to_bed(unique_motifs_dic, out_tmp_bed,
                                                    one_based_start=True)
            # Calculate effective motif region size.
            eff_motif_reg_size = benchlib.get_uniq_gen_size(out_tmp_bed)

        # Number of unique motif nucleotides.
        rbp.c_uniq_motif_nts = eff_motif_reg_size
        # % unique motif nts over effective region length.
        rbp.perc_uniq_motif_nts_eff_reg = (eff_motif_reg_size / eff_reg_size) * 100
        # % unique motif nts over called region length.
        rbp.perc_uniq_motif_nts_cal_reg = (eff_motif_reg_size / called_reg_size) * 100
        # Number of unique motif hits per effective 1000 nt.
        rbp.uniq_motif_hits_eff_1000nt  = rbp.c_uniq_motif_hits / (eff_reg_size / 1000)
        # Number of unique motif hits per called 1000 nt.
        rbp.uniq_motif_hits_cal_1000nt  = rbp.c_uniq_motif_hits / (called_reg_size / 1000)

        print("# --in regions for motif search:", c_regions)
        print("Called genomic region size:     ", called_reg_size)
        print("Effective genomic region size:  ", eff_reg_size)

        """
        Motif enrichment test:
        Are motifs enriched in higher scoring sites?

        """

        print("Calculate Wilcoxon rank-sum test statistics ... ")

        # Check if all scores same (e.g. 0).
        reg_scores_dic = {}
        for reg_id in reg2sc_dic:
            reg_scores_dic[reg2sc_dic[reg_id]] = 1
        if len(reg_scores_dic) == 1:
            print("WARNING: all site scores identical. Reported p-values meaningless! (i.e., equal 1.0)")

        hit_reg_scores = []
        non_hit_reg_scores = []
        seen_ids_dic = {}

        for reg_id in reg2sc_dic:
            reg_sc = reg2sc_dic[reg_id] # float value.
            # If --unstranded, count regions only once as hit or no hit.
            if args.unstranded and not args.unstranded_ct:
                core_id = benchlib.reg_get_core_id(reg_id)
                reg_id1 = core_id + "(+)"
                reg_id2 = core_id + "(-)"
                if core_id not in seen_ids_dic:
                    if reg_id1 in regions_with_motifs_dic or reg_id2 in regions_with_motifs_dic:
                        hit_reg_scores.append(reg_sc)
                    else:
                        non_hit_reg_scores.append(reg_sc)
                    seen_ids_dic[core_id] = 1
            else:
                if reg_id in regions_with_motifs_dic:
                    hit_reg_scores.append(reg_sc)
                else:
                    non_hit_reg_scores.append(reg_sc)

        wc_pval = 1.0
        # In case no regions without motif hits.
        if not non_hit_reg_scores:
            print("WARNING: all input regions contain motifs. Adding dummy scores (median) ... ")
            dummy_val = statistics.median(hit_reg_scores)
            hit_reg_scores.append(dummy_val)
            non_hit_reg_scores.append(dummy_val)

        print("# hit regions:    ", len(hit_reg_scores))
        print("# non-hit regions:", len(non_hit_reg_scores))

        if unique_motifs_dic:
            wc_stat, wc_pval = mannwhitneyu(hit_reg_scores, non_hit_reg_scores, alternative=wrs_alt_hypo)
            rbp.wc_pval = wc_pval
        print("Compact hit stats (RBP ID, # unique hits, Wilcoxon p-value):")
        print("%s\t%i\t%s" %(rbp_id, rbp.c_uniq_motif_hits, str(wc_pval)))

        """
        Motif enrichment test for regex motifs.
        
        """
        if args.regex:
                
            print("Calculate Wilcoxon rank-sum test statistics for --regex ... ")

            hit_reg_scores = []
            non_hit_reg_scores = []
            seen_ids_dic = {}

            for reg_id in reg2sc_dic:
                reg_sc = reg2sc_dic[reg_id] # float value.
                # If --unstranded, count regions only once as hit or no hit.
                if args.unstranded and not args.unstranded_ct:
                    core_id = benchlib.reg_get_core_id(reg_id)
                    reg_id1 = core_id + "(+)"
                    reg_id2 = core_id + "(-)"
                    if core_id not in seen_ids_dic:
                        if reg_id1 in regions_with_regex_dic or reg_id2 in regions_with_regex_dic:
                            hit_reg_scores.append(reg_sc)
                        else:
                            non_hit_reg_scores.append(reg_sc)
                        seen_ids_dic[core_id] = 1
                else:
                    if reg_id in regions_with_regex_dic:
                        hit_reg_scores.append(reg_sc)
                    else:
                        non_hit_reg_scores.append(reg_sc)

            wc_pval = 1.0
            # In case no regions without motif hits.
            if not non_hit_reg_scores:
                print("WARNING: all input regions contain motifs. Adding dummy scores (median) ... ")
                dummy_val = statistics.median(hit_reg_scores)
                hit_reg_scores.append(dummy_val)
                non_hit_reg_scores.append(dummy_val)

            print("# hit regions:    ", len(hit_reg_scores))
            print("# non-hit regions:", len(non_hit_reg_scores))

            c_uniq_regex_hits = len(unique_regex_dic)

            if unique_regex_dic:
                wc_stat, wc_pval = mannwhitneyu(hit_reg_scores, non_hit_reg_scores, alternative=wrs_alt_hypo)
            print("Compact hit stats (RBP ID, # unique hits, Wilcoxon p-value):")
            print("regex\t%i\t%s" %(c_uniq_regex_hits, str(wc_pval)))

            c_regex_hit_reg = len(hit_reg_scores)
            c_regex_no_hit_reg = len(non_hit_reg_scores)

            id2regex_stats_dic[internal_id] = [c_regex_hit_reg, c_regex_no_hit_reg, c_uniq_regex_hits, wc_pval]

            # Calculate Fisher exact test for regex vs RBP hits.
            print("Calculate Fisher exact test statistics for --regex ... ")

            table, avg_min_dist, perc_close_hits = benchlib.make_contingency_table_2x2_v2(
                                                        region_rbp_binds_dic, 1, 0,
                                                        rid2rbpidx2hcp_dic,
                                                        max_motif_dist=args.max_motif_dist)

            odds_ratio, p_value = fisher_exact(table, alternative=fisher_alt_hypo)

            id2regex_stats_dic[internal_id].append(avg_min_dist)
            id2regex_stats_dic[internal_id].append(perc_close_hits)
            id2regex_stats_dic[internal_id].append(str(table))
            id2regex_stats_dic[internal_id].append(str(p_value))

        """
        Output RBP hit stats (one row per RBP).

        """
        c_reg_with_hits = rbp.c_hit_reg
        perc_reg_with_hits = rbp.perc_hit_reg
        c_motif_hits = rbp.c_motif_hits
        c_uniq_motif_hits = rbp.c_uniq_motif_hits
        c_uniq_motif_nts = rbp.c_uniq_motif_nts
        perc_uniq_motif_nts_cal_reg = rbp.perc_uniq_motif_nts_cal_reg
        perc_uniq_motif_nts_eff_reg = rbp.perc_uniq_motif_nts_eff_reg
        uniq_motif_hits_cal_1000nt = rbp.uniq_motif_hits_cal_1000nt
        uniq_motif_hits_eff_1000nt = rbp.uniq_motif_hits_eff_1000nt
        wc_pval = rbp.wc_pval

        seq_motif_hits = ",".join(str(hc) for hc in rbp.seq_motif_hits)
        str_motif_hits = ",".join(str(hc) for hc in rbp.str_motif_hits)
        seq_motif_ids = ",".join(rbp.seq_motif_ids)
        str_motif_ids = ",".join(rbp.str_motif_ids)
        if not seq_motif_hits:
            seq_motif_hits = "-"
        if not str_motif_hits:
            str_motif_hits = "-"
        if not seq_motif_ids:
            seq_motif_ids = "-"
        if not str_motif_ids:
            str_motif_ids = "-"

        row_str = data_id + "\t"
        row_str += method_id + "\t"
        row_str += run_id + "\t"
        row_str += motif_db_str + "\t"
        row_str += rbp_id + "\t"

        row_str += str(c_regions) + "\t"

        row_str += str(reg_len_mean) + "\t"
        row_str += str(reg_len_median) + "\t"
        row_str += str(reg_len_min) + "\t"
        row_str += str(reg_len_max) + "\t"

        row_str += str(called_reg_size) + "\t"
        row_str += str(eff_reg_size) + "\t"

        row_str += str(c_reg_with_hits) + "\t"
        row_str += str(perc_reg_with_hits) + "\t"

        row_str += str(c_motif_hits) + "\t"
        row_str += str(c_uniq_motif_hits) + "\t"
        row_str += str(c_uniq_motif_nts) + "\t"
        row_str += str(perc_uniq_motif_nts_cal_reg) + "\t"
        row_str += str(perc_uniq_motif_nts_eff_reg) + "\t"
        row_str += str(uniq_motif_hits_cal_1000nt) + "\t"
        row_str += str(uniq_motif_hits_eff_1000nt) + "\t"
        row_str += str(wc_pval) + "\t"
        row_str += seq_motif_ids + "\t"
        row_str += seq_motif_hits + "\t"
        row_str += str_motif_ids + "\t"
        row_str += str_motif_hits + "\t"
        row_str += internal_id + "\n"

        OUTRBPSTATS.write(row_str)


        """
        Output motif region stats (one row per motif hit).
        Report ALL motif hits, plus report how many times one genomic 
        motif hit occurs (uniq_count). 

        """

        for fh in fimo_hits_list:

            region_id = fh.seq_name
            region_len = benchlib.get_length_from_seq_name(fh.seq_name)
            # Genomic motif region string.
            fh_str = repr(fh) 
            uniq_count = unique_motifs_dic[fh_str]

            # Store motif hit as BED.
            hit_id = "%s:%s-%s(%s),%s;%s" %(fh.chr_id, str(fh.start), str(fh.end), fh.strand, fh.motif_id, internal_id)
            if hit_id not in motif_reg_dic:
                bed_row = "%s\t%i\t%i\t%s,%s;%i;%s,%s\t0\t%s\t%s\t%s\t-1.0\t-1.0" %(fh.chr_id, fh.start-1, fh.end, rbp_id, fh.motif_id, uniq_count, method_id, data_id, fh.strand, str(fh.score), str(fh.pval))
                motif_reg_dic[hit_id] = bed_row

            row_str = data_id + "\t"
            row_str += method_id + "\t"
            row_str += run_id + "\t"
            row_str += motif_db_str + "\t"
            row_str += region_id + "\t"
            row_str += rbp_id + "\t"
            row_str += fh.motif_id + "\t"
            row_str += fh.chr_id + "\t"
            row_str += str(fh.start) + "\t"
            row_str += str(fh.end) + "\t"
            row_str += fh.strand + "\t"
            row_str += str(fh.seq_s) + "\t"
            row_str += str(fh.seq_e) + "\t"
            row_str += str(region_len) + "\t"
            row_str += str(uniq_count) + "\t"
            row_str += str(fh.score) + "\t"
            row_str += str(fh.pval) + "\t"
            row_str += "-\t"
            row_str += "-\t"
            row_str += internal_id + "\n"

            OUTMTFSTATS.write(row_str)

        for cmsh in cmsearch_hits_list:

            region_id = cmsh.seq_name
            region_len = benchlib.get_length_from_seq_name(cmsh.seq_name)
            # Genomic motif region string.
            cmsh_str = repr(cmsh) 
            uniq_count = unique_motifs_dic[cmsh_str]

            # Store motif hit as BED.
            hit_id = "%s:%s-%s(%s),%s;%s" %(cmsh.chr_id, str(cmsh.start), str(cmsh.end), cmsh.strand, cmsh.motif_id, internal_id)
            if hit_id not in motif_reg_dic:
                bed_row = "%s\t%i\t%i\t%s,%s;%i;%s,%s\t0\t%s\t%s\t%s\t-1.0\t-1.0" %(cmsh.chr_id, cmsh.start-1, cmsh.end, rbp_id, cmsh.motif_id, uniq_count, cmsh.strand, method_id, data_id, str(cmsh.score), str(cmsh.e_value))
                motif_reg_dic[hit_id] = bed_row

            row_str = data_id + "\t"
            row_str += method_id + "\t"
            row_str += run_id + "\t"
            row_str += motif_db_str + "\t"
            row_str += region_id + "\t"
            row_str += rbp_id + "\t"
            row_str += cmsh.motif_id + "\t"
            row_str += cmsh.chr_id + "\t"
            row_str += str(cmsh.start) + "\t"
            row_str += str(cmsh.end) + "\t"
            row_str += cmsh.strand + "\t"
            row_str += str(cmsh.seq_s) + "\t"
            row_str += str(cmsh.seq_e) + "\t"
            row_str += str(region_len) + "\t"
            row_str += str(uniq_count) + "\t"
            row_str += "-\t"
            row_str += "-\t"
            row_str += str(cmsh.score) + "\t"
            row_str += str(cmsh.e_value) + "\t"
            row_str += internal_id + "\n"

            OUTMTFSTATS.write(row_str)

        """
        if --gtf is set, overlap regions with annotations.
        
        """
        c_all_hits += c_hit_reg

        if args.in_gtf:
            print("--gtf file set. Overlap regions with gene annotations ... ")

            # reg_ids_dic needed to complete reg2annot_dic (for regions with no overlaps).
            reg_ids_dic = {}
            if args.unstranded and not args.unstranded_ct:
                for seq_id, seq in sorted(out_seqs_dic.items()):
                    core_id = benchlib.reg_get_core_id(seq_id)
                    reg_ids_dic[core_id] = 1
            else:
                for seq_id, seq in sorted(out_seqs_dic.items()):
                    reg_ids_dic[seq_id] = 1

            # Overlap with input regions.
            print("Overlap annotations with input regions ... ")
            params = "-s -wo -f %s" %(str(args.gtf_feat_min_overlap))
            overlap_annotations_bed = args.out_folder + "/overlap_annotations.tmp.bed"
            benchlib.bed_intersect_files(filtered_sites_bed, intron_exon_out_bed, 
                                         overlap_annotations_bed,
                                         params=params)
            
            reg2annot_dic = benchlib.get_region_annotations(overlap_annotations_bed,
                                                            reg_ids_dic=reg_ids_dic)

            # reg2annot_dic = {'chr22:30971326-30971352(+)': ['other (nc)RNA', 'ENST00000614234'], ...

            # Store annotations for all regions.
            occ_tr_ids_dic = {}  # Transcript IDs occupied by dataset regions.
            id2reg_annot_dic[internal_id] = {}
            for reg_id in reg2annot_dic:
                annot = reg2annot_dic[reg_id][0]
                tr_id = reg2annot_dic[reg_id][1]

                if tr_id:  # if tr_id is not False (if region does not overlap with transcripts/genes).

                    # Record transcript IDs occupied by all dataset regions.
                    if tr_id in all_sets_occ_tr_ids_dic:
                        all_sets_occ_tr_ids_dic[tr_id] += 1
                    else:
                        all_sets_occ_tr_ids_dic[tr_id] = 1

                    # Record transcript IDs occupied by regions from this specific dataset.
                    if tr_id in occ_tr_ids_dic:
                        occ_tr_ids_dic[tr_id] += 1
                    else:
                        occ_tr_ids_dic[tr_id] = 1

                annot_dic[annot] = 1
                if annot in id2reg_annot_dic[internal_id]:
                    id2reg_annot_dic[internal_id][annot] += 1
                else:
                    id2reg_annot_dic[internal_id][annot] = 1
            
            # Store annotations for regions with hits only.
            id2hit_reg_annot_dic[internal_id] = {}
            for reg_id in regions_with_motifs_dic:
                annot = reg2annot_dic[reg_id][0]
                if annot in id2hit_reg_annot_dic[internal_id]:
                    id2hit_reg_annot_dic[internal_id][annot] += 1
                else:
                    id2hit_reg_annot_dic[internal_id][annot] = 1

            # Record transcript ID occupancies for all transcripts in --gtf annotation.
            if occ_all_tr:
                id2occ_list_dic[internal_id] = []
                for tr_id in sorted(tr_ids_dic):
                    if tr_id in occ_tr_ids_dic:
                        if occ_mode == 1:
                            id2occ_list_dic[internal_id].append(1)
                        elif occ_mode == 2:
                            id2occ_list_dic[internal_id].append(occ_tr_ids_dic[tr_id])
                    else:
                        id2occ_list_dic[internal_id].append(0)
            else:
                id2occ_tr_ids_dic[internal_id] = occ_tr_ids_dic

            # --unstranded option, count both strands only once.
            if args.unstranded and not args.unstranded_ct:
                for internal_id in id2reg_annot_dic:
                    for annot in id2reg_annot_dic[internal_id]:
                        annot_c = id2reg_annot_dic[internal_id][annot]
                        assert not annot_c % 2, "# of regions with annotation %s should be even since --unstranded is set" %(annot)
                        new_annot_c = annot_c // 2
                        id2reg_annot_dic[internal_id][annot] = new_annot_c
                for internal_id in id2hit_reg_annot_dic:
                    for annot in id2hit_reg_annot_dic[internal_id]:
                        annot_c = id2hit_reg_annot_dic[internal_id][annot]
                        assert not annot_c % 2, "# of regions with annotation %s should be even since --unstranded is set" %(annot)
                        new_annot_c = annot_c // 2
                        id2hit_reg_annot_dic[internal_id][annot] = new_annot_c

        # Dataset ID.
        # dataset_idx += 1
        # dataset_id = str(dataset_idx) + "," + rbp_id + "," + motif_db_str + "," + method_id + "," + data_id
        if add_motif_db_info:
            dataset_id = rbp_id + "," + motif_db_str + "," + method_id + "," + data_id
        else:
            dataset_id = rbp_id + "," + method_id + "," + data_id

        dataset_ids_list.append(dataset_id)

        if args.report:

            # Get k-mer frequencies for all regions.
            print("Calculate k-mer frequencies ... ")

            # k-mer frequencies unaffected by --unstranded options.
            kmer_dic = benchlib.seqs_dic_count_kmer_freqs(out_seqs_dic, args.kmer_size, 
                                                          rna=False,
                                                          convert_to_uc=True,
                                                          return_ratios=True)

            # Store the k-mer frequencies for later comparison plot in a list, sorted by key.
            kmer_freqs_list = []
            for kmer in sorted(kmer_dic):
                kmer_freqs_list.append(kmer_dic[kmer])
            kmer_freqs_ll.append(kmer_freqs_list)

            print("Get sequence length statistics ... ")

            # Sequence length statistics for out_seqs_dic.
            unstranded_len_stats = False
            if args.unstranded and not args.unstranded_ct:
                # In this case we want to count the two strands of a region as one region.
                unstranded_len_stats = True
            seq_len_stats_l = benchlib.get_sequence_length_statistics(out_seqs_dic,
                                                                      unstranded=unstranded_len_stats)
            # Add dataset ID to seq_len_stats_l.
            seq_len_stats_l.insert(0, dataset_id)
            seq_len_stats_ll.append(seq_len_stats_l)


    OUTRBPSTATS.close()
    OUTMTFSTATS.close()

    OUTBED = open(motif_hits_bed_out,"w")
    for hit_id in motif_reg_dic:
        OUTBED.write("%s\n" %(motif_reg_dic[hit_id]))
    OUTBED.close()

    """
    Gene region occupancy stats only for genes occupied by input datasets.
    (i.e. if occ_all_tr == False).
    
    """

    if args.in_gtf and not occ_all_tr:

        for internal_id in id2infos_dic:

            id2occ_list_dic[internal_id] = []

            for tr_id in sorted(all_sets_occ_tr_ids_dic):
                if tr_id in id2occ_tr_ids_dic[internal_id]:
                    if occ_mode == 1:
                        id2occ_list_dic[internal_id].append(1)
                    elif occ_mode == 2:
                        id2occ_list_dic[internal_id].append(id2occ_tr_ids_dic[internal_id][tr_id])
                else:
                    id2occ_list_dic[internal_id].append(0)

    """
    Example id2reg_annot_dic:
    {'1wz3Cd6R': {'CDS': 66, 'intron': 8, "3'UTR": 7, "5'UTR": 2}, 'VoSg9-Mm': {'other (nc)RNA': 1, "3'UTR": 73, 'CDS': 10, 'lncRNA': 1, 'intron': 3}}

    """
    # print("id2infos_dic:")
    # print(id2infos_dic)
    # print("id2reg_annot_dic:")
    # print(id2reg_annot_dic)
    # print("dataset_ids_list:")
    # print(dataset_ids_list)
    # print("kmer_freqs_ll:")
    # print(kmer_freqs_ll)

    html_report_out = args.out_folder + "/" + "report.rbpbench_batch.html"
    if args.plot_abs_paths:
        html_report_out = os.path.abspath(args.out_folder) + "/" + "report.rbpbench_batch.html"

    if args.report:  # create report also if no hits ?

        assert dataset_ids_list, "no dataset IDs found for report creation"
        assert kmer_freqs_ll, "no k-mer frequencies found for report creation"

        plots_subfolder = "html_report_plots"
        benchlib_path = os.path.dirname(benchlib.__file__)

        print("Create HTML report ... ")
        benchlib.batch_generate_html_report(dataset_ids_list,
                                            kmer_freqs_ll,
                                            id2infos_dic, 
                                            id2reg_annot_dic, 
                                            id2hit_reg_annot_dic,
                                            args.out_folder,
                                            benchlib_path,
                                            seq_len_stats_ll,
                                            html_report_out=html_report_out,
                                            unstranded=args.unstranded,
                                            unstranded_ct=args.unstranded_ct,
                                            id2regex_stats_dic=id2regex_stats_dic,
                                            regex=regex,
                                            wrs_mode=args.wrs_mode,
                                            fisher_mode=args.fisher_mode,
                                            max_motif_dist=args.max_motif_dist,
                                            id2occ_list_dic=id2occ_list_dic,
                                            plot_abs_paths=args.plot_abs_paths,
                                            plotly_js_mode=args.plotly_js_mode,
                                            sort_js_mode=args.sort_js_mode,
                                            kmer_size=args.kmer_size,
                                            add_motif_db_info=add_motif_db_info,
                                            motif_db_str=motif_db_str,
                                            plots_subfolder=plots_subfolder)

    """
    All annot:
    annot_dic[annot] = 1
    id2hit_reg_annot_dic[internal_id][annot] += 1
    id2reg_annot_dic[internal_id][annot] += 1
    id2infos_dic[internal_id] = [rbp_id, data_id, method_id, motif_db_str, bed_file_path]

    """

    # Genomic region annotation stats on region containing RBP motif hits.
    rbp_annot_out = args.out_folder + "/rbp_motif_region_annotation_stats.tsv"
    # Genomic region annotation stats on all regions (with or without RBP motif hits).
    all_annot_out = args.out_folder + "/all_region_annotation_stats.tsv"

    if args.in_gtf:

        OUTRBP = open(rbp_annot_out, "w")
        OUTALL = open(all_annot_out, "w")

        # List all annotations encountered in batch run.
        annot_list = []
        for annot in annot_dic:
            annot_list.append(annot)
        # Sort list alphabetically.
        annot_list = sorted(annot_list)

        # Write header.
        header_annot_str = "\t".join(annot_list)
        OUTRBP.write("rbp_id\tmethod_id\tdata_id\tc_hit_regions_\tc_all_regions\tperc_hit_reg\t%s\tinternal_id\n" %(header_annot_str))
        OUTALL.write("rbp_id\tmethod_id\tdata_id\tc_all_regions\t%s\tinternal_id\n" %(header_annot_str))

        for internal_id in id2reg_annot_dic:

            # All regions in dataset (== total annotation count).
            reg_counts = id2c_regions_dic[internal_id]
            c_all_regions = reg_counts[0]
            c_hit_regions = reg_counts[1]

            id_infos = id2infos_dic[internal_id]

            rbp_id = id_infos[0]
            data_id = id_infos[1]
            method_id = id_infos[2]

            if add_motif_db_info:
                rbp_id = id_infos[0]
                motif_db_str = id_infos[1]
                data_id = id_infos[2]
                method_id = id_infos[3]

            id_rbp_annot_list = []
            for annot in annot_list:
                perc_annot = 0.0
                if annot in id2hit_reg_annot_dic[internal_id]:
                    # Calculate percentage of annotation counts over RBP motif hit annotation counts.
                    perc_annot = (id2hit_reg_annot_dic[internal_id][annot] / c_hit_regions) * 100
                id_rbp_annot_list.append(perc_annot)

            perc_rbp_annot_str = "\t".join(str(round(perc, 2)) for perc in id_rbp_annot_list)
            perc_hit_all = (c_hit_regions / c_all_regions) * 100
            perc_hit_all = str(round(perc_hit_all, 2))
            OUTRBP.write("%s\t%s\t%s\t%i\t%i\t%s\t%s\t%s\n" %(rbp_id, method_id, data_id, c_hit_regions, c_all_regions, perc_hit_all, perc_rbp_annot_str, internal_id))

            id_all_annot_list = []
            for annot in annot_list:
                perc_annot = 0.0
                if annot in id2reg_annot_dic[internal_id]:
                    # Calculate percentage of annotation counts over all annotation counts.
                    perc_annot = (id2reg_annot_dic[internal_id][annot] / c_all_regions) * 100
                id_all_annot_list.append(perc_annot)

            perc_all_annot_str = "\t".join(str(round(perc, 2)) for perc in id_all_annot_list)
            OUTALL.write("%s\t%s\t%s\t%i\t%s\t%s\n" %(rbp_id, method_id, data_id, c_all_regions, perc_all_annot_str, internal_id))

        OUTRBP.close()
        OUTALL.close()


    """
    Output parameter settings.

    """
    # Output mode settings.
    print("")
    print("Output parameter settings ... ")
    SETOUT = open(settings_file, "w")
    for arg in vars(args):
        SETOUT.write("%s\t%s\n" %(arg, str(getattr(args, arg))))
    for call in call_dic:
        SETOUT.write("%s\t%s\n" %(call, call_dic[call]))
    SETOUT.close()

    """
    Take out the trash.

    """
    print("Delete .tmp files ... ")
    if os.path.exists(out_tmp_bed):
        os.remove(out_tmp_bed)
    if os.path.exists(cmstat_tmp_out):
        os.remove(cmstat_tmp_out)

    """
    Inform about outputs.

    """
    print("")
    print("OUTPUT FILES")
    print("============")
    print("")
    print("Run parameter settings:\n%s" %(settings_file))
    print("Motif hits .bed:\n%s" %(motif_hits_bed_out))
    print("RBP hit stats .tsv:\n%s" %(rbp_stats_out))
    print("Motif hit stats .tsv:\n%s" %(motif_stats_out))
    if args.in_gtf:
        print("RBP motif region annotation stats .tsv:\n%s" %(rbp_annot_out))
        print("All region annotation stats .tsv:\n%s" %(all_annot_out))
    if args.report:
        print("Comparative plots report .html:\n%s" %(html_report_out))
    print("")











################################################################################

def main_searchregex(args):
    """
    Regex motif search.

    """

    print("Running for you in SEARCHREGEX mode ... ")

    assert os.path.exists(args.in_file), "--in file \"%s\" not found" % (args.in_file)
    assert benchlib.is_valid_regex(args.regex), "invalid --regex \"%s\" given. Please provide a valid regex string" % (args.regex)

    # Output files.
    if not os.path.exists(args.out_folder):
        os.makedirs(args.out_folder)
    in_seqs_fa = args.out_folder + "/in_sequences.fa"
    in_reg_bed = args.out_folder + "/in_regions.bed"
    motif_hits_bed_out = args.out_folder + "/motif_hits.bed"
    regions_with_hit_counts_bed_out = args.out_folder + "/regions_with_hit_counts.bed"

    """
    Check if --in is BED or FASTA.
    Get sequences dictionary accordingly.
    
    """

    id_check = True
    if args.make_uniq_headers:
        id_check = False

    in_seqs_dic = {}
    bed_reg_dic = {}
    is_bed = False

    if benchlib.fasta_check_format(args.in_file):

        print("--in input file is FASTA. Read in sequences ... ")

        
        in_seqs_dic = benchlib.read_fasta_into_dic(args.in_file,
                                        dna=True,
                                        all_uc=True,
                                        id_check=id_check,
                                        empty_check=False,
                                        new_header_id=args.header_id,
                                        make_uniq_headers=args.make_uniq_headers,
                                        report=1,
                                        skip_n_seqs=False)

        assert in_seqs_dic, "no sequences read in from --in FASTA file. Make sure to provide a FASTA formatted file with DNA or RNA sequences"

    elif benchlib.bed_check_format(args.in_file, asserts=False):

        print("--in input file is BED. Extract region sequences from --genome FASTA file ... ")

        if not args.in_genome:
            assert False, "--in BED file provided, but no --genome FASTA file provided. Please provide a FASTA file with genomic sequences"
        assert os.path.exists(args.in_genome), "--genome FASTA file \"%s\" not found" % (args.in_genome)

        is_bed = True

        bed_reg_dic = benchlib.bed_check_ids_output_bed(args.in_file, in_reg_bed,
                                                        id_check=id_check,
                                                        new_header_id=args.header_id,
                                                        make_uniq_headers=args.make_uniq_headers)

        benchlib.bed_extract_sequences_from_fasta(in_reg_bed, args.in_genome, in_seqs_fa,
                                                  add_param="-name",  # new FASTA header format: bed_col4_id::chr21:45528055-45528135(-)
                                                  print_warnings=True)

        in_seqs_dic = benchlib.read_fasta_into_dic(in_seqs_fa,
                                                   dna=True,
                                                   all_uc=True,
                                                   name_bed=True,  # Makes sure that in_seqs_dic keys are BED column 4 IDs.
                                                   id_check=True,
                                                   empty_check=False,
                                                   skip_n_seqs=False)
        
        assert in_seqs_dic, "no sequences extracted from --in BED file. Make sure to provide a BED file with genomic regions and a compatible FASTA file with genomic sequences"

    else:
        assert False, "--in input file format not supported. Provide either FASTA or BED file"

    assert in_seqs_dic, "no sequences read in from --in FASTA file. Make sure to provide a FASTA formatted file with DNA or RNA sequences"


    """
    Search for regex motif hits in sequence dictionary.
    
    hits_dic format:
    {'seq1': [[0, 2, 'AT'], [4, 6, 'AG']]}

    bed_reg_dic[reg_id] = [chr_id, reg_s, reg_e, reg_pol]

    """
    step_size_one = False
    if args.regex_search_mode == 1:
        step_size_one = False
    elif args.regex_search_mode == 2:
        step_size_one = True
    else:
        assert False, "invalid --regex-search-mode %i set" %(args.regex_search_mode)

    hits_dic = benchlib.search_regex_in_seqs_dic(args.regex, in_seqs_dic,
                                                 step_size_one=step_size_one,
                                                 case_sensitive=True)

    c_all_hits = 0
    for hit in hits_dic:
        c_all_hits += len(hits_dic[hit])

    print("")
    if is_bed:
        print("# input regions:    ", len(in_seqs_dic))
        print("# regex motif hits: ", c_all_hits)
    else:
        print("# input sequences:  ", len(in_seqs_dic))
        print("# regex motif hits: ", c_all_hits)


    """
    Output files.
    
    BED sequence ID format:
    chr20:62139082-62139128(-)

    """

    MOTIFOUT = open(motif_hits_bed_out, "w")
    REGIONOUT = open(regions_with_hit_counts_bed_out, "w")

    seen_motif_sites_dic = {}

    for hit in hits_dic:
        seq_id = hit
        c_hits = len(hits_dic[hit])
        len_seq = len(in_seqs_dic[seq_id])
        for hit_info in hits_dic[hit]:
            start = hit_info[0]
            end = hit_info[1]
            seq = hit_info[2]

            if is_bed:

                gen_reg_coords = bed_reg_dic[seq_id]
                reg_id = gen_reg_coords[0] + ":" + gen_reg_coords[1] + "-" + gen_reg_coords[2] + "(" + gen_reg_coords[3] + ")"

                gen_motif_coords = benchlib.get_genomic_coords_from_seq_name(reg_id, start, end,
                                                                             one_based_start=False)

                chr_id = gen_motif_coords[0]
                gen_motif_s = gen_motif_coords[1]
                gen_motif_e = gen_motif_coords[2]
                strand = gen_motif_coords[3]

                motif_site_str = "%s:%i-%i(%s)" %(chr_id, gen_motif_s, gen_motif_e, strand)
                if motif_site_str in seen_motif_sites_dic:
                    continue
                else:
                    seen_motif_sites_dic[motif_site_str] = 1
                    MOTIFOUT.write("%s\t%i\t%i\t%s\t0\t%s\n" %(chr_id, gen_motif_s, gen_motif_e, seq, strand))

            else:

                motif_site_str = "%s:%i-%i" %(seq_id, start, end)
                if motif_site_str in seen_motif_sites_dic:
                    continue
                else:
                    seen_motif_sites_dic[motif_site_str] = 1
                    MOTIFOUT.write("%s\t%s\t%s\t%s\t0\t+\n" %(seq_id, start, end, seq))
        
        if is_bed:

            gen_reg_coords = bed_reg_dic[seq_id]
            chr_id = gen_reg_coords[0]
            reg_s = gen_reg_coords[1]
            reg_e = gen_reg_coords[2]
            strand = gen_reg_coords[3]
            REGIONOUT.write("%s\t%s\t%s\t%s\t%i\t%s\n" %(chr_id, reg_s, reg_e, seq_id, c_hits, strand))

        else:

            REGIONOUT.write("%s\t0\t%i\t%s\t%i\t+\n" %(seq_id, len_seq, seq_id, c_hits))

    """
    If regions with zero hits should also be added to REGIONOUT.

    """

    if args.add_zero_hits:
        
        print("Also add regions with zero hits ... ")

        for seq_id in in_seqs_dic:
            if seq_id not in hits_dic:
                if is_bed:
                    gen_reg_coords = bed_reg_dic[seq_id]
                    chr_id = gen_reg_coords[0]
                    reg_s = gen_reg_coords[1]
                    reg_e = gen_reg_coords[2]
                    strand = gen_reg_coords[3]
                    REGIONOUT.write("%s\t%s\t%s\t%s\t0\t%s\n" %(chr_id, reg_s, reg_e, seq_id, strand))

                else:
                    len_seq = len(in_seqs_dic[seq_id])
                    REGIONOUT.write("%s\t0\t%i\t%s\t0\t+\n" %(seq_id, len_seq, seq_id))

    MOTIFOUT.close()
    REGIONOUT.close()

    if not hits_dic:
        print("No regex motif hits found in --in regions / sequences")

    print("")
    print("OUTPUT FILES")
    print("============")
    print("")
    print("Regex motif hits .bed:\n%s" %(motif_hits_bed_out))
    print("Sequences / regions with hit counts .bed:\n%s" %(regions_with_hit_counts_bed_out))
    print("")


################################################################################

def main_searchseq(args):
    """
    Sequence motifs search.

    """

    print("Running for you in SEARCHSEQ mode ... ")


    assert os.path.exists(args.in_seqs), "--in FASTA file \"%s\" not found" % (args.in_seqs)

    # Is MEME >= v5 installed?
    if not args.meme_disable_check:
        assert benchlib.is_tool("meme"), "meme not in PATH"
        check, meme_version = benchlib.check_tool_version("meme -version", "5.0")
        assert check, "RBPBench requires meme version >= 5.0 (installed version: %s)" %(meme_version)

    # Check if MEME version is >= 5.5.4 (need to add fimo --no-pgc option to produce same results!).
    fimo_params = "--norc --verbosity 1 --skip-matched-sequence --text"
    if not args.meme_disable_check:
        check, meme_version = benchlib.check_tool_version("meme -version", "5.5.4")
        if check:
            fimo_params = "--norc --verbosity 1 --skip-matched-sequence --text --no-pgc"
    if args.meme_no_pgc:
        fimo_params = "--norc --verbosity 1 --skip-matched-sequence --text --no-pgc"

    """
    Library path.
    """
    benchlib_path = os.path.dirname(benchlib.__file__)
    db_path = benchlib_path + "/content"

    """
    FIMO nt frequencies.
    """
    fimo_freqs_file = db_path + "/fimo_nt_freqs.txt"
    if args.fimo_nt_freqs:
        fimo_freqs_file = args.fimo_nt_freqs
    assert os.path.exists(fimo_freqs_file), "set FIMO nucleotide frequencies file \"%s\" not found" % (fimo_freqs_file)

    """
    Motif database.
    """
    seq_motifs_db_file, str_motifs_db_file, rbp2ids_file, motif_db_str = specify_motif_db(args.motif_db, 
                                                                            db_path=db_path)
    # Custom motif database: folder given.
    if args.custom_db:
        assert not args.custom_db_meme_xml, "--custom-db folder set incompatible with --custom-db-meme-xml. Provide custom motif database either via folder (--custom-db) or as single files"
        assert not args.custom_db_cm, "--custom-db folder set incompatible with --custom-db-cm. Provide custom motif database either via folder (--custom-db) or as single files"
        assert not args.custom_db_info, "--custom-db folder set incompatible with --custom-db-info. Provide custom motif database either via folder (--custom-db) or as single files"
        seq_motifs_db_file, str_motifs_db_file, rbp2ids_file = specify_custom_motif_db(args.custom_db)
        motif_db_str = args.custom_db_id
    # Custom motif database: single files given.
    if args.custom_db_meme_xml or args.custom_db_cm or args.custom_db_info:
        motif_db_str = args.custom_db_id
        assert not args.custom_db, "single custom motif database files provided not compatible with --custom-db. Provide custom motif database either via folder (--custom-db) or as single files"
        assert args.custom_db_info, "--custom-db-info needed to define custom motif database"
        rbp2ids_file = args.custom_db_info
        assert args.custom_db_meme_xml or args.custom_db_cm, "--custom-db-meme-xml and/or --custom-db-cm needed to define custom motif database"
        if args.custom_db_meme_xml:
            seq_motifs_db_file = args.custom_db_meme_xml
        else:
            seq_motifs_db_file = ""  # setting to empty string results in os.path.exists -> False.
        if args.custom_db_cm:
            str_motifs_db_file = args.custom_db_cm
        else:
            str_motifs_db_file = ""

    args.motif_db_str = motif_db_str

    """
    Get ID mappings

    name2ids_dic:
    RBP name -> motif IDs mapping
    id2type_dic:
    motif ID -> motif type (cm, meme_xml)
    id2org_dic (ignore for now):
    motif ID -> organism ID (so far only "human")

    """
    name2ids_dic, id2type_dic = benchlib.get_rbp_id_mappings(rbp2ids_file)
    # Motif ID -> RBP name (== RBP ID) mapping.
    id2name_dic = {}
    for rbp_id in name2ids_dic:
        for motif_id in name2ids_dic[rbp_id]:
            id2name_dic[motif_id] = rbp_id

    """
    Get MEME XML database motif blocks dictionary.

    """
    seq_motif_blocks_dic = {}
    if os.path.exists(seq_motifs_db_file):
        seq_motif_blocks_dic = benchlib.read_in_xml_motifs(seq_motifs_db_file,
                                                           empty_check=True)
    for motif_id in seq_motif_blocks_dic:
        assert motif_id in id2name_dic, "MEME XML motif ID %s not found in prior mapping. Please contact developers!" %(motif_id)

    """
    Get covariance model database motif blocks dictionary.

    """
    str_motif_blocks_dic = {}
    if os.path.exists(str_motifs_db_file):
        str_motif_blocks_dic = benchlib.read_in_cm_blocks(str_motifs_db_file, 
                                                          empty_check=True)
    for motif_id in str_motif_blocks_dic:
        assert motif_id in id2name_dic, "Covariance model accession ID %s not found in prior mapping. Please contact developers!" %(motif_id)

    # Remove special chars from run ID.
    args.data_id = benchlib.remove_special_chars_from_str(args.data_id)
    assert args.data_id, "empty string after removing special chars from --data-id. Please provide alphanumeric string for data ID (- or _ are okay as well)"
    args.method_id = benchlib.remove_special_chars_from_str(args.method_id)
    assert args.method_id, "empty string after removing special chars from --method-id. Please provide alphanumeric string for method ID (- or _ are okay as well)"
    # Run ID definition.
    run_id = "run_id"
    # if args.run_id:
    #     run_id = benchlib.remove_special_chars_from_str(args.run_id)
    #     assert run_id, "empty string after removing special chars from --run-id. Please provide alphanumeric string for run ID (- or _ are okay as well)"
    # else:
    #     random_id = uuid.uuid4()
    #     run_id = str(random_id)

    # hash_len = max(len(run_id), len(args.data_id), len(args.method_id))
    # print("###################" + "#"*hash_len)
    print("Run ID:     ", run_id)
    print("Data ID:    ", args.data_id)
    print("Method ID:  ", args.method_id)
    # print("###################" + "#"*hash_len)

    """
    Output folders + files.

    """
    if not os.path.exists(args.out_folder):
        os.makedirs(args.out_folder)

    # filtered_sites_bed = args.out_folder + "/in_sites.filtered.bed"
    filtered_seqs_fa = args.out_folder + "/in_sequences.filtered.fa"
    seq_motifs_xml = args.out_folder + "/seq_motifs.xml"
    str_motifs_cm = args.out_folder + "/str_motifs.cm"
    fimo_res_tsv = args.out_folder + "/fimo_results.tsv"
    cmsearch_res_txt = args.out_folder + "/cmsearch_results.txt"

    rbp_stats_out = args.out_folder + "/rbp_hit_stats.tsv"
    motif_stats_out = args.out_folder + "/motif_hit_stats.tsv"
    con_res_out_tsv = args.out_folder + "/contingency_table_results.tsv"
    settings_file = args.out_folder + "/settings.find_motifs.out"
    rbp_reg_occ_table_out = args.out_folder + "/rbp_region_occupancies.tsv"

    # Output unique motif hits.
    motif_hits_bed_out = args.out_folder + "/motif_hits.rbpbench_searchseq.bed"

    # Temp files.
    # random_id = uuid.uuid1()
    # tmp_out_bed = args.out_folder + "/" + str(random_id) + ".filtered_in.bed"
    out_tmp_bed = args.out_folder + "/rbp_motif_hit_regions.tmp.bed"
    cmstat_tmp_out = args.out_folder + "/cmstat_out.tmp.txt"

    # Delete if existing folder.
    if os.path.exists(fimo_res_tsv):
        os.remove(fimo_res_tsv)
    if os.path.exists(cmsearch_res_txt):
        os.remove(cmsearch_res_txt)


    """
    Load RBP data based on --rbps (+ optionally USER data).

    """

    rbp_in_dic = {}
    for rbp_id in args.list_rbps:
        rbp_in_dic[rbp_id] = 1

    # RBPs for motif search.
    loaded_rbps_dic = {}

    # USER set?
    user_motifs = False
    user_rbp_id = False
    if "USER" in rbp_in_dic:
        user_motifs = True
    else:
        assert not args.user_meme_xml, "--user-meme-xml provided but --rbps USER not set. Please add USER to --rbps list to search for user-supplied motifs"
        assert not args.user_cm, "--user-cm provided but --rbps USER not set. Please add USER to --rbps list to search for user-supplied motifs"
        assert not args.user_rbp_id, "--user-rbp-id set but --rbps USER not set. Please add USER to --rbps list to search for user-supplied motifs"

    # If ALL set, load all RBPs (+ optinally USER).
    if "ALL" in rbp_in_dic:
        if len(rbp_in_dic) == 2:
            assert user_motifs, "set --rbps ALL, --rbps ALL USER, or individual RBPs (+ optinally USER) --rbps RBP1 RBP2 ... USER"
        if len(rbp_in_dic) > 2:
            assert False, "set --rbps ALL, --rbps ALL USER, or individual RBPs (+ optinally USER) --rbps RBP1 RBP2 ... USER"
        print("--rbps ALL selected. Loading all database motifs ... ")
        for rbp_id in name2ids_dic:
            loaded_rbps_dic[rbp_id] = motif_db_str

    else:
        # Load individual RBPs.
        for rbp_id in rbp_in_dic:
            if rbp_id != "USER":
                """
                Check if RBP ID in database.
                Suggest similar RBPs based on string similarity (edit distance).

                """
                if rbp_id not in name2ids_dic:
                    db_rbp_list = []
                    for db_rbp_id in name2ids_dic:
                        db_rbp_list.append(db_rbp_id)
                    pair_dist_dic = benchlib.calc_edit_dist_query_list(rbp_id, db_rbp_list)
                    max_c = 10
                    c = 0
                    suggested_rbps = []
                    for key, value in sorted(pair_dist_dic.items(), key=lambda item: item[1], reverse=False):
                        if c >= max_c:
                            break
                        c += 1
                        suggested_rbps.append(key)
                    suggested_rbps_str = ",".join(suggested_rbps)
                    assert False, "provided --rbps ID %s not in internal motif database (%s). Please provide RBP name present in database. Did you mean (any of) the following database ID(s) (top 10 hits based on string similarity): %s ?" %(rbp_id, motif_db_str, suggested_rbps_str)
                # assert rbp_id in name2ids_dic, "provided --rbps ID %s not in internal motif database. Please provide RBP name present in database" %(rbp_id)
                loaded_rbps_dic[rbp_id] = motif_db_str

    # Motif IDs for search.
    loaded_motif_ids_dic = {}
    for rbp_id in loaded_rbps_dic:
        for motif_id in name2ids_dic[rbp_id]:
            loaded_motif_ids_dic[motif_id] = motif_db_str

    """
    Check and load provided USER data.

    """

    if user_motifs:
        print("--rbps USER selected. Check + load provided USER motifs ... ")
        assert args.user_rbp_id, "--rbps USER demands --user-rbp-id to be set to connect the supplied motif(s) with an RBP ID"
        assert args.user_meme_xml or args.user_cm, "--rbps USER requires a provided sequence or structure motif file (via --user-meme-xml AND/OR --user-cm)"

        # Reformat user_rbp_id. 
        user_rbp_id = benchlib.remove_special_chars_from_str(args.user_rbp_id)
        assert user_rbp_id, "empty string after removing special chars from --user-rbp-id. Please provide alphanumeric string for RBP ID (- or _ are okay as well)"

        assert user_rbp_id not in loaded_rbps_dic, "user RBP ID %s already selected from database. Please deselect respective database RBP ID or provide unique user RBP ID via --user-rbp-id" %(user_rbp_id)
        loaded_rbps_dic[user_rbp_id] = "user"
        # In case user_rbp_id in database, reset motif IDs associated to user_rbp_id.
        name2ids_dic[user_rbp_id] = []
        print("RBP ID for user-supplied motifs:", user_rbp_id)

        user_seq_motif_blocks_dic = {}
        if args.user_meme_xml:
            assert os.path.exists(args.user_meme_xml), "--user-meme-xml file \"%s\" not found" % (args.user_meme_xml)
            user_seq_motif_blocks_dic = benchlib.read_in_xml_motifs(args.user_meme_xml, empty_check=False)
            assert user_seq_motif_blocks_dic, "no motifs read in from provided --user-meme-xml. Make sure to supply sequence motifs in MEME XML format!"
            # Check if motif ID already loaded.
            for acc_id in user_seq_motif_blocks_dic:
                assert acc_id not in loaded_motif_ids_dic, "user-supplied MEME XML motif ID %s already selected, i.e., ID is already associated with selected database RBP %s. Please change user motif ID to a unique motif ID or deselect the respective RBP" %(acc_id, id2name_dic[acc_id])
                loaded_motif_ids_dic[acc_id] = "user"
                # Add user to database blocks (overwrite if same ID encountered).
                seq_motif_blocks_dic[acc_id] = user_seq_motif_blocks_dic[acc_id]
                name2ids_dic[user_rbp_id].append(acc_id)
                id2type_dic[acc_id] = "meme_xml"
                id2name_dic[acc_id] = user_rbp_id

        user_str_motif_blocks_dic = {}
        if args.user_cm:
            assert os.path.exists(args.user_cm), "--user-cm file \"%s\" not found" % (args.user_cm)
            # Check for valid format.
            acc_ids_dic = benchlib.check_cm_file(args.user_cm, cmstat_tmp_out, empty_check=False)
            # Read in covariance model blocks.
            user_str_motif_blocks_dic = benchlib.read_in_cm_blocks(args.user_cm)
            for acc_id in acc_ids_dic:
                assert acc_id in user_str_motif_blocks_dic, "accession ID %s not in blocks dictionary. Please contact developers!" %(acc_id)
            # Check if motif ID already loaded.
            for acc_id in user_str_motif_blocks_dic:
                assert acc_id not in loaded_motif_ids_dic, "user-supplied covariance model accession (ACC) ID %s already selected, i.e., ID is already associated with selected database RBP %s. Please change to a unique accession ID or deselect the respective RBP" %(acc_id, id2name_dic[acc_id])
                loaded_motif_ids_dic[acc_id] = "user"
                # Add user to database blocks (overwrite if same ID encountered).
                str_motif_blocks_dic[acc_id] = user_str_motif_blocks_dic[acc_id]
                name2ids_dic[user_rbp_id].append(acc_id)
                id2type_dic[acc_id] = "cm"
                id2name_dic[acc_id] = user_rbp_id

    """
    Check if loaded RBP IDs have motifs.

    """
    for rbp_id in loaded_rbps_dic:
        for motif_id in name2ids_dic[rbp_id]:
            found = 0
            if motif_id in seq_motif_blocks_dic:
                found += 1
            if motif_id in str_motif_blocks_dic:
                found += 1
            assert found, "no motifs loaded for RBP ID \"%s\". Please provide the respective motifs file" %(rbp_id)

    """
    Load RBP data, store in RBP() class.

    """

    # Store motif IDs for search.
    search_rbps_dic = {}
    seq_rbps_dic = {}
    str_rbps_dic = {}
    motif_id2idx_dic = {} # motif ID -> list index.
    args.internal_id = []

    for rbp_id in loaded_rbps_dic:
    
        internal_id = base64.urlsafe_b64encode(os.urandom(6)).decode()
        args.internal_id.append(internal_id)
        rbp = benchlib.RBP(rbp_id, internal_id)

        for motif_id in name2ids_dic[rbp_id]:
        
            assert motif_id in loaded_motif_ids_dic, "motif_id %s not in loaded_motif_ids_dic" %(motif_id)

            if id2type_dic[motif_id] == "meme_xml":
                rbp.seq_motif_ids.append(motif_id)
                motif_id2idx_dic[motif_id] = len(rbp.seq_motif_ids) - 1
                rbp.seq_motif_hits.append(0)
                seq_rbps_dic[rbp_id] = 1
            else:
                rbp.str_motif_ids.append(motif_id)
                motif_id2idx_dic[motif_id] = len(rbp.str_motif_ids) - 1
                rbp.str_motif_hits.append(0)
                str_rbps_dic[rbp_id] = 1

        search_rbps_dic[rbp_id] = rbp


    print("# of RBP IDs for search:    ", len(loaded_rbps_dic))
    print("# of motif IDs for search:  ", len(loaded_motif_ids_dic))

    """
    Read in sequences.
    """
    id_check = True
    if args.make_uniq_headers:
        id_check = False
    
    in_seqs_dic = benchlib.read_fasta_into_dic(args.in_seqs,
                                       dna=True,
                                       all_uc=True,
                                       id_check=id_check,
                                       empty_check=False,
                                       new_header_id=args.header_id,
                                       make_uniq_headers=args.make_uniq_headers,
                                       report=1,
                                       skip_n_seqs=False)

    assert in_seqs_dic, "no sequences read in from --in FASTA file. Make sure to provide a FASTA formatted file with DNA or RNA sequences"


    # Output sequences to FASTA.
    benchlib.fasta_output_dic(in_seqs_dic, filtered_seqs_fa,
                              split=True)


    # Effective number of regions used for motif search.
    c_regions = len(in_seqs_dic)

    # Called region size.
    called_reg_size = 0
    len_list = []
    for seq_id in in_seqs_dic:
        seq_len = len(in_seqs_dic[seq_id])
        called_reg_size += seq_len
        len_list.append(seq_len)

    # Length statistics.
    reg_len_median = statistics.median(len_list)
    reg_len_mean = statistics.mean(len_list)
    reg_len_mean = round(reg_len_mean, 2)
    reg_len_min = min(len_list)
    reg_len_max = max(len_list)

    """
    ====================================
    RUN SEQUENCE MOTIF SEARCH WITH FIMO.
    ====================================
    
    """
    fimo_hits_list = []
    call_dic = {}

    if seq_rbps_dic:

        """
        Print motifs to file.

        """

        print("Output motifs to XML ... ")
        out_str, c_added_motifs = benchlib.blocks_to_xml_string(seq_motif_blocks_dic, loaded_motif_ids_dic)

        benchlib.output_string_to_file(out_str, seq_motifs_xml)


        """
        Run FIMO on sequences + motifs.

        """

        print("Run FIMO ... ")
        benchlib.run_fast_fimo(filtered_seqs_fa, seq_motifs_xml, fimo_res_tsv,
                    pval_thr=args.fimo_pval,
                    nt_freqs_file=fimo_freqs_file,
                    call_dic=call_dic,
                    params=fimo_params,
                    error_check=False)

        """
        Read in FIMO hits.

        """

        assert os.path.exists(fimo_res_tsv), "FIMO output file fimo.tsv %s does not exist! There must have been an error while running FIMO (invalid xml file provided?)" %(fimo_res_tsv)

        print("Read in FIMO results ... ")
        fimo_hits_list = benchlib.read_in_fimo_results(fimo_res_tsv,
                                                       seq_based=True)

        c_fimo_hits = len(fimo_hits_list)
        print("# of FIMO motif hits:", c_fimo_hits)


    """
    =========================================
    RUN STRUCTURE MOTIF SEARCH WITH CMSEARCH.
    =========================================

    """
    cmsearch_hits_list = []

    if str_rbps_dic:
        
        print("Output covariance models to .cm ... ")
        benchlib.output_cm_blocks_to_file(str_motif_blocks_dic, loaded_motif_ids_dic, str_motifs_cm)

        # Run cmsearch.
        print("Run cmsearch ... ")
        benchlib.run_cmsearch(filtered_seqs_fa, str_motifs_cm, cmsearch_res_txt,
                        error_check=False,
                        call_dic=call_dic,
                        params="-g --tformat fasta --toponly --incT 1 -T 1 --default")  # or add --anytrunc and remove --g
        # Read in hits.
        print("Read in cmsearch results ... ")
        cmsearch_hits_list, c_cms_hits = benchlib.read_in_cmsearch_results(cmsearch_res_txt,
                                                                           seq_based=True,
                                                                           check=True)

        print("# of cmsearch motif hits:", c_cms_hits)


    """
    Store for each RBP the regions with motif hits (and hit counts), using
    dictionary of dictionaries regions_with_motifs_dic.
    This tells us, how many input regions have motif hits, separated by RBP.
    Also store for each RBP the unique motif hit regions (and hit counts), using
    dictionary of dictionaries unique_motifs_dic.

    regions_with_motifs_dic:
        Dictionary of dictionaries, format:
        {rbp_id1 -> {'region1': motif_c_region1, 'region2': motif_c_region2}, rbp_id2 -> {'region1': motif_c_region1}}
    unique_motifs_dic:
        Dictionary of dictionaries, format:
        {rbp_id1 -> {'motif_region1': c_motif_region1, 'motif_region2': c_motif_region2}, rbp_id2 -> .. }

    """

    regions_with_motifs_dic = {}
    unique_motifs_dic = {}

    # Store regions with sequence motifs.
    for fh in fimo_hits_list:

        rbp_id = id2name_dic[fh.motif_id]

        if rbp_id in regions_with_motifs_dic:
            # fh.seq_name : FASTA header (== --in genomic sequence region).
            if fh.seq_name in regions_with_motifs_dic[rbp_id]:
                regions_with_motifs_dic[rbp_id][fh.seq_name] += 1
            else:
                regions_with_motifs_dic[rbp_id][fh.seq_name] = 1
        else:
            regions_with_motifs_dic[rbp_id] = {}
            regions_with_motifs_dic[rbp_id][fh.seq_name] = 1

        fh_str = repr(fh) # genomic motif region string.

        # Unique motif regions for each RBP.
        if rbp_id in unique_motifs_dic:
            if fh_str in unique_motifs_dic[rbp_id]:
                unique_motifs_dic[rbp_id][fh_str] += 1
            else:
                unique_motifs_dic[rbp_id][fh_str] = 1
        else:
            unique_motifs_dic[rbp_id] = {}
            unique_motifs_dic[rbp_id][fh_str] = 1

        # Output motif stats.


    # Store regions with structure motifs.
    for cmsh in cmsearch_hits_list:

        rbp_id = id2name_dic[cmsh.motif_id]

        if rbp_id in regions_with_motifs_dic:
            # cmsh.seq_name : FASTA header (== --in genomic sequence region).
            if cmsh.seq_name in regions_with_motifs_dic[rbp_id]:
                regions_with_motifs_dic[rbp_id][cmsh.seq_name] += 1
            else:
                regions_with_motifs_dic[rbp_id][cmsh.seq_name] = 1
        else:
            regions_with_motifs_dic[rbp_id] = {}
            regions_with_motifs_dic[rbp_id][cmsh.seq_name] = 1

        cmsh_str = repr(cmsh) # genomic motif region string.

        # Unique motif regions for each RBP.
        if rbp_id in unique_motifs_dic:
            if cmsh_str in unique_motifs_dic[rbp_id]:
                unique_motifs_dic[rbp_id][cmsh_str] += 1
            else:
                unique_motifs_dic[rbp_id][cmsh_str] = 1
        else:
            unique_motifs_dic[rbp_id] = {}
            unique_motifs_dic[rbp_id][cmsh_str] = 1

    """
    Store infos for each RBP in RBP class.

    search_rbps_dic[rbp_id] = rbp_class
    RBP class arguments:
            name: str,
            seq_motif_ids = None,
            str_motif_ids = None,
            c_hit_reg = 0, # # regions with motif hits.
            perc_hit_reg = 0.0, # % hit regions over all regions (i.e. how many input regions contain >= 1 RBP motif).
            c_motif_hits = 0, # # motif hits.
            c_uniq_motif_hits = 0, # # unique motif hits.
            c_uniq_motif_nts = 0, # # unique motif nucleotides.
            perc_uniq_motif_nts_eff_reg = 0.0, # % unique motif nts over effective region length.
            perc_uniq_motif_nts_cal_reg = 0.0, # % unique motif nts over called region length.
            uniq_motif_hits_eff_1000nt = 0.0, # unique motif hits per effective 1000 nt.
            uniq_motif_hits_cal_1000nt = 0.0, # unique motif hits per called 1000 nt.
            ks_pval = 1.0, # Kolmogorov-Smirnov (KS) statistic p-value (are higher scoring sites enriched with motifs).
            ks_stat = 0.0,
            organism: Optional[str] = None

    Number of sequences for FIMO / cmsearch: 
    c_regions

    """
    # Set number of no-hit regions.
    for rbp_id in search_rbps_dic:
        search_rbps_dic[rbp_id].c_no_hit_reg = c_regions

    for rbp_id in regions_with_motifs_dic:
        # Number of --in regions with RBP motif hits.
        c_hit_reg = len(regions_with_motifs_dic[rbp_id])

        # Number of motif hits on --in regions in total.
        c_motif_hits = 0
        for reg_id in regions_with_motifs_dic[rbp_id]:
            c_motif_hits += regions_with_motifs_dic[rbp_id][reg_id]
        search_rbps_dic[rbp_id].c_hit_reg = c_hit_reg
        search_rbps_dic[rbp_id].c_no_hit_reg = c_regions - c_hit_reg
        search_rbps_dic[rbp_id].c_motif_hits = c_motif_hits

        # % hit regions over all regions (i.e. how many input regions contain >= 1 RBP motif).
        search_rbps_dic[rbp_id].perc_hit_reg = (search_rbps_dic[rbp_id].c_hit_reg / c_regions) * 100

    """
    Get unique motif hits.

    unique_motifs_dic:
        Dictionary of dictionaries, format:
        {rbp_id1 -> {'motif_region1': c_motif_region1, 'motif_region2': c_motif_region2}, rbp_id2 -> .. }
    """

    for rbp_id in unique_motifs_dic:
        c_uniq_motif_hits = len(unique_motifs_dic[rbp_id])
        search_rbps_dic[rbp_id].c_uniq_motif_hits = c_uniq_motif_hits
        # Store individual motif unique hits.
        for motif_str_repr in unique_motifs_dic[rbp_id]:
            motif_id = benchlib.get_motif_id_from_str_repr(motif_str_repr)
            idx = motif_id2idx_dic[motif_id]
            if id2type_dic[motif_id] == "meme_xml":
                search_rbps_dic[rbp_id].seq_motif_hits[idx] += 1
            else:
                search_rbps_dic[rbp_id].str_motif_hits[idx] += 1

    """
    Number of motif nucleotides over called + effective region size.

    """

    # Effective region size same as called for sequences (searchseq).
    eff_reg_size = called_reg_size

    print("Calculate effective motif region sizes for each RBP ... ")
    for rbp_id in unique_motifs_dic:
        # Output unique motif hit regions (sequence or structure) to BED for RBP rbp_id.
        benchlib.output_motif_hits_to_bed(rbp_id, unique_motifs_dic, out_tmp_bed,
                                          one_based_start=True)
        # Calculate effective motif region size.
        eff_motif_reg_size = benchlib.get_uniq_gen_size(out_tmp_bed)

        # Number of unique motif nucleotides.
        search_rbps_dic[rbp_id].c_uniq_motif_nts = eff_motif_reg_size
        # % unique motif nts over effective region length.
        search_rbps_dic[rbp_id].perc_uniq_motif_nts_eff_reg = (eff_motif_reg_size / eff_reg_size) * 100
        # % unique motif nts over called region length.
        search_rbps_dic[rbp_id].perc_uniq_motif_nts_cal_reg = (eff_motif_reg_size / called_reg_size) * 100
        # Number of unique motif hits per effective 1000 nt.
        search_rbps_dic[rbp_id].uniq_motif_hits_eff_1000nt  = search_rbps_dic[rbp_id].c_uniq_motif_hits / (eff_reg_size / 1000)
        # Number of unique motif hits per called 1000 nt.
        search_rbps_dic[rbp_id].uniq_motif_hits_cal_1000nt  = search_rbps_dic[rbp_id].c_uniq_motif_hits / (called_reg_size / 1000)


    print("# --in sequences for motif search:", c_regions)
    print("Total sequence length:            ", called_reg_size)


    # """
    # Some motif enrichment tests.

    # Kolmogorov-Smirnov test:
    # conda install -c conda-forge scipy
    # from scipy.stats import ks_2samp
    # scipy.stats.ks_2samp()
    # https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.ks_2samp.html
    # Performs the two-sample Kolmogorov-Smirnov test for goodness of fit.    
    # This test compares the underlying continuous distributions F(x) and G(x) of 
    # two independent samples. See Notes for a description of the available null 
    # and alternative hypotheses.

    # Changing log2 FC to FC results in same p-values ...

    # alternative: two-sided, greater, less
    
    # Alternatively:
    # Wilcoxon signed-rank test:
    # https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.wilcoxon.html
    # alternative: two-sided, greater, less
    # This however needs same input sizes (x,y)
    # Alternatively, use Wilcoxon rank-sum test (Mann-Whitney U test)

    
    # """

    # # print("Calculate Kolmogorov-Smirnov (KS) statistics ... ")
    # print("Calculate Wilcoxon rank-sum test statistics ... ")

    # # Check if all scores same (e.g. 0).
    # reg_scores_dic = {}
    # for reg_id in reg2sc_dic:
    #     reg_scores_dic[reg2sc_dic[reg_id]] = 1
    # if len(reg_scores_dic) == 1:
    #     print("WARNING: all site scores identical. Reported p-values meaningless! (i.e., equal 1.0)")

    # wc_pval_dic = {}
    # for rbp_id in regions_with_motifs_dic:
    #     hit_reg_scores = []
    #     non_hit_reg_scores = []
    #     seen_ids_dic = {}
    #     # CHECK?
    #     for reg_id in reg2sc_dic:
    #         reg_sc = reg2sc_dic[reg_id]  # float value.

    #         # If --unstranded, count regions only once as hit or no hit.
    #         if args.unstranded and not args.unstranded_ct:
    #             core_id = benchlib.reg_get_core_id(reg_id)
    #             reg_id1 = core_id + "(+)"
    #             reg_id2 = core_id + "(-)"
    #             if core_id not in seen_ids_dic:
    #                 if reg_id1 in regions_with_motifs_dic[rbp_id] or reg_id2 in regions_with_motifs_dic[rbp_id]:
    #                     hit_reg_scores.append(reg_sc)
    #                 else:
    #                     non_hit_reg_scores.append(reg_sc)
    #                 seen_ids_dic[core_id] = 1

    #         else:
    #             if reg_id in regions_with_motifs_dic[rbp_id]:
    #                 hit_reg_scores.append(reg_sc)
    #             else:
    #                 non_hit_reg_scores.append(reg_sc)

    #     # print("rbp_id:", rbp_id)
    #     # print("hit_reg_scores:", hit_reg_scores)
    #     # print("non_hit_reg_scores:", non_hit_reg_scores)
    #     # print("# hit regions:    ", len(hit_reg_scores))
    #     # print("# non-hit regions:", len(non_hit_reg_scores))

    #     # Calculate the KS statistic and p-value
    #     # ks_stat, ks_pval = ks_2samp(hit_reg_scores, non_hit_reg_scores, alternative="less")

    #     wc_pval = 1.0
    #     # In case no regions without motif hits.
    #     if not non_hit_reg_scores:
    #         print("WARNING: all input regions contain %s motifs. Adding dummy scores (median) ... " %(rbp_id))
    #         dummy_val = statistics.median(hit_reg_scores)
    #         hit_reg_scores.append(dummy_val)
    #         non_hit_reg_scores.append(dummy_val)

    #     # Wilcoxon rank-sum test (Mann-Whitney U test).
    #     if unique_motifs_dic[rbp_id]:
    #         wc_stat, wc_pval = mannwhitneyu(hit_reg_scores, non_hit_reg_scores, alternative="greater")
    #         # wc_stat_less, wc_pval_less = mannwhitneyu(hit_reg_scores, non_hit_reg_scores, alternative="less")

    #         #print("hit_reg_scores:", hit_reg_scores)
    #         #print("non_hit_reg_scores:", non_hit_reg_scores)
    #         # search_rbps_dic[rbp_id].ks_pval = ks_pval
    #         search_rbps_dic[rbp_id].wc_pval = wc_pval
    #         # search_rbps_dic[rbp_id].wc_pval_less = wc_pval_less
    #         wc_pval_dic[rbp_id] = wc_pval

    #     # print("KS p-value (%s):" %(rbp_id), p_value)


    # # Print out RBPs sorted by Wilcoxon p-value.
    # sorted_wc_pval_dic = dict(sorted(wc_pval_dic.items(), key=lambda item: item[1], reverse=False))
    # print("Compact hit stats (RBP ID, # unique hits, Wilcoxon p-value):")
    # for rbp_id, p_value in sorted_wc_pval_dic.items():
    #     # print("KS p-value (%s):" %(rbp_id), p_value)
    #     # print(rbp_id, ":", p_value)
    #     c_hits = search_rbps_dic[rbp_id].c_uniq_motif_hits
    #     # ks_pval = search_rbps_dic[rbp_id].ks_pval
    #     # wc_pval_less = search_rbps_dic[rbp_id].wc_pval_less
    #     # print("RBP:", rbp_id, "# hits:", c_uniq_motif_hits, "KS p-value:", p_value)
    #     # print("%s\t%i\t%s\t%s" %(rbp_id, c_hits, str(p_value), str(wc_pval_less)))
    #     print("%s\t%i\t%s" %(rbp_id, c_hits, str(p_value)))
    # print("")



    """
    Output RBP hit stats (ie one row per RBP).

    Output clowns:
    rbp_id
    c_regions
    called_reg_size
    effective_reg_size
    c_reg_with_hits
    perc_reg_with_hits
    c_motif_hits
    c_uniq_motif_hits
    c_uniq_motif_nts
    perc_uniq_motif_nts_cal_reg
    perc_uniq_motif_nts_eff_reg
    uniq_motif_hits_cal_1000nt
    uniq_motif_hits_eff_1000nt
    wc_pval
    seq_motif_ids
    seq_motif_hits
    str_motif_ids
    str_motif_hits

    """

    rbp_list = []

    OUTSTATS = open(rbp_stats_out, "w")
    rbp_stats_header = "data_id\tmethod_id\trun_id\tmotif_db\trbp_id\tc_regions\tmean_reg_len\tmedian_reg_len\tmin_reg_len\tmax_reg_len\t"
    rbp_stats_header += "called_reg_size\teffective_reg_size\tc_reg_with_hits\tperc_reg_with_hits\t"
    rbp_stats_header += "c_motif_hits\tc_uniq_motif_hits\tc_uniq_motif_nts\tperc_uniq_motif_nts_cal_reg\tperc_uniq_motif_nts_eff_reg\tuniq_motif_hits_cal_1000nt\t"
    rbp_stats_header += "uniq_motif_hits_eff_1000nt\twc_pval\tseq_motif_ids\tseq_motif_hits\tstr_motif_ids\tstr_motif_hits\tinternal_id\n"
    OUTSTATS.write(rbp_stats_header)

    for rbp_id in search_rbps_dic:

        # print(search_rbps_dic[rbp_id].__dict__)
        rbp_list.append(rbp_id)

        motif_db_out = loaded_rbps_dic[rbp_id]

        c_reg_with_hits = search_rbps_dic[rbp_id].c_hit_reg
        perc_reg_with_hits = search_rbps_dic[rbp_id].perc_hit_reg
        c_motif_hits = search_rbps_dic[rbp_id].c_motif_hits
        c_uniq_motif_hits = search_rbps_dic[rbp_id].c_uniq_motif_hits
        c_uniq_motif_nts = search_rbps_dic[rbp_id].c_uniq_motif_nts
        perc_uniq_motif_nts_cal_reg = search_rbps_dic[rbp_id].perc_uniq_motif_nts_cal_reg
        perc_uniq_motif_nts_eff_reg = search_rbps_dic[rbp_id].perc_uniq_motif_nts_eff_reg
        uniq_motif_hits_cal_1000nt = search_rbps_dic[rbp_id].uniq_motif_hits_cal_1000nt
        uniq_motif_hits_eff_1000nt = search_rbps_dic[rbp_id].uniq_motif_hits_eff_1000nt
        wc_pval = search_rbps_dic[rbp_id].wc_pval
        internal_id = search_rbps_dic[rbp_id].internal_id

        seq_motif_hits = ",".join(str(hc) for hc in search_rbps_dic[rbp_id].seq_motif_hits)
        str_motif_hits = ",".join(str(hc) for hc in search_rbps_dic[rbp_id].str_motif_hits)
        seq_motif_ids = ",".join(search_rbps_dic[rbp_id].seq_motif_ids)
        str_motif_ids = ",".join(search_rbps_dic[rbp_id].str_motif_ids)
        if not seq_motif_hits:
            seq_motif_hits = "-"
        if not str_motif_hits:
            str_motif_hits = "-"
        if not seq_motif_ids:
            seq_motif_ids = "-"
        if not str_motif_ids:
            str_motif_ids = "-"

        row_str = args.data_id + "\t"
        row_str += args.method_id + "\t"
        row_str += run_id + "\t"
        row_str += motif_db_out + "\t"
        row_str += rbp_id + "\t"

        row_str += str(c_regions) + "\t"

        row_str += str(reg_len_mean) + "\t"
        row_str += str(reg_len_median) + "\t"
        row_str += str(reg_len_min) + "\t"
        row_str += str(reg_len_max) + "\t"

        row_str += str(called_reg_size) + "\t"
        row_str += str(eff_reg_size) + "\t"

        row_str += str(c_reg_with_hits) + "\t"
        row_str += str(perc_reg_with_hits) + "\t"

        row_str += str(c_motif_hits) + "\t"
        row_str += str(c_uniq_motif_hits) + "\t"
        row_str += str(c_uniq_motif_nts) + "\t"
        row_str += str(perc_uniq_motif_nts_cal_reg) + "\t"
        row_str += str(perc_uniq_motif_nts_eff_reg) + "\t"
        row_str += str(uniq_motif_hits_cal_1000nt) + "\t"
        row_str += str(uniq_motif_hits_eff_1000nt) + "\t"
        row_str += str(wc_pval) + "\t"
        row_str += seq_motif_ids + "\t"
        row_str += seq_motif_hits + "\t"
        row_str += str_motif_ids + "\t"
        row_str += str_motif_hits + "\t"
        row_str += internal_id + "\n"

        OUTSTATS.write(row_str)

    OUTSTATS.close()

    """
    Region ID list.
    
    """
    reg_ids_list = []
    reg_ids_dic = {}
    for seq_id, seq in sorted(in_seqs_dic.items()):
        reg_ids_list.append(seq_id)
        reg_ids_dic[seq_id] = 1

    rbp_list.sort()
    len_rbp_list = len(rbp_list)
    # Store rbp_id -> for each region if hit: 1, else: 0, i.e.: [1,0,0,0,0]
    reg_hits_dic = {}
    add_count = False # Add # of motif hits in region or just add 1 (if False)

    # RBP ID to index mapping.
    rbp2idx_dic = {}
    idx2rbp_dic = {}
    print("Get RBP region occupancies ... ")
    for idx, rbp_id in enumerate(rbp_list):
        rbp2idx_dic[rbp_id] = idx
        idx2rbp_dic[idx] = rbp_id
        # Region has hits yes(1)/no(0).
        hit_list = []
        for reg_id in reg_ids_list:
            if rbp_id in regions_with_motifs_dic and reg_id in regions_with_motifs_dic[rbp_id]:
                if add_count:
                    hit_list.append(regions_with_motifs_dic[rbp_id][reg_id])
                else:
                    hit_list.append(1)
            else:
                hit_list.append(0)
        reg_hits_dic[rbp_id] = hit_list

    """
    Output occupancies.

    reg_hits_dic[rbp_id] = [0,1,0,0, ...]
    reg_ids_list = [reg_id1, reg_id2, ... ]

    rbp2regidx_dic:
        # rbp_id -> 0-based indexes of occupied regions, e.g. [0, 3, 12, 88, 114] 

    """
    rbp2regidx_dic = {}
    OUTOCC = open(rbp_reg_occ_table_out,"w")

    occ_header = "#region_id \ rbp_id"
    for rbp_id, hit_list in sorted(reg_hits_dic.items()):
        occ_header += "\t%s" %(rbp_id)
        rbp2regidx_dic[rbp_id] = []
        for idx, label in enumerate(hit_list):
            if label:  # if occupied (i.e. 1-label).
                rbp2regidx_dic[rbp_id].append(idx)
    OUTOCC.write("%s\n" %(occ_header))
    for idx, reg_id in enumerate(reg_ids_list):
        occ_row = "%s" %(reg_id)
        for rbp_id, hit_list in sorted(reg_hits_dic.items()):
            occ_row += "\t%i" %(hit_list[idx])
        OUTOCC.write("%s\n" %(occ_row))
    OUTOCC.close()

    """
    Store RBP binding information for each input region.
    Format region_rbp_binds_dic:
    region_id -> [False, True, False ... ] 
    with list number of RBP IDs (len_rbp_list), alphabetically sorted.
    Format region_rbp_motif_pos_dic:
    Region ID -> "motif_id,start_1based,end_1based,p_value/-(bit_score)"
    E.g.
    region_rbp_motif_pos_dic["reg1"] = ["rbp1_m1,98,102,0.01", "rbp1_m1,110,115,0.1", "rbp1_m2,110,115,0.05", "rbp2_m1,115,120,0.02", "rbp3_m1,90,95,0.01"]

    """
    region_rbp_binds_dic = {}
    region_rbp_motif_pos_dic = {}

    for reg_id in in_seqs_dic:
        # assert reg_id in reg2sc_dic, "region ID \"%s\" from in_seqs_dic not found in reg2sc_dic" %(reg_id)
        region_rbp_binds_dic[reg_id] = [False]*len_rbp_list
        region_rbp_motif_pos_dic[reg_id] = []


    """
    Output motif region stats (1 row for each motif hit).
    Report ALL motif hits,
    plus report how many times one genomic motif hit occurs (uniq_count). 

    """

    OUTSTATS = open(motif_stats_out,"w")

    motif_stats_header = "data_id\tmethod_id\trun_id\tmotif_db\tregion_id\trbp_id\tmotif_id\tchr_id\tgen_s\tgen_e\tstrand\tregion_s\tregion_e\tregion_len\t"
    motif_stats_header += "uniq_count\tfimo_score\tfimo_pval\tcms_score\tcms_eval\tinternal_id\n"
    OUTSTATS.write(motif_stats_header)

    # Unique motif regions BED.
    motif_reg_dic = {}

    # hit_id = "%s:%s-%s(%s),%s" %(cols[7], cols[8], cols[9], cols[10], cols[6])

    for fh in fimo_hits_list:

        rbp_id = id2name_dic[fh.motif_id]
        region_id = fh.seq_name
        region_len = len(in_seqs_dic[region_id])
        # genomic motif region string.
        fh_str = repr(fh)
        uniq_count = unique_motifs_dic[rbp_id][fh_str]
        # Store binding info of RBP in region.
        rbp_idx = rbp2idx_dic[rbp_id]

        # Motif hit string.
        motif_str = "%s,%i,%i,%s" %(fh.motif_id, fh.start, fh.end, str(fh.pval))
        # # Center position of motif hit.
        # motif_hit_s = fh.start - 1
        # motif_hit_e = fh.end
        # center_pos = benchlib.get_center_position(motif_hit_s, motif_hit_e)        

        region_rbp_binds_dic[region_id][rbp_idx] = True
        region_rbp_motif_pos_dic[region_id].append(motif_str)

        motif_db_out = loaded_motif_ids_dic[fh.motif_id]

        internal_id = search_rbps_dic[rbp_id].internal_id

        # Store motif hit as BED.
        hit_id = "%s:%s-%s(%s),%s" %(fh.chr_id, str(fh.start), str(fh.end), fh.strand, fh.motif_id)
        if hit_id not in motif_reg_dic:
            bed_row = "%s\t%i\t%i\t%s,%s;%i;%s,%s\t0\t%s\t%s\t%s\t-1.0\t-1.0" %(fh.chr_id, fh.start-1, fh.end, rbp_id, fh.motif_id, uniq_count, args.method_id, args.data_id, fh.strand, str(fh.score), str(fh.pval))
            motif_reg_dic[hit_id] = bed_row

        row_str = args.data_id + "\t"
        row_str += args.method_id + "\t"
        row_str += run_id + "\t"
        row_str += motif_db_out + "\t"
        row_str += region_id + "\t"
        row_str += rbp_id + "\t"
        row_str += fh.motif_id + "\t"
        row_str += fh.chr_id + "\t"
        row_str += str(fh.start) + "\t"  # 1-based.
        row_str += str(fh.end) + "\t"
        row_str += fh.strand + "\t"
        row_str += str(fh.seq_s) + "\t"  # 1-based.
        row_str += str(fh.seq_e) + "\t"
        row_str += str(region_len) + "\t"
        row_str += str(uniq_count) + "\t"
        row_str += str(fh.score) + "\t"
        row_str += str(fh.pval) + "\t"
        row_str += "-\t"
        row_str += "-\t"
        row_str += internal_id + "\n"

        OUTSTATS.write(row_str)

    for cmsh in cmsearch_hits_list:

        rbp_id = id2name_dic[cmsh.motif_id]
        region_id = cmsh.seq_name
        region_len = len(in_seqs_dic[region_id])
        # genomic motif region string.
        cmsh_str = repr(cmsh) 
        uniq_count = unique_motifs_dic[rbp_id][cmsh_str]
        # Store binding info of RBP in region.
        rbp_idx = rbp2idx_dic[rbp_id]

        # Motif hit string.
        motif_str = "%s,%i,%i,%s" %(cmsh.motif_id, cmsh.start, cmsh.end, str(-1*cmsh.score))
        # # Center position of motif hit.
        # motif_hit_s = cmsh.start - 1
        # motif_hit_e = cmsh.end
        # center_pos = benchlib.get_center_position(motif_hit_s, motif_hit_e)
        
        region_rbp_binds_dic[region_id][rbp_idx] = True
        region_rbp_motif_pos_dic[region_id].append(motif_str)

        motif_db_out = loaded_motif_ids_dic[cmsh.motif_id]

        internal_id = search_rbps_dic[rbp_id].internal_id

        # Store motif hit as BED.
        hit_id = "%s:%s-%s(%s),%s" %(cmsh.chr_id, str(cmsh.start), str(cmsh.end), cmsh.strand, cmsh.motif_id)
        if hit_id not in motif_reg_dic:
            bed_row = "%s\t%i\t%i\t%s,%s;%i;%s,%s\t0\t%s\t%s\t%s\t-1.0\t-1.0" %(cmsh.chr_id, cmsh.start-1, cmsh.end, rbp_id, cmsh.motif_id, uniq_count, args.method_id, args.data_id, cmsh.strand, str(cmsh.score), str(cmsh.e_value))
            motif_reg_dic[hit_id] = bed_row

        row_str = args.data_id + "\t"
        row_str += args.method_id + "\t"
        row_str += run_id + "\t"
        row_str += motif_db_out + "\t"
        row_str += region_id + "\t"
        row_str += rbp_id + "\t"
        row_str += cmsh.motif_id + "\t"
        row_str += cmsh.chr_id + "\t"
        row_str += str(cmsh.start) + "\t"
        row_str += str(cmsh.end) + "\t"
        row_str += cmsh.strand + "\t"
        row_str += str(cmsh.seq_s) + "\t"
        row_str += str(cmsh.seq_e) + "\t"
        row_str += str(region_len) + "\t"
        row_str += str(uniq_count) + "\t"
        row_str += "-\t"
        row_str += "-\t"
        row_str += str(cmsh.score) + "\t"
        row_str += str(cmsh.e_value) + "\t"
        row_str += internal_id + "\n"
        #print("region_id:", region_id)
        #print("evalue:", cmsh.e_value)
        #print(row_str)

        OUTSTATS.write(row_str)

    OUTSTATS.close()

    """
    Output motif hits as BED.
    """

    OUTBED = open(motif_hits_bed_out,"w")
    for hit_id in motif_reg_dic:
        OUTBED.write("%s\n" %(motif_reg_dic[hit_id]))
    OUTBED.close()



    """
    Motif plots and motif hit statistics HTML.

    """
    html_motif_plots_out = args.out_folder + "/" + "motif_plots.rbpbench_searchseq.html"
    if args.plot_abs_paths:
        html_motif_plots_out = os.path.abspath(args.out_folder) + "/" + "motif_plots.rbpbench_searchseq.html"

    if args.plot_motifs:
        
        print("Generate motif plots HTML ... ")
        
        plots_subfolder = "html_motif_plots"
        benchlib_path = os.path.dirname(benchlib.__file__)

        benchlib.search_generate_html_motif_plots(search_rbps_dic, seq_motif_blocks_dic, 
                                         str_motif_blocks_dic, args.out_folder, 
                                         benchlib_path, loaded_motif_ids_dic,
                                         motif_db_str=motif_db_str,
                                         sort_js_mode=args.sort_js_mode,
                                         html_report_out=html_motif_plots_out,
                                         plot_abs_paths=args.plot_abs_paths,
                                         rbpbench_mode="searchseq",
                                         plots_subfolder=plots_subfolder)


    """
    Output parameter settings.

    """
    # Output mode settings.
    print("Output parameter settings ... ")
    SETOUT = open(settings_file, "w")
    for arg in vars(args):
        SETOUT.write("%s\t%s\n" %(arg, str(getattr(args, arg))))
    for call in call_dic:
        SETOUT.write("%s\t%s\n" %(call, call_dic[call]))
    SETOUT.close()

    """
    Take out the trash.

    """
    print("Delete .tmp files ... ")
    if os.path.exists(out_tmp_bed):
        os.remove(out_tmp_bed)
    if os.path.exists(cmstat_tmp_out):
        os.remove(cmstat_tmp_out)


    """
    Inform about outputs.

    """
    print("")
    print("OUTPUT FILES")
    print("============")
    print("")
    print("Run parameter settings:\n%s" %(settings_file))
    # print("Co-occurrence p-values for each RBP pair .tsv:\n%s" %(con_res_out_tsv))
    # print("Filtered input regions .bed:\n%s" %(filtered_sites_bed))
    print("Filtered input sequences .fa:\n%s" %(filtered_seqs_fa))
    print("Motif hits .bed:\n%s" %(motif_hits_bed_out))
    print("RBP region occupancies .tsv:\n%s" %(rbp_reg_occ_table_out))
    print("RBP hit stats .tsv:\n%s" %(rbp_stats_out))
    print("Motif hit stats .tsv:\n%s" %(motif_stats_out))
    # if reg_annot_table_file is not None:
    #     print("Region annotations .tsv:\n%s" %(reg_annot_table_file))
    if args.plot_motifs:
        print("Motif plots and hit statistics .html:\n%s" %(html_motif_plots_out))
    # if args.report:
    #     print("Search report .html:\n%s" %(html_report_out))
    print("")


################################################################################

def main_searchlong(args):
    """
    Motif search in long genomic regions.



    """

    print("Running for you in SEARCHLONG mode ... ")

    assert os.path.exists(args.in_file), "--in file \"%s\" not found" % (args.in_file)

    if args.tr_list:
        assert args.in_gtf, "set --tr-list requires --gtf GTF file"
    assert benchlib.boundary_check(args.gtf_feat_min_overlap, 1E-9, 1.0), "set --gtf-feat-min-overlap expected to be >= 1E-9 and <= 1.0"
    if args.in_gtf:
        assert args.plot_motifs, "set --gtf requires --plot-motifs"

    # Is MEME >= v5 installed?
    if not args.meme_disable_check:
        assert benchlib.is_tool("meme"), "meme not in PATH"
        check, meme_version = benchlib.check_tool_version("meme -version", "5.0")
        assert check, "RBPBench requires meme version >= 5.0 (installed version: %s)" %(meme_version)

    # Check if MEME version is >= 5.5.4 (need to add fimo --no-pgc option to produce same results!).
    fimo_params = "--norc --verbosity 1 --skip-matched-sequence --text"
    if not args.meme_disable_check:
        check, meme_version = benchlib.check_tool_version("meme -version", "5.5.4")
        if check:
            fimo_params = "--norc --verbosity 1 --skip-matched-sequence --text --no-pgc"
    if args.meme_no_pgc:
        fimo_params = "--norc --verbosity 1 --skip-matched-sequence --text --no-pgc"

    # Regex check.
    if args.regex:
        assert benchlib.is_valid_regex(args.regex), "given --regex \"%s\" is not a valid regular expression. Please provide valid expression" % (args.regex)

    """
    Library path.
    """
    benchlib_path = os.path.dirname(benchlib.__file__)
    db_path = benchlib_path + "/content"

    """
    FIMO nt frequencies.
    """
    fimo_freqs_file = db_path + "/fimo_nt_freqs.txt"
    if args.fimo_nt_freqs:
        fimo_freqs_file = args.fimo_nt_freqs
    assert os.path.exists(fimo_freqs_file), "set FIMO nucleotide frequencies file \"%s\" not found" % (fimo_freqs_file)

    """
    Motif database.
    """
    seq_motifs_db_file, str_motifs_db_file, rbp2ids_file, motif_db_str = specify_motif_db(args.motif_db, 
                                                                            db_path=db_path)
    # Custom motif database: folder given.
    if args.custom_db:
        assert not args.custom_db_meme_xml, "--custom-db folder set incompatible with --custom-db-meme-xml. Provide custom motif database either via folder (--custom-db) or as single files"
        assert not args.custom_db_cm, "--custom-db folder set incompatible with --custom-db-cm. Provide custom motif database either via folder (--custom-db) or as single files"
        assert not args.custom_db_info, "--custom-db folder set incompatible with --custom-db-info. Provide custom motif database either via folder (--custom-db) or as single files"
        seq_motifs_db_file, str_motifs_db_file, rbp2ids_file = specify_custom_motif_db(args.custom_db)
        motif_db_str = args.custom_db_id
    # Custom motif database: single files given.
    if args.custom_db_meme_xml or args.custom_db_cm or args.custom_db_info:
        motif_db_str = args.custom_db_id
        assert not args.custom_db, "single custom motif database files provided not compatible with --custom-db. Provide custom motif database either via folder (--custom-db) or as single files"
        assert args.custom_db_info, "--custom-db-info needed to define custom motif database"
        rbp2ids_file = args.custom_db_info
        assert args.custom_db_meme_xml or args.custom_db_cm, "--custom-db-meme-xml and/or --custom-db-cm needed to define custom motif database"
        if args.custom_db_meme_xml:
            seq_motifs_db_file = args.custom_db_meme_xml
        else:
            seq_motifs_db_file = ""  # setting to empty string results in os.path.exists -> False.
        if args.custom_db_cm:
            str_motifs_db_file = args.custom_db_cm
        else:
            str_motifs_db_file = ""

    args.motif_db_str = motif_db_str

    """
    Get ID mappings

    name2ids_dic:
    RBP name -> motif IDs mapping
    id2type_dic:
    motif ID -> motif type (cm, meme_xml)
    id2org_dic (ignore for now):
    motif ID -> organism ID (so far only "human")

    """
    name2ids_dic, id2type_dic = benchlib.get_rbp_id_mappings(rbp2ids_file)
    # Motif ID -> RBP name (== RBP ID) mapping.
    id2name_dic = {}
    for rbp_id in name2ids_dic:
        for motif_id in name2ids_dic[rbp_id]:
            id2name_dic[motif_id] = rbp_id

    """
    Get MEME XML database motif blocks dictionary.

    """
    seq_motif_blocks_dic = {}
    if os.path.exists(seq_motifs_db_file):
        seq_motif_blocks_dic = benchlib.read_in_xml_motifs(seq_motifs_db_file,
                                                           empty_check=True)
    for motif_id in seq_motif_blocks_dic:
        assert motif_id in id2name_dic, "MEME XML motif ID %s not found in prior mapping. Please contact developers!" %(motif_id)

    """
    Get covariance model database motif blocks dictionary.

    """
    str_motif_blocks_dic = {}
    if os.path.exists(str_motifs_db_file):
        str_motif_blocks_dic = benchlib.read_in_cm_blocks(str_motifs_db_file, 
                                                          empty_check=True)
    for motif_id in str_motif_blocks_dic:
        assert motif_id in id2name_dic, "Covariance model accession ID %s not found in prior mapping. Please contact developers!" %(motif_id)

    # Remove special chars from run ID.
    args.data_id = benchlib.remove_special_chars_from_str(args.data_id)
    assert args.data_id, "empty string after removing special chars from --data-id. Please provide alphanumeric string for data ID (- or _ are okay as well)"
    args.method_id = benchlib.remove_special_chars_from_str(args.method_id)
    assert args.method_id, "empty string after removing special chars from --method-id. Please provide alphanumeric string for method ID (- or _ are okay as well)"
    # Run ID definition.
    run_id = "run_id"
    if args.run_id:
        run_id = benchlib.remove_special_chars_from_str(args.run_id)
        assert run_id, "empty string after removing special chars from --run-id. Please provide alphanumeric string for run ID (- or _ are okay as well)"

    print("Run ID:     ", run_id)
    print("Data ID:    ", args.data_id)
    print("Method ID:  ", args.method_id)


    """
    Output folders + files.

    """
    if not os.path.exists(args.out_folder):
        os.makedirs(args.out_folder)

    filtered_sites_bed = args.out_folder + "/in_sites.filtered.bed"
    filtered_sites_fa = args.out_folder + "/in_sites.filtered.fa"
    seq_motifs_xml = args.out_folder + "/seq_motifs.xml"
    str_motifs_cm = args.out_folder + "/str_motifs.cm"
    fimo_res_tsv = args.out_folder + "/fimo_results.tsv"
    cmsearch_res_txt = args.out_folder + "/cmsearch_results.txt"

    rbp_stats_out = args.out_folder + "/rbp_hit_stats.tsv"
    motif_stats_out = args.out_folder + "/motif_hit_stats.tsv"
    # con_res_out_tsv = args.out_folder + "/contingency_table_results.tsv"
    settings_file = args.out_folder + "/settings.find_motifs.out"
    # rbp_reg_occ_table_out = args.out_folder + "/rbp_region_occupancies.tsv"

    # Output unique motif hits.
    motif_hits_bed_out = args.out_folder + "/motif_hits.rbpbench_searchlong.bed"

    out_tmp_bed = args.out_folder + "/rbp_motif_hit_regions.tmp.bed"
    cmstat_tmp_out = args.out_folder + "/cmstat_out.tmp.txt"

    # Delete if existing folder.
    if os.path.exists(fimo_res_tsv):
        os.remove(fimo_res_tsv)
    if os.path.exists(cmsearch_res_txt):
        os.remove(cmsearch_res_txt)


    """
    Load RBP data based on --rbps (+ optionally USER data).

    """

    rbp_in_dic = {}
    for rbp_id in args.list_rbps:
        rbp_in_dic[rbp_id] = 1

    # RBPs for motif search.
    loaded_rbps_dic = {}

    # USER set?
    user_motifs = False
    user_rbp_id = False
    if "USER" in rbp_in_dic:
        user_motifs = True
    else:
        assert not args.user_meme_xml, "--user-meme-xml provided but --rbps USER not set. Please add USER to --rbps list to search for user-supplied motifs"
        assert not args.user_cm, "--user-cm provided but --rbps USER not set. Please add USER to --rbps list to search for user-supplied motifs"
        assert not args.user_rbp_id, "--user-rbp-id set but --rbps USER not set. Please add USER to --rbps list to search for user-supplied motifs"

    # If ALL set, load all RBPs (+ optinally USER).
    if "ALL" in rbp_in_dic:
        if len(rbp_in_dic) == 2:
            assert user_motifs, "set --rbps ALL, --rbps ALL USER, or individual RBPs (+ optinally USER) --rbps RBP1 RBP2 ... USER"
        if len(rbp_in_dic) > 2:
            assert False, "set --rbps ALL, --rbps ALL USER, or individual RBPs (+ optinally USER) --rbps RBP1 RBP2 ... USER"
        print("--rbps ALL selected. Loading all database motifs ... ")
        for rbp_id in name2ids_dic:
            loaded_rbps_dic[rbp_id] = motif_db_str

    else:
        # Load individual RBPs.
        for rbp_id in rbp_in_dic:
            if rbp_id != "USER":
                """
                Check if RBP ID in database.
                Suggest similar RBPs based on string similarity (edit distance).

                """
                if rbp_id not in name2ids_dic:
                    db_rbp_list = []
                    for db_rbp_id in name2ids_dic:
                        db_rbp_list.append(db_rbp_id)
                    pair_dist_dic = benchlib.calc_edit_dist_query_list(rbp_id, db_rbp_list)
                    max_c = 10
                    c = 0
                    suggested_rbps = []
                    for key, value in sorted(pair_dist_dic.items(), key=lambda item: item[1], reverse=False):
                        if c >= max_c:
                            break
                        c += 1
                        suggested_rbps.append(key)
                    suggested_rbps_str = ",".join(suggested_rbps)
                    assert False, "provided --rbps ID %s not in internal motif database (%s). Please provide RBP name present in database. Did you mean (any of) the following database ID(s) (top 10 hits based on string similarity): %s ?" %(rbp_id, motif_db_str, suggested_rbps_str)
                # assert rbp_id in name2ids_dic, "provided --rbps ID %s not in internal motif database. Please provide RBP name present in database" %(rbp_id)
                loaded_rbps_dic[rbp_id] = motif_db_str

    # Motif IDs for search.
    loaded_motif_ids_dic = {}
    for rbp_id in loaded_rbps_dic:
        for motif_id in name2ids_dic[rbp_id]:
            loaded_motif_ids_dic[motif_id] = motif_db_str

    """
    Check and load provided USER data.

    """

    if user_motifs:
        print("--rbps USER selected. Check + load provided USER motifs ... ")
        assert args.user_rbp_id, "--rbps USER demands --user-rbp-id to be set to connect the supplied motif(s) with an RBP ID"
        assert args.user_meme_xml or args.user_cm, "--rbps USER requires a provided sequence or structure motif file (via --user-meme-xml AND/OR --user-cm)"

        # Reformat user_rbp_id. 
        user_rbp_id = benchlib.remove_special_chars_from_str(args.user_rbp_id)
        assert user_rbp_id, "empty string after removing special chars from --user-rbp-id. Please provide alphanumeric string for RBP ID (- or _ are okay as well)"

        assert user_rbp_id not in loaded_rbps_dic, "user RBP ID %s already selected from database. Please deselect respective database RBP ID or provide unique user RBP ID via --user-rbp-id" %(user_rbp_id)
        loaded_rbps_dic[user_rbp_id] = "user"
        # In case user_rbp_id in database, reset motif IDs associated to user_rbp_id.
        name2ids_dic[user_rbp_id] = []
        print("RBP ID for user-supplied motifs:", user_rbp_id)

        user_seq_motif_blocks_dic = {}
        if args.user_meme_xml:
            assert os.path.exists(args.user_meme_xml), "--user-meme-xml file \"%s\" not found" % (args.user_meme_xml)
            user_seq_motif_blocks_dic = benchlib.read_in_xml_motifs(args.user_meme_xml, empty_check=False)
            assert user_seq_motif_blocks_dic, "no motifs read in from provided --user-meme-xml. Make sure to supply sequence motifs in MEME XML format!"
            # Check if motif ID already loaded.
            for acc_id in user_seq_motif_blocks_dic:
                assert acc_id not in loaded_motif_ids_dic, "user-supplied MEME XML motif ID %s already selected, i.e., ID is already associated with selected database RBP %s. Please change user motif ID to a unique motif ID or deselect the respective RBP" %(acc_id, id2name_dic[acc_id])
                loaded_motif_ids_dic[acc_id] = "user"
                # Add user to database blocks (overwrite if same ID encountered).
                seq_motif_blocks_dic[acc_id] = user_seq_motif_blocks_dic[acc_id]
                name2ids_dic[user_rbp_id].append(acc_id)
                id2type_dic[acc_id] = "meme_xml"
                id2name_dic[acc_id] = user_rbp_id

        user_str_motif_blocks_dic = {}
        if args.user_cm:
            assert os.path.exists(args.user_cm), "--user-cm file \"%s\" not found" % (args.user_cm)
            # Check for valid format.
            acc_ids_dic = benchlib.check_cm_file(args.user_cm, cmstat_tmp_out, empty_check=False)
            # Read in covariance model blocks.
            user_str_motif_blocks_dic = benchlib.read_in_cm_blocks(args.user_cm)
            for acc_id in acc_ids_dic:
                assert acc_id in user_str_motif_blocks_dic, "accession ID %s not in blocks dictionary. Please contact developers!" %(acc_id)
            # Check if motif ID already loaded.
            for acc_id in user_str_motif_blocks_dic:
                assert acc_id not in loaded_motif_ids_dic, "user-supplied covariance model accession (ACC) ID %s already selected, i.e., ID is already associated with selected database RBP %s. Please change to a unique accession ID or deselect the respective RBP" %(acc_id, id2name_dic[acc_id])
                loaded_motif_ids_dic[acc_id] = "user"
                # Add user to database blocks (overwrite if same ID encountered).
                str_motif_blocks_dic[acc_id] = user_str_motif_blocks_dic[acc_id]
                name2ids_dic[user_rbp_id].append(acc_id)
                id2type_dic[acc_id] = "cm"
                id2name_dic[acc_id] = user_rbp_id

    """
    Check if loaded RBP IDs have motifs.

    """
    for rbp_id in loaded_rbps_dic:
        for motif_id in name2ids_dic[rbp_id]:
            found = 0
            if motif_id in seq_motif_blocks_dic:
                found += 1
            if motif_id in str_motif_blocks_dic:
                found += 1
            assert found, "no motifs loaded for RBP ID \"%s\". Please provide the respective motifs file" %(rbp_id)


    """
    If --regex is set:
    Treat regex as sequence motif / fimo type.
    rbp_id: regex, motif_id: regex, motif_db: regex
    
    """

    regex_id = args.regex_id
    regex = args.regex
    
    if args.regex:

        # Remove , ; from given regex, to avoid motif_id format conflicts.
        regex = benchlib.remove_special_chars_from_str(args.regex,
                                                       reg_ex="[,;]")
        
        assert regex, "empty string after removing special chars from --regex. Please provide a valid regex with DNA letters"

        regex_id = benchlib.remove_special_chars_from_str(args.regex_id)

        assert regex_id, "empty string after removing special chars from --regex-id. Please provide alphanumeric string for regex ID (- or _ are okay as well)"
        assert regex_id not in name2ids_dic, "--regex set but a different RBP ID with name \"%s\" was found. Please provide a different RBP ID or --regex-id" %(regex_id)

        if args.motif_regex_id:
            assert regex_id not in id2type_dic, "--regex set but a different motif ID with name \"%s\" was found. Please provide a different motif ID or --regex-id" %(regex_id)

            id2name_dic[regex_id] = regex_id    # motif_id -> rbp_id
            id2type_dic[regex_id] = "regex"  # motif_id -> motif type string; motif type string can be regex, cm, meme_xml
            loaded_motif_ids_dic[regex_id] = regex_id  # motif_id -> motif_db_str
            name2ids_dic[regex_id] = [regex_id]  # rbp_id -> motif_ids

        else:
            assert regex not in id2type_dic, "--regex set but a different motif ID with name \"%s\" was found. Please provide a different motif ID or use --motif-regex-id" %(regex_id)

            id2name_dic[regex] = regex_id    # motif_id -> rbp_id
            id2type_dic[regex] = "regex"  # motif_id -> motif type string; motif type string can be regex, cm, meme_xml
            loaded_motif_ids_dic[regex] = regex_id  # motif_id -> motif_db_str
            name2ids_dic[regex_id] = [regex]  # rbp_id -> motif_ids

        loaded_rbps_dic[regex_id] = regex_id  # rbp_id -> motif_db_str


    """
    Load RBP data, store in RBP() class.

    """

    # Store motif IDs for search.
    search_rbps_dic = {}
    seq_rbps_dic = {}
    str_rbps_dic = {}
    motif_id2idx_dic = {} # motif ID -> list index.
    args.internal_id = []

    for rbp_id in loaded_rbps_dic:
    
        internal_id = base64.urlsafe_b64encode(os.urandom(6)).decode()
        args.internal_id.append(internal_id)
        rbp = benchlib.RBP(rbp_id, internal_id)

        for motif_id in name2ids_dic[rbp_id]:
        
            assert motif_id in loaded_motif_ids_dic, "motif_id %s not in loaded_motif_ids_dic" %(motif_id)

            if id2type_dic[motif_id] == "meme_xml":
                rbp.seq_motif_ids.append(motif_id)
                motif_id2idx_dic[motif_id] = len(rbp.seq_motif_ids) - 1
                rbp.seq_motif_hits.append(0)
                seq_rbps_dic[rbp_id] = 1
            elif id2type_dic[motif_id] == "regex":
                rbp.seq_motif_ids.append(motif_id)
                motif_id2idx_dic[motif_id] = len(rbp.seq_motif_ids) - 1
                rbp.seq_motif_hits.append(0)
                seq_rbps_dic[rbp_id] = 1
            elif id2type_dic[motif_id] == "cm":
                rbp.str_motif_ids.append(motif_id)
                motif_id2idx_dic[motif_id] = len(rbp.str_motif_ids) - 1
                rbp.str_motif_hits.append(0)
                str_rbps_dic[rbp_id] = 1
            else:
                assert False, "unknown motif type (\"%s\") set for motif_id %s" %(id2type_dic[motif_id], motif_id)

        search_rbps_dic[rbp_id] = rbp


    print("# of RBP IDs for search:    ", len(loaded_rbps_dic))
    print("# of motif IDs for search:  ", len(loaded_motif_ids_dic))

    """
    Get chromosome IDs from --genome.
    """
    print("Get --genome FASTA headers ... ")
    chr_ids_dic = benchlib.get_fasta_headers(args.in_genome)

    """
    Guess chromosome ID style.

    chr_style:
        1: chr1, chr2, ..., chrX, chrM
        2: 1, 2, ... , X, MT

    """
    chr_style = 0  # no changes to chromosome IDs in GTF files.
    
    if "1" in chr_ids_dic:
        assert "chr1" not in chr_ids_dic, "inconsistent chromosome IDs in --genome FASTA file (both chr1 and 1)"
    if "chr1" in chr_ids_dic:
        assert "1" not in chr_ids_dic, "inconsistent chromosome IDs in --genome FASTA file (both chr1 and 1)"
    if "chr1" in chr_ids_dic:
        chr_style = 1
    if "1" in chr_ids_dic:
        chr_style = 2

    """
    Find out what --in file is: BED or transcript IDs list.
    
    """

    search_tr_ids_dic = {}
    in_bed_file = False

    if not benchlib.bed_check_format(args.in_file, asserts=False):

        assert args.in_gtf, "--in file is not a BED file so a GTF file (--gtf) is required for transcript ID mapping"
        search_tr_ids_dic = benchlib.read_ids_into_dic(args.in_file,
                                                       check_dic=False)
        assert search_tr_ids_dic, "no transcript IDs read in from provided --in file. Please provide a valid IDs file (one transcript ID per row)"
        assert not args.tr_list, "--tr-list set but --in file is already a list of transcript IDs. Please provide --in BED file in case of --tr-list"

    else:
        in_bed_file = args.in_file

    """
    If --gtf given, get transcript infos.

    """

    tid2tio_dic = {}
    tr2gid_dic = {}
    tr_types_dic = {}  # Store transcript biotypes in GTF file.

    if args.in_gtf:

        # Get gene infos.
        print("Read in gene features from --gtf ... ")
        
        gid2gio_dic = benchlib.gtf_read_in_gene_infos(args.in_gtf,
                                                      tr2gid_dic=tr2gid_dic,
                                                      tr_types_dic=tr_types_dic,
                                                      check_chr_ids_dic=chr_ids_dic,
                                                      chr_style=chr_style,
                                                      empty_check=False)
        assert gid2gio_dic, "no gene infos read in from --gtf. Please provide a valid/compatible GTF file (e.g. from Ensembl or ENCODE)"
        assert tr2gid_dic, "no transcript -> gene ID mapping read in from --gtf. Please provide a valid/compatible GTF file (e.g. from Ensembl or ENCODE)"
        assert tr_types_dic, "no transcript biotypes read in from --gtf. Please provide a valid/compatible GTF file (e.g. from Ensembl or ENCODE)"

        c_gene_infos = len(gid2gio_dic)
        print("# gene features read in from --gtf:", c_gene_infos)

        if search_tr_ids_dic:
            for tr_id in search_tr_ids_dic:
                assert tr_id in tr2gid_dic, "transcript ID \"%s\" from --in file does not appear in --gtf file. Check if transcript IDs in --gtf include version numbers (change IDs), or provide compatible files" %(tr_id)

        # If --tr-list given.
        tr_ids_dic = {}
        if args.tr_list:
            tr_ids_dic = benchlib.read_ids_into_dic(args.tr_list,
                                                    check_dic=False)
            assert tr_ids_dic, "no IDs read in from provided --tr-list file. Please provide a valid IDs file (one ID per row)"
            for tr_id in tr_ids_dic:
                assert tr_id in tr2gid_dic, "transcript ID \"%s\" from provided --tr-list file does not appear in --gtf file. Please provide compatible files" %(tr_id)
                tr_ids_dic[tr_id] = tr2gid_dic[tr_id]
            print("# of transcript IDs (read in from --tr-list): ", len(tr_ids_dic))
        else:
            if not search_tr_ids_dic:
                # Get most prominent transcripts from gene infos.
                tr_ids_dic = benchlib.select_mpts_from_gene_infos(gid2gio_dic,
                                        basic_tag=False,  # do not be strict (only_tsl=False too).
                                        ensembl_canonical_tag=False,
                                        prior_basic_tag=True,  # Prioritize basic tag transcript.
                                        only_tsl=False)
                assert tr_ids_dic, "most prominent transcript selection from gene infos failed. Please contact developers"
                print("# of transcript IDs (most prominent transcripts): ", len(tr_ids_dic))
            else:
                tr_ids_dic = search_tr_ids_dic  # Only transcript IDs / annotations needed for search.

        # Check exon order (return True if minus strand exon 1 is most downstream, not most upstream, which is the correct way).
        print("Check minus-strand exon order in --gtf ... ")
        correct_min_ex_order = benchlib.gtf_check_exon_order(args.in_gtf)
        if correct_min_ex_order:
            print("Correct order encountered ... ")
        else:
            print("Reverse order encountered ... ")
        # Get transcript infos.
        print("Read in transcript infos from --gtf ... ")
        tid2tio_dic = benchlib.gtf_read_in_transcript_infos(args.in_gtf, 
                                                            tr_ids_dic=tr_ids_dic,
                                                            correct_min_ex_order=correct_min_ex_order,
                                                            chr_style=chr_style,
                                                            empty_check=False)

        assert tid2tio_dic, "no transcript infos read in from --gtf. Please provide a valid/compatible GTF file (e.g. from Ensembl or ENCODE)"

        # (in)sanity checks.
        for tr_id in tr_ids_dic:
            assert tr_id in tid2tio_dic, "transcript ID %s not in tid2tio_dic"
        for tr_id in tid2tio_dic:
            assert tr_id in tr_ids_dic, "transcript ID %s not in tr_ids_dic"

        c_tr_infos = len(tid2tio_dic)
        print("# transcript features read in from --gtf:", c_tr_infos)

        # Output transcript regions as BED file.
        if search_tr_ids_dic:
            print("Output --in transcript IDs as transcript regions to BED ... ")
            in_bed_file = args.out_folder + "/transcript_regions.searchlong.tmp.bed"
            # File handle.
            OUTBED = open(in_bed_file, "w")
            # Output transcript regions.
            for tr_id in search_tr_ids_dic:
                chr_id = tid2tio_dic[tr_id].chr_id
                tr_s = tid2tio_dic[tr_id].tr_s - 1
                tr_e = tid2tio_dic[tr_id].tr_e
                tr_pol = tid2tio_dic[tr_id].tr_pol
                OUTBED.write("%s\t%i\t%i\t%s\t0\t%s\n" %(chr_id, tr_s, tr_e, tr_id, tr_pol))
            OUTBED.close()
        
    """
    Filter / extend --in genomic regions BED file.

    """

    ext_up = 0
    ext_down = 0
    bed_score_col = 5

    # Filter / extend --in BED.
    print("Preprocess --in sites ... ")
    reg2sc_dic = {}  # Used to store region scores for Wilcoxon rank-sum test.
    bed_chr_ids_dic = {}
    reg_stats_dic = benchlib.bed_filter_extend_bed(in_bed_file, filtered_sites_bed,
                                          ext_up=ext_up,
                                          ext_down=ext_down,
                                          remove_dupl=True,
                                          reg2sc_dic=reg2sc_dic,
                                          score_col=bed_score_col,
                                          chr_ids_dic=chr_ids_dic,
                                          bed_chr_ids_dic=bed_chr_ids_dic,
                                          use_region_ids=True,
                                          unstranded=False)

    print("# --in regions pre-filtering:  ", reg_stats_dic["c_in"])
    print("# --in regions post-filtering: ", reg_stats_dic["c_out"])
    print("# regions with invalid chr_id: ", reg_stats_dic["c_chr_filter"])
    print("# duplicated regions removed:  ", reg_stats_dic["c_dupl_filter"])

    assert reg_stats_dic["c_out"], "no --in regions remain after chromosome ID filtering. If caused by invalid chr_id filtering, make sure chromosome IDs in --genome FASTA and --in BED files (or GTF if --in is transcript IDs file) are compatible (i.e., \"chr1\" vs. \"1\" notation)"

    """
    Calculate effective size of genomic regions.
    
    """
    print("Calculate effective genomic region size ... ")
    eff_reg_size = benchlib.get_uniq_gen_size(filtered_sites_bed)

    print("Called region length sum:      ", reg_stats_dic["reg_len_sum"])
    print("Effective region length sum:   ", eff_reg_size)

    """
    Get genomic region sequences from --genome.

    Output FASTA header format:
    >chr8:9772198-9772297(+)

    No need to convert sequences to uppercase, as FIMO works on both 
    lower- and uppercase (as long as DNA / RNA is set correct).

    """
    print("Extract sequences from --genome ... ")
    benchlib.bed_extract_sequences_from_fasta(filtered_sites_bed, 
                                              args.in_genome, filtered_sites_fa,
                                              print_warnings=True)

    """
    Get FASTA sequences and sequence lengths.
    """

    out_seqs_dic = benchlib.read_fasta_into_dic(filtered_sites_fa,
                                       dna=True,
                                       all_uc=True,
                                       id_check=True,
                                       empty_check=False,
                                       skip_n_seqs=False)

    assert out_seqs_dic, "no sequences extracted from FASTA file for --in BED regions. Make sure to use compatible FASTA/BED files!"

    # Get region strands/polarities for motif distance calculations.
    reg2pol_dic = benchlib.extract_pol_from_seq_ids(out_seqs_dic)

    # Effective number of regions used for motif search.
    c_regions = len(out_seqs_dic)

    # Called region size.
    called_reg_size = 0
    len_list = []
    for seq_id in out_seqs_dic:
        seq_len = len(out_seqs_dic[seq_id])
        called_reg_size += seq_len
        len_list.append(seq_len)

    # Length statistics.
    reg_len_median = statistics.median(len_list)
    reg_len_mean = statistics.mean(len_list)
    reg_len_mean = round(reg_len_mean, 2)
    reg_len_min = min(len_list)
    reg_len_max = max(len_list)

    """
    ====================================
    RUN SEQUENCE MOTIF SEARCH WITH FIMO.
    ====================================
    
    """
    fimo_hits_list = []
    call_dic = {}

    if seq_rbps_dic:

        """
        Print motifs to file.

        """

        print("Output motifs to XML ... ")
        out_str, c_added_motifs = benchlib.blocks_to_xml_string(seq_motif_blocks_dic, loaded_motif_ids_dic)

        benchlib.output_string_to_file(out_str, seq_motifs_xml)


        """
        Run FIMO on sequences + motifs.

        """

        print("Run FIMO ... ")
        benchlib.run_fast_fimo(filtered_sites_fa, seq_motifs_xml, fimo_res_tsv,
                    pval_thr=args.fimo_pval,
                    nt_freqs_file=fimo_freqs_file,
                    call_dic=call_dic,
                    params=fimo_params,
                    error_check=False)

        """
        Read in FIMO hits.

        """

        assert os.path.exists(fimo_res_tsv), "FIMO output file fimo.tsv %s does not exist! There must have been an error while running FIMO (invalid xml file provided?)" %(fimo_res_tsv)

        print("Read in FIMO results ... ")
        fimo_hits_list = benchlib.read_in_fimo_results(fimo_res_tsv)

        c_fimo_hits = len(fimo_hits_list)
        print("# of FIMO motif hits:", c_fimo_hits)

        """
        If --regex is set, search for regex hits in sequences (stored in out_seqs_dic).

        """
        if args.regex:

            step_size_one = False
            if args.regex_search_mode == 1:
                step_size_one = False
            elif args.regex_search_mode == 2:
                step_size_one = True
            else:
                assert False, "invalid --regex-search-mode %i set" %(args.regex_search_mode)

            print("Run search for --regex \"%s\" ... " %(regex))
            regex_hits_list = benchlib.get_regex_hits(regex, regex_id, out_seqs_dic,
                                                      step_size_one=step_size_one,
                                                      use_motif_regex_id=args.motif_regex_id)

            c_regex_hits = len(regex_hits_list)
            print("# of regex hits:", c_regex_hits)

            # Add regex hits to fimo_hits_list.
            fimo_hits_list += regex_hits_list


    """
    =========================================
    RUN STRUCTURE MOTIF SEARCH WITH CMSEARCH.
    =========================================

    """
    cmsearch_hits_list = []

    if str_rbps_dic:
        
        print("Output covariance models to .cm ... ")
        benchlib.output_cm_blocks_to_file(str_motif_blocks_dic, loaded_motif_ids_dic, str_motifs_cm)

        # Run cmsearch.
        print("Run cmsearch ... ")
        benchlib.run_cmsearch(filtered_sites_fa, str_motifs_cm, cmsearch_res_txt,
                        error_check=False,
                        call_dic=call_dic,
                        params="-g --tformat fasta --toponly --incT 1 -T 1 --default") # or add --anytrunc and remove --g
        # Read in hits.
        print("Read in cmsearch results ... ")
        cmsearch_hits_list, c_cms_hits = benchlib.read_in_cmsearch_results(cmsearch_res_txt, 
                                                                           check=True)

        print("# of cmsearch motif hits:", c_cms_hits)


    """
    Store for each RBP the regions with motif hits (and hit counts), using
    dictionary of dictionaries regions_with_motifs_dic.
    This tells us, how many input regions have motif hits, separated by RBP.
    Also store for each RBP the unique motif hit regions (and hit counts), using
    dictionary of dictionaries unique_motifs_dic.

    regions_with_motifs_dic:
        Dictionary of dictionaries, format:
        {rbp_id1 -> {'region1': motif_c_region1, 'region2': motif_c_region2}, rbp_id2 -> {'region1': motif_c_region1}}
    unique_motifs_dic:
        Dictionary of dictionaries, format:
        {rbp_id1 -> {'motif_region1': c_motif_region1, 'motif_region2': c_motif_region2}, rbp_id2 -> .. }

    """

    regions_with_motifs_dic = {}
    unique_motifs_dic = {}

    # Store regions with sequence motifs.
    for fh in fimo_hits_list:

        rbp_id = id2name_dic[fh.motif_id]

        if rbp_id in regions_with_motifs_dic:
            # fh.seq_name : FASTA header (== --in genomic sequence region).
            if fh.seq_name in regions_with_motifs_dic[rbp_id]:
                regions_with_motifs_dic[rbp_id][fh.seq_name] += 1
            else:
                regions_with_motifs_dic[rbp_id][fh.seq_name] = 1
        else:
            regions_with_motifs_dic[rbp_id] = {}
            regions_with_motifs_dic[rbp_id][fh.seq_name] = 1

        fh_str = repr(fh) # genomic motif region string.

        # Unique motif regions for each RBP.
        if rbp_id in unique_motifs_dic:
            if fh_str in unique_motifs_dic[rbp_id]:
                unique_motifs_dic[rbp_id][fh_str] += 1
            else:
                unique_motifs_dic[rbp_id][fh_str] = 1
        else:
            unique_motifs_dic[rbp_id] = {}
            unique_motifs_dic[rbp_id][fh_str] = 1

    # Store regions with structure motifs.
    for cmsh in cmsearch_hits_list:

        rbp_id = id2name_dic[cmsh.motif_id]

        if rbp_id in regions_with_motifs_dic:
            # cmsh.seq_name : FASTA header (== --in genomic sequence region).
            if cmsh.seq_name in regions_with_motifs_dic[rbp_id]:
                regions_with_motifs_dic[rbp_id][cmsh.seq_name] += 1
            else:
                regions_with_motifs_dic[rbp_id][cmsh.seq_name] = 1
        else:
            regions_with_motifs_dic[rbp_id] = {}
            regions_with_motifs_dic[rbp_id][cmsh.seq_name] = 1

        cmsh_str = repr(cmsh) # genomic motif region string.

        # Unique motif regions for each RBP.
        if rbp_id in unique_motifs_dic:
            if cmsh_str in unique_motifs_dic[rbp_id]:
                unique_motifs_dic[rbp_id][cmsh_str] += 1
            else:
                unique_motifs_dic[rbp_id][cmsh_str] = 1
        else:
            unique_motifs_dic[rbp_id] = {}
            unique_motifs_dic[rbp_id][cmsh_str] = 1

    """
    Store infos for each RBP in RBP class.

    search_rbps_dic[rbp_id] = rbp_class
    RBP class arguments:
            name: str,
            seq_motif_ids = None,
            str_motif_ids = None,
            c_hit_reg = 0, # # regions with motif hits.
            perc_hit_reg = 0.0, # % hit regions over all regions (i.e. how many input regions contain >= 1 RBP motif).
            c_motif_hits = 0, # # motif hits.
            c_uniq_motif_hits = 0, # # unique motif hits.
            c_uniq_motif_nts = 0, # # unique motif nucleotides.
            perc_uniq_motif_nts_eff_reg = 0.0, # % unique motif nts over effective region length.
            perc_uniq_motif_nts_cal_reg = 0.0, # % unique motif nts over called region length.
            uniq_motif_hits_eff_1000nt = 0.0, # unique motif hits per effective 1000 nt.
            uniq_motif_hits_cal_1000nt = 0.0, # unique motif hits per called 1000 nt.
            ks_pval = 1.0, # Kolmogorov-Smirnov (KS) statistic p-value (are higher scoring sites enriched with motifs).
            ks_stat = 0.0,
            organism: Optional[str] = None

    Number of sequences for FIMO / cmsearch: 
    c_regions

    """
    # Set number of no-hit regions.
    for rbp_id in search_rbps_dic:
        search_rbps_dic[rbp_id].c_no_hit_reg = c_regions

    for rbp_id in regions_with_motifs_dic:
        # Number of --in regions with RBP motif hits.
        c_hit_reg = len(regions_with_motifs_dic[rbp_id])

        # Number of motif hits on --in regions in total.
        c_motif_hits = 0
        for reg_id in regions_with_motifs_dic[rbp_id]:
            c_motif_hits += regions_with_motifs_dic[rbp_id][reg_id]
        search_rbps_dic[rbp_id].c_hit_reg = c_hit_reg
        search_rbps_dic[rbp_id].c_no_hit_reg = c_regions - c_hit_reg
        search_rbps_dic[rbp_id].c_motif_hits = c_motif_hits

        # % hit regions over all regions (i.e. how many input regions contain >= 1 RBP motif).
        search_rbps_dic[rbp_id].perc_hit_reg = (search_rbps_dic[rbp_id].c_hit_reg / c_regions) * 100

    """
    Get unique motif hits.

    unique_motifs_dic:
        Dictionary of dictionaries, format:
        {rbp_id1 -> {'motif_region1': c_motif_region1, 'motif_region2': c_motif_region2}, rbp_id2 -> .. }
    """

    for rbp_id in unique_motifs_dic:
        c_uniq_motif_hits = len(unique_motifs_dic[rbp_id])
        search_rbps_dic[rbp_id].c_uniq_motif_hits = c_uniq_motif_hits
        # Store individual motif unique hits.
        for motif_str_repr in unique_motifs_dic[rbp_id]:
            motif_id = benchlib.get_motif_id_from_str_repr(motif_str_repr)
            idx = motif_id2idx_dic[motif_id]
            if id2type_dic[motif_id] == "meme_xml":
                search_rbps_dic[rbp_id].seq_motif_hits[idx] += 1
            elif id2type_dic[motif_id] == "regex":
                search_rbps_dic[rbp_id].seq_motif_hits[idx] += 1
            elif id2type_dic[motif_id] == "cm":
                search_rbps_dic[rbp_id].str_motif_hits[idx] += 1
            else:
                assert False, "unknown motif type (\"%s\") set for motif_id %s" %(id2type_dic[motif_id], motif_id)

    """
    Number of motif nucleotides over called + effective region size.

    """

    print("Calculate effective motif region sizes for each RBP ... ")
    for rbp_id in unique_motifs_dic:
        # Output unique motif hit regions (sequence or structure) to BED for RBP rbp_id.
        benchlib.output_motif_hits_to_bed(rbp_id, unique_motifs_dic, out_tmp_bed,
                                          one_based_start=True)
        # Calculate effective motif region size.
        eff_motif_reg_size = benchlib.get_uniq_gen_size(out_tmp_bed)

        # Number of unique motif nucleotides.
        search_rbps_dic[rbp_id].c_uniq_motif_nts = eff_motif_reg_size
        # % unique motif nts over effective region length.
        search_rbps_dic[rbp_id].perc_uniq_motif_nts_eff_reg = (eff_motif_reg_size / eff_reg_size) * 100
        # % unique motif nts over called region length.
        search_rbps_dic[rbp_id].perc_uniq_motif_nts_cal_reg = (eff_motif_reg_size / called_reg_size) * 100
        # Number of unique motif hits per effective 1000 nt.
        search_rbps_dic[rbp_id].uniq_motif_hits_eff_1000nt  = search_rbps_dic[rbp_id].c_uniq_motif_hits / (eff_reg_size / 1000)
        # Number of unique motif hits per called 1000 nt.
        search_rbps_dic[rbp_id].uniq_motif_hits_cal_1000nt  = search_rbps_dic[rbp_id].c_uniq_motif_hits / (called_reg_size / 1000)

    """
    # Print RBP object stats.
    for rbp_id in search_rbps_dic:
        print(search_rbps_dic[rbp_id].__dict__)

    """

    # print(search_rbps_dic["AGGF1"].__dict__)
    print("# --in regions for motif search:", c_regions)
    print("Called genomic region size:     ", called_reg_size)
    print("Effective genomic region size:  ", eff_reg_size)


    """
    Output RBP hit stats (ie one row per RBP).

    Output clowns:
    rbp_id
    c_regions
    called_reg_size
    effective_reg_size
    c_reg_with_hits
    perc_reg_with_hits
    c_motif_hits
    c_uniq_motif_hits
    c_uniq_motif_nts
    perc_uniq_motif_nts_cal_reg
    perc_uniq_motif_nts_eff_reg
    uniq_motif_hits_cal_1000nt
    uniq_motif_hits_eff_1000nt
    wc_pval
    seq_motif_ids
    seq_motif_hits
    str_motif_ids
    str_motif_hits

    """

    rbp_list = []

    OUTSTATS = open(rbp_stats_out, "w")
    rbp_stats_header = "data_id\tmethod_id\trun_id\tmotif_db\trbp_id\tc_regions\tmean_reg_len\tmedian_reg_len\tmin_reg_len\tmax_reg_len\t"
    rbp_stats_header += "called_reg_size\teffective_reg_size\tc_reg_with_hits\tperc_reg_with_hits\t"
    rbp_stats_header += "c_motif_hits\tc_uniq_motif_hits\tc_uniq_motif_nts\tperc_uniq_motif_nts_cal_reg\tperc_uniq_motif_nts_eff_reg\tuniq_motif_hits_cal_1000nt\t"
    rbp_stats_header += "uniq_motif_hits_eff_1000nt\twc_pval\tseq_motif_ids\tseq_motif_hits\tstr_motif_ids\tstr_motif_hits\tinternal_id\n"
    OUTSTATS.write(rbp_stats_header)

    for rbp_id in search_rbps_dic:

        # print(search_rbps_dic[rbp_id].__dict__)
        rbp_list.append(rbp_id)

        motif_db_out = loaded_rbps_dic[rbp_id]

        c_reg_with_hits = search_rbps_dic[rbp_id].c_hit_reg
        perc_reg_with_hits = search_rbps_dic[rbp_id].perc_hit_reg
        c_motif_hits = search_rbps_dic[rbp_id].c_motif_hits
        c_uniq_motif_hits = search_rbps_dic[rbp_id].c_uniq_motif_hits
        c_uniq_motif_nts = search_rbps_dic[rbp_id].c_uniq_motif_nts
        perc_uniq_motif_nts_cal_reg = search_rbps_dic[rbp_id].perc_uniq_motif_nts_cal_reg
        perc_uniq_motif_nts_eff_reg = search_rbps_dic[rbp_id].perc_uniq_motif_nts_eff_reg
        uniq_motif_hits_cal_1000nt = search_rbps_dic[rbp_id].uniq_motif_hits_cal_1000nt
        uniq_motif_hits_eff_1000nt = search_rbps_dic[rbp_id].uniq_motif_hits_eff_1000nt
        wc_pval = "-"
        internal_id = search_rbps_dic[rbp_id].internal_id

        seq_motif_hits = ",".join(str(hc) for hc in search_rbps_dic[rbp_id].seq_motif_hits)
        str_motif_hits = ",".join(str(hc) for hc in search_rbps_dic[rbp_id].str_motif_hits)
        seq_motif_ids = ",".join(search_rbps_dic[rbp_id].seq_motif_ids)
        str_motif_ids = ",".join(search_rbps_dic[rbp_id].str_motif_ids)
        if not seq_motif_hits:
            seq_motif_hits = "-"
        if not str_motif_hits:
            str_motif_hits = "-"
        if not seq_motif_ids:
            seq_motif_ids = "-"
        if not str_motif_ids:
            str_motif_ids = "-"

        row_str = args.data_id + "\t"
        row_str += args.method_id + "\t"
        row_str += run_id + "\t"
        row_str += motif_db_out + "\t"
        row_str += rbp_id + "\t"

        row_str += str(c_regions) + "\t"

        row_str += str(reg_len_mean) + "\t"
        row_str += str(reg_len_median) + "\t"
        row_str += str(reg_len_min) + "\t"
        row_str += str(reg_len_max) + "\t"

        row_str += str(called_reg_size) + "\t"
        row_str += str(eff_reg_size) + "\t"

        row_str += str(c_reg_with_hits) + "\t"
        row_str += str(perc_reg_with_hits) + "\t"

        row_str += str(c_motif_hits) + "\t"
        row_str += str(c_uniq_motif_hits) + "\t"
        row_str += str(c_uniq_motif_nts) + "\t"
        row_str += str(perc_uniq_motif_nts_cal_reg) + "\t"
        row_str += str(perc_uniq_motif_nts_eff_reg) + "\t"
        row_str += str(uniq_motif_hits_cal_1000nt) + "\t"
        row_str += str(uniq_motif_hits_eff_1000nt) + "\t"
        row_str += wc_pval + "\t"
        row_str += seq_motif_ids + "\t"
        row_str += seq_motif_hits + "\t"
        row_str += str_motif_ids + "\t"
        row_str += str_motif_hits + "\t"
        row_str += internal_id + "\n"

        OUTSTATS.write(row_str)

    OUTSTATS.close()


    """
    Output motif region stats (1 row for each motif hit).
    Report ALL motif hits,
    plus report how many times one genomic motif hit occurs (uniq_count). 

    """

    OUTSTATS = open(motif_stats_out,"w")

    motif_stats_header = "data_id\tmethod_id\trun_id\tmotif_db\tregion_id\trbp_id\tmotif_id\tchr_id\tgen_s\tgen_e\tstrand\tregion_s\tregion_e\tregion_len\t"
    motif_stats_header += "uniq_count\tfimo_score\tfimo_pval\tcms_score\tcms_eval\tinternal_id\n"
    OUTSTATS.write(motif_stats_header)

    # Unique motif regions BED.
    motif_reg_dic = {}


    for fh in fimo_hits_list:

        rbp_id = id2name_dic[fh.motif_id]
        region_id = fh.seq_name
        region_len = benchlib.get_length_from_seq_name(fh.seq_name)
        # genomic motif region string.
        fh_str = repr(fh)
        uniq_count = unique_motifs_dic[rbp_id][fh_str]

        motif_db_out = loaded_motif_ids_dic[fh.motif_id]

        internal_id = search_rbps_dic[rbp_id].internal_id

        # Store motif hit as BED.
        hit_id = "%s:%s-%s(%s),%s" %(fh.chr_id, str(fh.start), str(fh.end), fh.strand, fh.motif_id)
        if hit_id not in motif_reg_dic:
            bed_row = "%s\t%i\t%i\t%s,%s;%i;%s,%s\t0\t%s\t%s\t%s\t-1.0\t-1.0" %(fh.chr_id, fh.start-1, fh.end, rbp_id, fh.motif_id, uniq_count, args.method_id, args.data_id, fh.strand, str(fh.score), str(fh.pval))
            motif_reg_dic[hit_id] = bed_row

        row_str = args.data_id + "\t"
        row_str += args.method_id + "\t"
        row_str += run_id + "\t"
        row_str += motif_db_out + "\t"
        row_str += region_id + "\t"
        row_str += rbp_id + "\t"
        row_str += fh.motif_id + "\t"
        row_str += fh.chr_id + "\t"
        row_str += str(fh.start) + "\t"  # 1-based.
        row_str += str(fh.end) + "\t"
        row_str += fh.strand + "\t"
        row_str += str(fh.seq_s) + "\t"  # 1-based.
        row_str += str(fh.seq_e) + "\t"
        row_str += str(region_len) + "\t"
        row_str += str(uniq_count) + "\t"
        row_str += str(fh.score) + "\t"
        row_str += str(fh.pval) + "\t"
        row_str += "-\t"
        row_str += "-\t"
        row_str += internal_id + "\n"

        OUTSTATS.write(row_str)

    for cmsh in cmsearch_hits_list:

        rbp_id = id2name_dic[cmsh.motif_id]
        region_id = cmsh.seq_name
        region_len = benchlib.get_length_from_seq_name(cmsh.seq_name)
        # genomic motif region string.
        cmsh_str = repr(cmsh) 
        uniq_count = unique_motifs_dic[rbp_id][cmsh_str]

        motif_db_out = loaded_motif_ids_dic[cmsh.motif_id]

        internal_id = search_rbps_dic[rbp_id].internal_id

        # Store motif hit as BED.
        hit_id = "%s:%s-%s(%s),%s" %(cmsh.chr_id, str(cmsh.start), str(cmsh.end), cmsh.strand, cmsh.motif_id)
        if hit_id not in motif_reg_dic:
            bed_row = "%s\t%i\t%i\t%s,%s;%i;%s,%s\t0\t%s\t%s\t%s\t-1.0\t-1.0" %(cmsh.chr_id, cmsh.start-1, cmsh.end, rbp_id, cmsh.motif_id, uniq_count, args.method_id, args.data_id, cmsh.strand, str(cmsh.score), str(cmsh.e_value))
            motif_reg_dic[hit_id] = bed_row

        row_str = args.data_id + "\t"
        row_str += args.method_id + "\t"
        row_str += run_id + "\t"
        row_str += motif_db_out + "\t"
        row_str += region_id + "\t"
        row_str += rbp_id + "\t"
        row_str += cmsh.motif_id + "\t"
        row_str += cmsh.chr_id + "\t"
        row_str += str(cmsh.start) + "\t"
        row_str += str(cmsh.end) + "\t"
        row_str += cmsh.strand + "\t"
        row_str += str(cmsh.seq_s) + "\t"
        row_str += str(cmsh.seq_e) + "\t"
        row_str += str(region_len) + "\t"
        row_str += str(uniq_count) + "\t"
        row_str += "-\t"
        row_str += "-\t"
        row_str += str(cmsh.score) + "\t"
        row_str += str(cmsh.e_value) + "\t"
        row_str += internal_id + "\n"
        #print("region_id:", region_id)
        #print("evalue:", cmsh.e_value)
        #print(row_str)

        OUTSTATS.write(row_str)

    OUTSTATS.close()

    """
    Output motif hits as BED.

    The motif hits written to motif_hits_bed_out are unique motif hits already. 
    If same hit occurs > 1, this is recorded in BED column 4 with format:
    rbp_id,motif_id;uniq_count;method_id,data_id
    These also include regex hits, as they are part of fimo hits.
    
    """

    OUTBED = open(motif_hits_bed_out,"w")
    for hit_id in motif_reg_dic:
        OUTBED.write("%s\n" %(motif_reg_dic[hit_id]))
    OUTBED.close()


    """
    Motif annotations if --plot-motifs and --gtf set.

    """

    rbp2motif2annot2c_dic = {}  # rbp_id -> motif_id -> annot -> count

    if args.in_gtf:

        # Extract exon + intron regions of selected transcripts from transcript infos.
        print("Output intron annotations to BED ... ")
        intron_exon_out_bed = args.out_folder + "/intron_exon_regions.tmp.bed"
        benchlib.output_transcript_info_intron_exon_to_bed(tid2tio_dic, intron_exon_out_bed,
                                            output_mode=3,  # only introns.
                                            report_counts=True,
                                            add_tr_id=True,
                                            empty_check=False)

        # Custom transcript biotypes for upset plot.
        custom_annot_dic = None
        if args.tr_types_list:
            for tr_type in args.tr_types_list:
                assert tr_type in tr_types_dic, "given transcript biotype ID \"%s\" not found in GTF file"
                custom_annot_dic[tr_type] = tr_type

        # Append detailed exon annotations (CDS, UTR, transcript biotypes) to intron annotations.
        print("Output exon annotations to BED ... ")
        benchlib.output_exon_annotations(tid2tio_dic, intron_exon_out_bed,
                                         custom_annot_dic=custom_annot_dic,
                                         append=True)

        # Overlap motif hit BED with genomic annotation regions.
        print("Overlap annotations with motif hit regions ... ")

        params = "-s -wo -f %s" %(str(args.gtf_feat_min_overlap))
        overlap_motif_hit_annotations_bed = args.out_folder + "/overlap_motif_hit_annotations.tmp.bed"
        benchlib.bed_intersect_files(motif_hits_bed_out, intron_exon_out_bed, 
                                     overlap_motif_hit_annotations_bed,
                                     params=params)

        motif_hit2annot_dic = benchlib.get_region_annotations(
                                            overlap_motif_hit_annotations_bed,
                                            motif_hits=True,
                                            reg_ids_dic=motif_reg_dic)

        for motif_hit in motif_hit2annot_dic:
            # motif_hit format: "chr1:10-15(+),motif_id". Get motif_id.
            motif_id = motif_hit.split(",")[1]
            annot = motif_hit2annot_dic[motif_hit][0]
            # tr_id = motif_hit2annot_dic[motif_hit][1]
            rbp_id = id2name_dic[motif_id]
            if rbp_id not in rbp2motif2annot2c_dic:
                rbp2motif2annot2c_dic[rbp_id] = {}
            if motif_id not in rbp2motif2annot2c_dic[rbp_id]:
                rbp2motif2annot2c_dic[rbp_id][motif_id] = {}
            if annot not in rbp2motif2annot2c_dic[rbp_id][motif_id]:
                rbp2motif2annot2c_dic[rbp_id][motif_id][annot] = 1
            else:
                rbp2motif2annot2c_dic[rbp_id][motif_id][annot] += 1

    """
    Get annotation to color dictionary, which is needed for region annotation plots in HTML reports.

    """

    annot2color_dic = {}

    if rbp2motif2annot2c_dic:

        annot_dic = {}

        if rbp2motif2annot2c_dic:
            for rbp_id in rbp2motif2annot2c_dic:
                for motif_id in rbp2motif2annot2c_dic[rbp_id]:
                    for annot in rbp2motif2annot2c_dic[rbp_id][motif_id]:
                        if annot not in annot_dic:
                            annot_dic[annot] = 1
                        else:
                            annot_dic[annot] += 1

        # hex_colors = get_hex_colors_list(min_len=len(annot_with_hits_dic))
        hex_colors = benchlib.get_hex_colors_list(min_len=len(annot_dic))

        idx = 0
        for annot in sorted(annot_dic, reverse=False):
            # hc = hex_colors[idx]
            # print("Assigning hex color %s to annotation %s ... " %(hc, annot))
            annot2color_dic[annot] = hex_colors[idx]
            idx += 1


    """
    Motif plots and motif hit statistics HTML.

    """
    html_motif_plots_out = args.out_folder + "/" + "motif_plots.rbpbench_searchlong.html"
    if args.plot_abs_paths:
        html_motif_plots_out = os.path.abspath(args.out_folder) + "/" + "motif_plots.rbpbench_search.html"
    # If HTML file already exists, remove it.
    if os.path.exists(html_motif_plots_out):
        os.remove(html_motif_plots_out)

    if args.plot_motifs:
        
        print("Generate motif plots HTML ... ")
        
        plots_subfolder = "html_motif_plots"
        benchlib_path = os.path.dirname(benchlib.__file__)

        benchlib.search_generate_html_motif_plots(search_rbps_dic, seq_motif_blocks_dic, 
                                         str_motif_blocks_dic, args.out_folder, 
                                         benchlib_path, loaded_motif_ids_dic,
                                         motif_db_str=motif_db_str,
                                         rbp2motif2annot2c_dic=rbp2motif2annot2c_dic,
                                         annot2color_dic=annot2color_dic,
                                         regex_id=regex_id,
                                         sort_js_mode=args.sort_js_mode,
                                         html_report_out=html_motif_plots_out,
                                         plot_abs_paths=args.plot_abs_paths,
                                         rbpbench_mode="searchlong",
                                         plots_subfolder=plots_subfolder)


    """
    Output parameter settings.

    """
    # Output mode settings.
    print("Output parameter settings ... ")
    SETOUT = open(settings_file, "w")
    for arg in vars(args):
        SETOUT.write("%s\t%s\n" %(arg, str(getattr(args, arg))))
    for call in call_dic:
        SETOUT.write("%s\t%s\n" %(call, call_dic[call]))
    SETOUT.close()

    """
    Take out the trash.

    """
    print("Delete .tmp files ... ")
    if os.path.exists(out_tmp_bed):
        os.remove(out_tmp_bed)
    if os.path.exists(cmstat_tmp_out):
        os.remove(cmstat_tmp_out)


    """
    Inform about outputs.

    """
    print("")
    print("OUTPUT FILES")
    print("============")
    print("")
    print("Run parameter settings:\n%s" %(settings_file))
    # print("Co-occurrence p-values for each RBP pair .tsv:\n%s" %(con_res_out_tsv))
    print("Filtered input regions .bed:\n%s" %(filtered_sites_bed))
    print("Filtered input regions .fa:\n%s" %(filtered_sites_fa))
    print("Motif hits .bed:\n%s" %(motif_hits_bed_out))
    # print("RBP region occupancies .tsv:\n%s" %(rbp_reg_occ_table_out))
    print("RBP hit stats .tsv:\n%s" %(rbp_stats_out))
    print("Motif hit stats .tsv:\n%s" %(motif_stats_out))
    # if reg_annot_table_file is not None:
    #     print("Region annotations .tsv:\n%s" %(reg_annot_table_file))
    if args.plot_motifs:
        print("Motif plots and hit statistics .html:\n%s" %(html_motif_plots_out))
    # if args.report:
    #     print("Search report .html:\n%s" %(html_report_out))
    print("")









################################################################################

def main_searchcorna(args):
    """
    Motif search in spliced transcripts and check out co-occurrences based 
    on selected RBP.

    """

    print("Running for you in SEARCHCORNA mode ... ")

    # AALAMO


    assert os.path.exists(args.in_gtf), "--gtf file \"%s\" not found" % (args.in_gtf)
    assert os.path.exists(args.in_genome), "--genome file \"%s\" not found" % (args.in_genome)

    assert benchlib.boundary_check(args.gtf_feat_min_overlap, 1E-9, 1.0), "set --gtf-feat-min-overlap expected to be >= 1E-9 and <= 1.0"

    # Is MEME >= v5 installed?
    if not args.meme_disable_check:
        assert benchlib.is_tool("meme"), "meme not in PATH"
        check, meme_version = benchlib.check_tool_version("meme -version", "5.0")
        assert check, "RBPBench requires meme version >= 5.0 (installed version: %s)" %(meme_version)

    # Check if MEME version is >= 5.5.4 (need to add fimo --no-pgc option to produce same results!).
    fimo_params = "--norc --verbosity 1 --skip-matched-sequence --text"
    if not args.meme_disable_check:
        check, meme_version = benchlib.check_tool_version("meme -version", "5.5.4")
        if check:
            fimo_params = "--norc --verbosity 1 --skip-matched-sequence --text --no-pgc"
    if args.meme_no_pgc:
        fimo_params = "--norc --verbosity 1 --skip-matched-sequence --text --no-pgc"

    # Regex check.
    if args.regex:
        assert benchlib.is_valid_regex(args.regex), "given --regex \"%s\" is not a valid regular expression. Please provide valid expression" % (args.regex)

    """
    Library path.
    """
    benchlib_path = os.path.dirname(benchlib.__file__)
    db_path = benchlib_path + "/content"

    """
    FIMO nt frequencies.
    """
    fimo_freqs_file = db_path + "/fimo_nt_freqs.txt"
    if args.fimo_nt_freqs:
        fimo_freqs_file = args.fimo_nt_freqs
    assert os.path.exists(fimo_freqs_file), "set FIMO nucleotide frequencies file \"%s\" not found" % (fimo_freqs_file)

    """
    Motif database.
    """
    seq_motifs_db_file, str_motifs_db_file, rbp2ids_file, motif_db_str = specify_motif_db(args.motif_db, 
                                                                            db_path=db_path)
    # Custom motif database: folder given.
    if args.custom_db:
        assert not args.custom_db_meme_xml, "--custom-db folder set incompatible with --custom-db-meme-xml. Provide custom motif database either via folder (--custom-db) or as single files"
        assert not args.custom_db_cm, "--custom-db folder set incompatible with --custom-db-cm. Provide custom motif database either via folder (--custom-db) or as single files"
        assert not args.custom_db_info, "--custom-db folder set incompatible with --custom-db-info. Provide custom motif database either via folder (--custom-db) or as single files"
        seq_motifs_db_file, str_motifs_db_file, rbp2ids_file = specify_custom_motif_db(args.custom_db)
        motif_db_str = args.custom_db_id
    # Custom motif database: single files given.
    if args.custom_db_meme_xml or args.custom_db_cm or args.custom_db_info:
        motif_db_str = args.custom_db_id
        assert not args.custom_db, "single custom motif database files provided not compatible with --custom-db. Provide custom motif database either via folder (--custom-db) or as single files"
        assert args.custom_db_info, "--custom-db-info needed to define custom motif database"
        rbp2ids_file = args.custom_db_info
        assert args.custom_db_meme_xml or args.custom_db_cm, "--custom-db-meme-xml and/or --custom-db-cm needed to define custom motif database"
        if args.custom_db_meme_xml:
            seq_motifs_db_file = args.custom_db_meme_xml
        else:
            seq_motifs_db_file = ""  # setting to empty string results in os.path.exists -> False.
        if args.custom_db_cm:
            str_motifs_db_file = args.custom_db_cm
        else:
            str_motifs_db_file = ""

    args.motif_db_str = motif_db_str

    """
    Get ID mappings

    name2ids_dic:
    RBP name -> motif IDs mapping
    id2type_dic:
    motif ID -> motif type (cm, meme_xml)
    id2org_dic (ignore for now):
    motif ID -> organism ID (so far only "human")

    """
    name2ids_dic, id2type_dic = benchlib.get_rbp_id_mappings(rbp2ids_file)
    # Motif ID -> RBP name (== RBP ID) mapping.
    id2name_dic = {}
    for rbp_id in name2ids_dic:
        for motif_id in name2ids_dic[rbp_id]:
            id2name_dic[motif_id] = rbp_id

    """
    Get MEME XML database motif blocks dictionary.

    """
    seq_motif_blocks_dic = {}
    if os.path.exists(seq_motifs_db_file):
        seq_motif_blocks_dic = benchlib.read_in_xml_motifs(seq_motifs_db_file,
                                                           empty_check=True)
    for motif_id in seq_motif_blocks_dic:
        assert motif_id in id2name_dic, "MEME XML motif ID %s not found in prior mapping. Please contact developers!" %(motif_id)

    """
    Get covariance model database motif blocks dictionary.

    """
    str_motif_blocks_dic = {}
    if os.path.exists(str_motifs_db_file):
        str_motif_blocks_dic = benchlib.read_in_cm_blocks(str_motifs_db_file, 
                                                          empty_check=True)
    for motif_id in str_motif_blocks_dic:
        assert motif_id in id2name_dic, "Covariance model accession ID %s not found in prior mapping. Please contact developers!" %(motif_id)

    # Remove special chars from run ID.
    args.data_id = benchlib.remove_special_chars_from_str(args.data_id)
    assert args.data_id, "empty string after removing special chars from --data-id. Please provide alphanumeric string for data ID (- or _ are okay as well)"
    args.method_id = benchlib.remove_special_chars_from_str(args.method_id)
    assert args.method_id, "empty string after removing special chars from --method-id. Please provide alphanumeric string for method ID (- or _ are okay as well)"
    # Run ID definition.
    run_id = "run_id"
    if args.run_id:
        run_id = benchlib.remove_special_chars_from_str(args.run_id)
        assert run_id, "empty string after removing special chars from --run-id. Please provide alphanumeric string for run ID (- or _ are okay as well)"

    print("Run ID:     ", run_id)
    print("Data ID:    ", args.data_id)
    print("Method ID:  ", args.method_id)


    """
    Output folders + files.

    """
    if not os.path.exists(args.out_folder):
        os.makedirs(args.out_folder)

    mrna_seqs_fa = args.out_folder + "/mrna_sequences.fa"
    mrna_regions_bed = args.out_folder + "/mrna_regions.bed"  # UTR CDS regions on mRNAs (i.e. transcript context).
    seq_motifs_xml = args.out_folder + "/seq_motifs.xml"
    str_motifs_cm = args.out_folder + "/str_motifs.cm"
    fimo_res_tsv = args.out_folder + "/fimo_results.tsv"
    cmsearch_res_txt = args.out_folder + "/cmsearch_results.txt"

    rbp_stats_out = args.out_folder + "/rbp_hit_stats.tsv"
    motif_stats_out = args.out_folder + "/motif_hit_stats.tsv"
    # con_res_out_tsv = args.out_folder + "/contingency_table_results.tsv"
    settings_file = args.out_folder + "/settings.find_motifs.out"
    # rbp_reg_occ_table_out = args.out_folder + "/rbp_region_occupancies.tsv"

    # Output unique motif hits.
    motif_hits_bed_out = args.out_folder + "/motif_hits.rbpbench_searchmrna.bed"

    out_tmp_bed = args.out_folder + "/rbp_motif_hit_regions.tmp.bed"
    cmstat_tmp_out = args.out_folder + "/cmstat_out.tmp.txt"

    # Delete if existing folder.
    if os.path.exists(fimo_res_tsv):
        os.remove(fimo_res_tsv)
    if os.path.exists(cmsearch_res_txt):
        os.remove(cmsearch_res_txt)


    """
    Load RBP data based on --rbps (+ optionally USER data).

    """

    rbp_in_dic = {}
    for rbp_id in args.list_rbps:
        rbp_in_dic[rbp_id] = 1

    # RBPs for motif search.
    loaded_rbps_dic = {}

    # USER set?
    user_motifs = False
    user_rbp_id = False
    if "USER" in rbp_in_dic:
        user_motifs = True
    else:
        assert not args.user_meme_xml, "--user-meme-xml provided but --rbps USER not set. Please add USER to --rbps list to search for user-supplied motifs"
        assert not args.user_cm, "--user-cm provided but --rbps USER not set. Please add USER to --rbps list to search for user-supplied motifs"
        assert not args.user_rbp_id, "--user-rbp-id set but --rbps USER not set. Please add USER to --rbps list to search for user-supplied motifs"

    # If ALL set, load all RBPs (+ optinally USER).
    if "ALL" in rbp_in_dic:
        if len(rbp_in_dic) == 2:
            assert user_motifs, "set --rbps ALL, --rbps ALL USER, or individual RBPs (+ optinally USER) --rbps RBP1 RBP2 ... USER"
        if len(rbp_in_dic) > 2:
            assert False, "set --rbps ALL, --rbps ALL USER, or individual RBPs (+ optinally USER) --rbps RBP1 RBP2 ... USER"
        print("--rbps ALL selected. Loading all database motifs ... ")
        for rbp_id in name2ids_dic:
            loaded_rbps_dic[rbp_id] = motif_db_str

    else:
        # Load individual RBPs.
        for rbp_id in rbp_in_dic:
            if rbp_id != "USER":
                """
                Check if RBP ID in database.
                Suggest similar RBPs based on string similarity (edit distance).

                """
                if rbp_id not in name2ids_dic:
                    db_rbp_list = []
                    for db_rbp_id in name2ids_dic:
                        db_rbp_list.append(db_rbp_id)
                    pair_dist_dic = benchlib.calc_edit_dist_query_list(rbp_id, db_rbp_list)
                    max_c = 10
                    c = 0
                    suggested_rbps = []
                    for key, value in sorted(pair_dist_dic.items(), key=lambda item: item[1], reverse=False):
                        if c >= max_c:
                            break
                        c += 1
                        suggested_rbps.append(key)
                    suggested_rbps_str = ",".join(suggested_rbps)
                    assert False, "provided --rbps ID %s not in internal motif database (%s). Please provide RBP name present in database. Did you mean (any of) the following database ID(s) (top 10 hits based on string similarity): %s ?" %(rbp_id, motif_db_str, suggested_rbps_str)
                # assert rbp_id in name2ids_dic, "provided --rbps ID %s not in internal motif database. Please provide RBP name present in database" %(rbp_id)
                loaded_rbps_dic[rbp_id] = motif_db_str

    # Motif IDs for search.
    loaded_motif_ids_dic = {}
    for rbp_id in loaded_rbps_dic:
        for motif_id in name2ids_dic[rbp_id]:
            loaded_motif_ids_dic[motif_id] = motif_db_str

    """
    Check and load provided USER data.

    """

    if user_motifs:
        print("--rbps USER selected. Check + load provided USER motifs ... ")
        assert args.user_rbp_id, "--rbps USER demands --user-rbp-id to be set to connect the supplied motif(s) with an RBP ID"
        assert args.user_meme_xml or args.user_cm, "--rbps USER requires a provided sequence or structure motif file (via --user-meme-xml AND/OR --user-cm)"

        # Reformat user_rbp_id. 
        user_rbp_id = benchlib.remove_special_chars_from_str(args.user_rbp_id)
        assert user_rbp_id, "empty string after removing special chars from --user-rbp-id. Please provide alphanumeric string for RBP ID (- or _ are okay as well)"

        assert user_rbp_id not in loaded_rbps_dic, "user RBP ID %s already selected from database. Please deselect respective database RBP ID or provide unique user RBP ID via --user-rbp-id" %(user_rbp_id)
        loaded_rbps_dic[user_rbp_id] = "user"
        # In case user_rbp_id in database, reset motif IDs associated to user_rbp_id.
        name2ids_dic[user_rbp_id] = []
        print("RBP ID for user-supplied motifs:", user_rbp_id)

        user_seq_motif_blocks_dic = {}
        if args.user_meme_xml:
            assert os.path.exists(args.user_meme_xml), "--user-meme-xml file \"%s\" not found" % (args.user_meme_xml)
            user_seq_motif_blocks_dic = benchlib.read_in_xml_motifs(args.user_meme_xml, empty_check=False)
            assert user_seq_motif_blocks_dic, "no motifs read in from provided --user-meme-xml. Make sure to supply sequence motifs in MEME XML format!"
            # Check if motif ID already loaded.
            for acc_id in user_seq_motif_blocks_dic:
                assert acc_id not in loaded_motif_ids_dic, "user-supplied MEME XML motif ID %s already selected, i.e., ID is already associated with selected database RBP %s. Please change user motif ID to a unique motif ID or deselect the respective RBP" %(acc_id, id2name_dic[acc_id])
                loaded_motif_ids_dic[acc_id] = "user"
                # Add user to database blocks (overwrite if same ID encountered).
                seq_motif_blocks_dic[acc_id] = user_seq_motif_blocks_dic[acc_id]
                name2ids_dic[user_rbp_id].append(acc_id)
                id2type_dic[acc_id] = "meme_xml"
                id2name_dic[acc_id] = user_rbp_id

        user_str_motif_blocks_dic = {}
        if args.user_cm:
            assert os.path.exists(args.user_cm), "--user-cm file \"%s\" not found" % (args.user_cm)
            # Check for valid format.
            acc_ids_dic = benchlib.check_cm_file(args.user_cm, cmstat_tmp_out, empty_check=False)
            # Read in covariance model blocks.
            user_str_motif_blocks_dic = benchlib.read_in_cm_blocks(args.user_cm)
            for acc_id in acc_ids_dic:
                assert acc_id in user_str_motif_blocks_dic, "accession ID %s not in blocks dictionary. Please contact developers!" %(acc_id)
            # Check if motif ID already loaded.
            for acc_id in user_str_motif_blocks_dic:
                assert acc_id not in loaded_motif_ids_dic, "user-supplied covariance model accession (ACC) ID %s already selected, i.e., ID is already associated with selected database RBP %s. Please change to a unique accession ID or deselect the respective RBP" %(acc_id, id2name_dic[acc_id])
                loaded_motif_ids_dic[acc_id] = "user"
                # Add user to database blocks (overwrite if same ID encountered).
                str_motif_blocks_dic[acc_id] = user_str_motif_blocks_dic[acc_id]
                name2ids_dic[user_rbp_id].append(acc_id)
                id2type_dic[acc_id] = "cm"
                id2name_dic[acc_id] = user_rbp_id

    """
    Check if loaded RBP IDs have motifs.

    """
    for rbp_id in loaded_rbps_dic:
        for motif_id in name2ids_dic[rbp_id]:
            found = 0
            if motif_id in seq_motif_blocks_dic:
                found += 1
            if motif_id in str_motif_blocks_dic:
                found += 1
            assert found, "no motifs loaded for RBP ID \"%s\". Please provide the respective motifs file" %(rbp_id)


    """
    If --regex is set:
    Treat regex as sequence motif / fimo type.
    rbp_id: regex, motif_id: regex, motif_db: regex
    
    """

    regex_id = args.regex_id
    regex = args.regex
    
    if args.regex:

        # Remove , ; from given regex, to avoid motif_id format conflicts.
        regex = benchlib.remove_special_chars_from_str(args.regex,
                                                       reg_ex="[,;]")
        
        assert regex, "empty string after removing special chars from --regex. Please provide a valid regex with DNA letters"

        regex_id = benchlib.remove_special_chars_from_str(args.regex_id)

        assert regex_id, "empty string after removing special chars from --regex-id. Please provide alphanumeric string for regex ID (- or _ are okay as well)"
        assert regex_id not in name2ids_dic, "--regex set but a different RBP ID with name \"%s\" was found. Please provide a different RBP ID or --regex-id" %(regex_id)

        if args.motif_regex_id:
            assert regex_id not in id2type_dic, "--regex set but a different motif ID with name \"%s\" was found. Please provide a different motif ID or --regex-id" %(regex_id)

            id2name_dic[regex_id] = regex_id    # motif_id -> rbp_id
            id2type_dic[regex_id] = "regex"  # motif_id -> motif type string; motif type string can be regex, cm, meme_xml
            loaded_motif_ids_dic[regex_id] = regex_id  # motif_id -> motif_db_str
            name2ids_dic[regex_id] = [regex_id]  # rbp_id -> motif_ids

        else:
            assert regex not in id2type_dic, "--regex set but a different motif ID with name \"%s\" was found. Please provide a different motif ID or use --motif-regex-id" %(regex_id)

            id2name_dic[regex] = regex_id    # motif_id -> rbp_id
            id2type_dic[regex] = "regex"  # motif_id -> motif type string; motif type string can be regex, cm, meme_xml
            loaded_motif_ids_dic[regex] = regex_id  # motif_id -> motif_db_str
            name2ids_dic[regex_id] = [regex]  # rbp_id -> motif_ids

        loaded_rbps_dic[regex_id] = regex_id  # rbp_id -> motif_db_str

    """
    If --set-rbp-id set, check if it is part of loaded RBP IDs.

    """

    if args.set_rbp_id is not None:
        assert args.set_rbp_id in loaded_rbps_dic, "given --set-rbp-id \"%s\" is not part of loaded RBP IDs. Please provide --set-rbp-id that is part of loaded RBPs (user-defined or database RBP ID)" %(args.set_rbp_id)

    """
    Load RBP data, store in RBP() class.

    """

    # Store motif IDs for search.
    search_rbps_dic = {}
    seq_rbps_dic = {}
    str_rbps_dic = {}
    motif_id2idx_dic = {} # motif ID -> list index.
    args.internal_id = []

    for rbp_id in loaded_rbps_dic:
    
        internal_id = base64.urlsafe_b64encode(os.urandom(6)).decode()
        args.internal_id.append(internal_id)
        rbp = benchlib.RBP(rbp_id, internal_id)

        for motif_id in name2ids_dic[rbp_id]:
        
            assert motif_id in loaded_motif_ids_dic, "motif_id %s not in loaded_motif_ids_dic" %(motif_id)

            if id2type_dic[motif_id] == "meme_xml":
                rbp.seq_motif_ids.append(motif_id)
                motif_id2idx_dic[motif_id] = len(rbp.seq_motif_ids) - 1
                rbp.seq_motif_hits.append(0)
                seq_rbps_dic[rbp_id] = 1
            elif id2type_dic[motif_id] == "regex":
                rbp.seq_motif_ids.append(motif_id)
                motif_id2idx_dic[motif_id] = len(rbp.seq_motif_ids) - 1
                rbp.seq_motif_hits.append(0)
                seq_rbps_dic[rbp_id] = 1
            elif id2type_dic[motif_id] == "cm":
                rbp.str_motif_ids.append(motif_id)
                motif_id2idx_dic[motif_id] = len(rbp.str_motif_ids) - 1
                rbp.str_motif_hits.append(0)
                str_rbps_dic[rbp_id] = 1
            else:
                assert False, "unknown motif type (\"%s\") set for motif_id %s" %(id2type_dic[motif_id], motif_id)

        search_rbps_dic[rbp_id] = rbp


    print("# of RBP IDs for search:    ", len(loaded_rbps_dic))
    print("# of motif IDs for search:  ", len(loaded_motif_ids_dic))

    """
    Get chromosome IDs from --genome.
    """
    print("Get --genome FASTA headers ... ")
    chr_ids_dic = benchlib.get_fasta_headers(args.in_genome)

    """
    Guess chromosome ID style.

    chr_style:
        1: chr1, chr2, ..., chrX, chrM
        2: 1, 2, ... , X, MT

    """
    chr_style = 0  # no changes to chromosome IDs in GTF files.
    
    if "1" in chr_ids_dic:
        assert "chr1" not in chr_ids_dic, "inconsistent chromosome IDs in --genome FASTA file (both chr1 and 1)"
    if "chr1" in chr_ids_dic:
        assert "1" not in chr_ids_dic, "inconsistent chromosome IDs in --genome FASTA file (both chr1 and 1)"
    if "chr1" in chr_ids_dic:
        chr_style = 1
    if "1" in chr_ids_dic:
        chr_style = 2


    """
    Read in gene infos from --gtf.

    """

    # reg_annot_table_file = args.out_folder + "/" + "region_annotations.tsv"

    print("Read in gene features from --gtf ... ")
    tr2gid_dic = {}
    tr_types_dic = {}  # Store transcript biotypes in GTF file.
    gid2gio_dic = benchlib.gtf_read_in_gene_infos(args.in_gtf,
                                                    tr2gid_dic=tr2gid_dic,
                                                    tr_types_dic=tr_types_dic,
                                                    check_chr_ids_dic=chr_ids_dic,
                                                    chr_style=chr_style,
                                                    empty_check=False)
    assert gid2gio_dic, "no gene infos read in from --gtf. Please provide a valid/compatible GTF file (e.g. from Ensembl or ENCODE)"
    c_gene_infos = len(gid2gio_dic)
    print("# gene features read in from --gtf:", c_gene_infos)

    # Get most prominent transcripts or if --tr-list is set, read in transcript IDs.
    tr_ids_dic = {}
    if args.tr_list:
        tr_ids_dic = benchlib.read_ids_into_dic(args.tr_list,
                                                check_dic=False)
        assert tr_ids_dic, "no IDs read in from provided --tr-list file. Please provide a valid IDs file (one ID per row)"
        for tr_id in tr_ids_dic:
            assert tr_id in tr2gid_dic, "transcript ID \"%s\" from provided --tr-list file does not appear in --gtf file. Please provide compatible files" %(tr_id)
            tr_ids_dic[tr_id] = tr2gid_dic[tr_id]
        print("# of transcript IDs (read in from --tr-list): ", len(tr_ids_dic))
    else:
        # Get most prominent transcripts from gene infos.
        tr_ids_dic = benchlib.select_mpts_from_gene_infos(gid2gio_dic,
                                basic_tag=False,  # do not be strict (only_tsl=False too).
                                ensembl_canonical_tag=False,
                                prior_basic_tag=True,  # Prioritize basic tag transcript.
                                only_tsl=False)
        assert tr_ids_dic, "most prominent transcript selection from gene infos failed. Please contact developers"
        print("# of transcript IDs (most prominent transcripts): ", len(tr_ids_dic))

    # Check exon order (return True if minus strand exon 1 is most downstream, not most upstream, which is the correct way).
    print("Check minus-strand exon order in --gtf ... ")
    correct_min_ex_order = benchlib.gtf_check_exon_order(args.in_gtf)
    if correct_min_ex_order:
        print("Correct order encountered ... ")
    else:
        print("Reverse order encountered ... ")
    # Get transcript infos.
    print("Read in transcript infos from --gtf ... ")
    tid2tio_dic = benchlib.gtf_read_in_transcript_infos(args.in_gtf, 
                                                        tr_ids_dic=tr_ids_dic,
                                                        correct_min_ex_order=correct_min_ex_order,
                                                        chr_style=chr_style,
                                                        empty_check=False)

    assert tid2tio_dic, "no transcript infos read in from --gtf. Please provide a valid/compatible GTF file (e.g. from Ensembl or ENCODE)"

    # (in)sanity checks.
    for tr_id in tr_ids_dic:
        assert tr_id in tid2tio_dic, "transcript ID %s not in tid2tio_dic"
    for tr_id in tid2tio_dic:
        assert tr_id in tr_ids_dic, "transcript ID %s not in tr_ids_dic"

    c_tr_infos = len(tid2tio_dic)
    print("# transcript features read in from --gtf:", c_tr_infos)

    # Get mRNA region lengths (from transcript IDs with CDS feature).
    print("Get mRNA region lengths ... ")
    tid2regl_dic = benchlib.get_mrna_region_lengths(tid2tio_dic)
    assert tid2regl_dic, "tid2regl_dic empty. Please contact developers"
    c_mrna_tids = len(tid2regl_dic)
    print("# mRNA transcripts (containing CDS):", c_mrna_tids)

    assert c_mrna_tids, "no mRNA transcripts (containing CDS) found in --gtf. Please provide a valid/compatible GTF file (e.g. from Ensembl or ENCODE)"

    # Get transcript sequences.
    print("Extract mRNA sequences ... ")
    tr_seqs_dic = benchlib.get_transcript_sequences_from_gtf(tid2tio_dic, args.in_genome,
                                                             tr_ids_dic=tid2regl_dic,
                                                             tmp_out_folder=args.out_folder)

    # Check once more.
    for tr_id in tid2regl_dic:
        total_len = tid2regl_dic[tr_id][0] + tid2regl_dic[tr_id][1] + tid2regl_dic[tr_id][2]
        assert total_len == len(tr_seqs_dic[tr_id]), "mRNA region lengths do not match extracted sequence lengths. Please contact developers"

    # Output mRNA regions (5'UTR CDS 3'UTR) to BED.
    print("Output mRNA regions to BED ... ")
    benchlib.output_mrna_regions_to_bed(tid2regl_dic, mrna_regions_bed)

    # Get mean / median UTR CDS lengths.
    utr5_len_list = []
    cds_len_list = []
    utr3_len_list = []
    for tr_id in tid2regl_dic:
        utr5_len_list.append(tid2regl_dic[tr_id][0])
        cds_len_list.append(tid2regl_dic[tr_id][1])
        utr3_len_list.append(tid2regl_dic[tr_id][2])
    
    utr5_len_norm = 100
    cds_len_norm = 100
    utr3_len_norm = 100
    norm_mode = "uniform"

    if args.mrna_norm_mode == 1:
        # Median.
        utr5_len_norm = statistics.median(utr5_len_list)
        cds_len_norm = statistics.median(cds_len_list)
        utr3_len_norm = statistics.median(utr3_len_list)
        norm_mode = "median"
        print("Median lengths of mRNA regions:")

    elif args.mrna_norm_mode == 2:
        # Mean.
        utr5_len_norm = statistics.mean(utr5_len_list)
        cds_len_norm = statistics.mean(cds_len_list)
        utr3_len_norm = statistics.mean(utr3_len_list)
        norm_mode = "mean"
        print("Mean lengths of mRNA regions:")

    else:
        assert False, "invalid --mrna-norm-mode %i set" %(args.mrna_norm_mode)

    print("5'UTR = ", utr5_len_norm)
    print("CDS   = ", cds_len_norm)
    print("3'UTR = ", utr3_len_norm)

    norm_mrna_reg_dic = {"5'UTR": utr5_len_norm, "CDS": cds_len_norm, "3'UTR": utr3_len_norm, "mode": norm_mode, "c_mrna_seqs": c_mrna_tids}

    mrna_reg_occ_dic = {}

    for rbp_id, rbp in search_rbps_dic.items():

        mrna_reg_occ_dic[rbp_id] = {}
        # List of length utr5_len_median with 0s.
        mrna_reg_occ_dic[rbp_id]["5'UTR"] = [0] * int(utr5_len_norm)
        mrna_reg_occ_dic[rbp_id]["CDS"] = [0] * int(cds_len_norm)
        mrna_reg_occ_dic[rbp_id]["3'UTR"] = [0] * int(utr3_len_norm)

        for motif_id in rbp.seq_motif_ids:
            mrna_reg_occ_dic[motif_id] = {}
            mrna_reg_occ_dic[motif_id]["5'UTR"] = [0] * int(utr5_len_norm)
            mrna_reg_occ_dic[motif_id]["CDS"] = [0] * int(cds_len_norm)
            mrna_reg_occ_dic[motif_id]["3'UTR"] = [0] * int(utr3_len_norm)

        for motif_id in rbp.str_motif_ids:
            mrna_reg_occ_dic[motif_id] = {}
            mrna_reg_occ_dic[motif_id]["5'UTR"] = [0] * int(utr5_len_norm)
            mrna_reg_occ_dic[motif_id]["CDS"] = [0] * int(cds_len_norm)
            mrna_reg_occ_dic[motif_id]["3'UTR"] = [0] * int(utr3_len_norm)


    # Output sequences to FASTA.
    print("Output mRNA sequences to FASTA ... ")
    benchlib.fasta_output_dic(tr_seqs_dic, mrna_seqs_fa,
                              split=True)

    # # mRNA sequences for search.
    c_regions = len(tr_seqs_dic)

    # Called region size.
    called_reg_size = 0
    len_list = []
    for seq_id in tr_seqs_dic:
        seq_len = len(tr_seqs_dic[seq_id])
        called_reg_size += seq_len
        len_list.append(seq_len)

    eff_reg_size = called_reg_size

    # Length statistics.
    reg_len_median = statistics.median(len_list)
    reg_len_mean = statistics.mean(len_list)
    reg_len_mean = round(reg_len_mean, 2)
    reg_len_min = min(len_list)
    reg_len_max = max(len_list)


    """
    ====================================
    RUN SEQUENCE MOTIF SEARCH WITH FIMO.
    ====================================
    
    """
    fimo_hits_list = []
    call_dic = {}

    if seq_rbps_dic:

        """
        Print motifs to file.

        """

        print("Output motifs to XML ... ")
        out_str, c_added_motifs = benchlib.blocks_to_xml_string(seq_motif_blocks_dic, loaded_motif_ids_dic)

        benchlib.output_string_to_file(out_str, seq_motifs_xml)


        """
        Run FIMO on sequences + motifs.

        """

        print("Run FIMO ... ")
        benchlib.run_fast_fimo(mrna_seqs_fa, seq_motifs_xml, fimo_res_tsv,
                    pval_thr=args.fimo_pval,
                    nt_freqs_file=fimo_freqs_file,
                    call_dic=call_dic,
                    params=fimo_params,
                    error_check=False)

        """
        Read in FIMO hits.

        """

        assert os.path.exists(fimo_res_tsv), "FIMO output file fimo.tsv %s does not exist! There must have been an error while running FIMO (invalid xml file provided?)" %(fimo_res_tsv)

        print("Read in FIMO results ... ")
        fimo_hits_list = benchlib.read_in_fimo_results(fimo_res_tsv,
                                                       seq_based=True)

        c_fimo_hits = len(fimo_hits_list)
        print("# of FIMO motif hits:", c_fimo_hits)

        """
        If --regex is set, search for regex hits in sequences (stored in out_seqs_dic).

        """
        if args.regex:

            step_size_one = False
            if args.regex_search_mode == 1:
                step_size_one = False
            elif args.regex_search_mode == 2:
                step_size_one = True
            else:
                assert False, "invalid --regex-search-mode %i set" %(args.regex_search_mode)

            print("Run search for --regex \"%s\" ... " %(regex))
            regex_hits_list = benchlib.get_regex_hits(regex, regex_id, tr_seqs_dic,
                                                      step_size_one=step_size_one,
                                                      seq_based=True,
                                                      use_motif_regex_id=args.motif_regex_id)

            c_regex_hits = len(regex_hits_list)
            print("# of regex hits:", c_regex_hits)

            # Add regex hits to fimo_hits_list.
            fimo_hits_list += regex_hits_list


    """
    =========================================
    RUN STRUCTURE MOTIF SEARCH WITH CMSEARCH.
    =========================================

    """
    cmsearch_hits_list = []

    if str_rbps_dic:
        
        print("Output covariance models to .cm ... ")
        benchlib.output_cm_blocks_to_file(str_motif_blocks_dic, loaded_motif_ids_dic, str_motifs_cm)

        # Run cmsearch.
        print("Run cmsearch ... ")
        benchlib.run_cmsearch(mrna_seqs_fa, str_motifs_cm, cmsearch_res_txt,
                        error_check=False,
                        call_dic=call_dic,
                        params="-g --tformat fasta --toponly --incT 1 -T 1 --default") # or add --anytrunc and remove --g
        # Read in hits.
        print("Read in cmsearch results ... ")
        cmsearch_hits_list, c_cms_hits = benchlib.read_in_cmsearch_results(cmsearch_res_txt,
                                                                           seq_based=True,
                                                                           check=True)

        print("# of cmsearch motif hits:", c_cms_hits)


    """
    Store for each RBP the regions with motif hits (and hit counts), using
    dictionary of dictionaries regions_with_motifs_dic.
    This tells us, how many input regions have motif hits, separated by RBP.
    Also store for each RBP the unique motif hit regions (and hit counts), using
    dictionary of dictionaries unique_motifs_dic.

    regions_with_motifs_dic:
        Dictionary of dictionaries, format:
        {rbp_id1 -> {'region1': motif_c_region1, 'region2': motif_c_region2}, rbp_id2 -> {'region1': motif_c_region1}}
    unique_motifs_dic:
        Dictionary of dictionaries, format:
        {rbp_id1 -> {'motif_region1': c_motif_region1, 'motif_region2': c_motif_region2}, rbp_id2 -> .. }

    """

    regions_with_motifs_dic = {}
    unique_motifs_dic = {}

    # Store regions with sequence motifs.
    for fh in fimo_hits_list:

        rbp_id = id2name_dic[fh.motif_id]

        if rbp_id in regions_with_motifs_dic:
            # fh.seq_name : FASTA header (== --in genomic sequence region).
            if fh.seq_name in regions_with_motifs_dic[rbp_id]:
                regions_with_motifs_dic[rbp_id][fh.seq_name] += 1
            else:
                regions_with_motifs_dic[rbp_id][fh.seq_name] = 1
        else:
            regions_with_motifs_dic[rbp_id] = {}
            regions_with_motifs_dic[rbp_id][fh.seq_name] = 1

        fh_str = repr(fh) # genomic motif region string.

        # Unique motif regions for each RBP.
        if rbp_id in unique_motifs_dic:
            if fh_str in unique_motifs_dic[rbp_id]:
                unique_motifs_dic[rbp_id][fh_str] += 1
            else:
                unique_motifs_dic[rbp_id][fh_str] = 1
        else:
            unique_motifs_dic[rbp_id] = {}
            unique_motifs_dic[rbp_id][fh_str] = 1

    # Store regions with structure motifs.
    for cmsh in cmsearch_hits_list:

        rbp_id = id2name_dic[cmsh.motif_id]

        if rbp_id in regions_with_motifs_dic:
            # cmsh.seq_name : FASTA header (== --in genomic sequence region).
            if cmsh.seq_name in regions_with_motifs_dic[rbp_id]:
                regions_with_motifs_dic[rbp_id][cmsh.seq_name] += 1
            else:
                regions_with_motifs_dic[rbp_id][cmsh.seq_name] = 1
        else:
            regions_with_motifs_dic[rbp_id] = {}
            regions_with_motifs_dic[rbp_id][cmsh.seq_name] = 1

        cmsh_str = repr(cmsh) # genomic motif region string.

        # Unique motif regions for each RBP.
        if rbp_id in unique_motifs_dic:
            if cmsh_str in unique_motifs_dic[rbp_id]:
                unique_motifs_dic[rbp_id][cmsh_str] += 1
            else:
                unique_motifs_dic[rbp_id][cmsh_str] = 1
        else:
            unique_motifs_dic[rbp_id] = {}
            unique_motifs_dic[rbp_id][cmsh_str] = 1

    """
    Store infos for each RBP in RBP class.

    search_rbps_dic[rbp_id] = rbp_class
    RBP class arguments:
            name: str,
            seq_motif_ids = None,
            str_motif_ids = None,
            c_hit_reg = 0, # # regions with motif hits.
            perc_hit_reg = 0.0, # % hit regions over all regions (i.e. how many input regions contain >= 1 RBP motif).
            c_motif_hits = 0, # # motif hits.
            c_uniq_motif_hits = 0, # # unique motif hits.
            c_uniq_motif_nts = 0, # # unique motif nucleotides.
            perc_uniq_motif_nts_eff_reg = 0.0, # % unique motif nts over effective region length.
            perc_uniq_motif_nts_cal_reg = 0.0, # % unique motif nts over called region length.
            uniq_motif_hits_eff_1000nt = 0.0, # unique motif hits per effective 1000 nt.
            uniq_motif_hits_cal_1000nt = 0.0, # unique motif hits per called 1000 nt.
            ks_pval = 1.0, # Kolmogorov-Smirnov (KS) statistic p-value (are higher scoring sites enriched with motifs).
            ks_stat = 0.0,
            organism: Optional[str] = None

    Number of sequences for FIMO / cmsearch: 
    c_regions

    """
    # Set number of no-hit regions.
    for rbp_id in search_rbps_dic:
        search_rbps_dic[rbp_id].c_no_hit_reg = c_regions

    for rbp_id in regions_with_motifs_dic:
        # Number of --in regions with RBP motif hits.
        c_hit_reg = len(regions_with_motifs_dic[rbp_id])

        # Number of motif hits on --in regions in total.
        c_motif_hits = 0
        for reg_id in regions_with_motifs_dic[rbp_id]:
            c_motif_hits += regions_with_motifs_dic[rbp_id][reg_id]
        search_rbps_dic[rbp_id].c_hit_reg = c_hit_reg
        search_rbps_dic[rbp_id].c_no_hit_reg = c_regions - c_hit_reg
        search_rbps_dic[rbp_id].c_motif_hits = c_motif_hits

        # % hit regions over all regions (i.e. how many input regions contain >= 1 RBP motif).
        search_rbps_dic[rbp_id].perc_hit_reg = (search_rbps_dic[rbp_id].c_hit_reg / c_regions) * 100

    """
    Get unique motif hits.

    unique_motifs_dic:
        Dictionary of dictionaries, format:
        {rbp_id1 -> {'motif_region1': c_motif_region1, 'motif_region2': c_motif_region2}, rbp_id2 -> .. }
    """

    for rbp_id in unique_motifs_dic:
        c_uniq_motif_hits = len(unique_motifs_dic[rbp_id])
        search_rbps_dic[rbp_id].c_uniq_motif_hits = c_uniq_motif_hits
        # Store individual motif unique hits.
        for motif_str_repr in unique_motifs_dic[rbp_id]:
            motif_id = benchlib.get_motif_id_from_str_repr(motif_str_repr)
            idx = motif_id2idx_dic[motif_id]
            if id2type_dic[motif_id] == "meme_xml":
                search_rbps_dic[rbp_id].seq_motif_hits[idx] += 1
            elif id2type_dic[motif_id] == "regex":
                search_rbps_dic[rbp_id].seq_motif_hits[idx] += 1
            elif id2type_dic[motif_id] == "cm":
                search_rbps_dic[rbp_id].str_motif_hits[idx] += 1
            else:
                assert False, "unknown motif type (\"%s\") set for motif_id %s" %(id2type_dic[motif_id], motif_id)

    """
    Number of motif nucleotides over called + effective region size.

    ALAMO

    """

    print("Calculate effective motif region sizes for each RBP ... ")
    for rbp_id in unique_motifs_dic:
        # Ouput unique motif hit regions (sequence or structure) to BED for RBP rbp_id.
        benchlib.output_motif_hits_to_bed(rbp_id, unique_motifs_dic, out_tmp_bed,
                                          one_based_start=True)
        # Calculate effective motif region size.
        eff_motif_reg_size = benchlib.get_uniq_gen_size(out_tmp_bed)

        # Number of unique motif nucleotides.
        search_rbps_dic[rbp_id].c_uniq_motif_nts = eff_motif_reg_size
        # % unique motif nts over effective region length.
        search_rbps_dic[rbp_id].perc_uniq_motif_nts_eff_reg = (eff_motif_reg_size / eff_reg_size) * 100
        # % unique motif nts over called region length.
        search_rbps_dic[rbp_id].perc_uniq_motif_nts_cal_reg = (eff_motif_reg_size / called_reg_size) * 100
        # Number of unique motif hits per effective 1000 nt.
        search_rbps_dic[rbp_id].uniq_motif_hits_eff_1000nt  = search_rbps_dic[rbp_id].c_uniq_motif_hits / (eff_reg_size / 1000)
        # Number of unique motif hits per called 1000 nt.
        search_rbps_dic[rbp_id].uniq_motif_hits_cal_1000nt  = search_rbps_dic[rbp_id].c_uniq_motif_hits / (called_reg_size / 1000)

    """
    # Print RBP object stats.
    for rbp_id in search_rbps_dic:
        print(search_rbps_dic[rbp_id].__dict__)

    """

    # print(search_rbps_dic["AGGF1"].__dict__)
    print("# --in regions for motif search:", c_regions)
    print("Called genomic region size:     ", called_reg_size)
    print("Effective genomic region size:  ", eff_reg_size)


    """
    Output RBP hit stats (ie one row per RBP).

    Output clowns:
    rbp_id
    c_regions
    called_reg_size
    effective_reg_size
    c_reg_with_hits
    perc_reg_with_hits
    c_motif_hits
    c_uniq_motif_hits
    c_uniq_motif_nts
    perc_uniq_motif_nts_cal_reg
    perc_uniq_motif_nts_eff_reg
    uniq_motif_hits_cal_1000nt
    uniq_motif_hits_eff_1000nt
    wc_pval
    seq_motif_ids
    seq_motif_hits
    str_motif_ids
    str_motif_hits

    """

    rbp_list = []

    OUTSTATS = open(rbp_stats_out, "w")
    rbp_stats_header = "data_id\tmethod_id\trun_id\tmotif_db\trbp_id\tc_regions\tmean_reg_len\tmedian_reg_len\tmin_reg_len\tmax_reg_len\t"
    rbp_stats_header += "called_reg_size\teffective_reg_size\tc_reg_with_hits\tperc_reg_with_hits\t"
    rbp_stats_header += "c_motif_hits\tc_uniq_motif_hits\tc_uniq_motif_nts\tperc_uniq_motif_nts_cal_reg\tperc_uniq_motif_nts_eff_reg\tuniq_motif_hits_cal_1000nt\t"
    rbp_stats_header += "uniq_motif_hits_eff_1000nt\twc_pval\tseq_motif_ids\tseq_motif_hits\tstr_motif_ids\tstr_motif_hits\tinternal_id\n"
    OUTSTATS.write(rbp_stats_header)

    for rbp_id in search_rbps_dic:

        # print(search_rbps_dic[rbp_id].__dict__)
        rbp_list.append(rbp_id)

        motif_db_out = loaded_rbps_dic[rbp_id]

        c_reg_with_hits = search_rbps_dic[rbp_id].c_hit_reg
        perc_reg_with_hits = search_rbps_dic[rbp_id].perc_hit_reg
        c_motif_hits = search_rbps_dic[rbp_id].c_motif_hits
        c_uniq_motif_hits = search_rbps_dic[rbp_id].c_uniq_motif_hits
        c_uniq_motif_nts = search_rbps_dic[rbp_id].c_uniq_motif_nts
        perc_uniq_motif_nts_cal_reg = search_rbps_dic[rbp_id].perc_uniq_motif_nts_cal_reg
        perc_uniq_motif_nts_eff_reg = search_rbps_dic[rbp_id].perc_uniq_motif_nts_eff_reg
        uniq_motif_hits_cal_1000nt = search_rbps_dic[rbp_id].uniq_motif_hits_cal_1000nt
        uniq_motif_hits_eff_1000nt = search_rbps_dic[rbp_id].uniq_motif_hits_eff_1000nt
        wc_pval = "-"
        internal_id = search_rbps_dic[rbp_id].internal_id

        seq_motif_hits = ",".join(str(hc) for hc in search_rbps_dic[rbp_id].seq_motif_hits)
        str_motif_hits = ",".join(str(hc) for hc in search_rbps_dic[rbp_id].str_motif_hits)
        seq_motif_ids = ",".join(search_rbps_dic[rbp_id].seq_motif_ids)
        str_motif_ids = ",".join(search_rbps_dic[rbp_id].str_motif_ids)
        if not seq_motif_hits:
            seq_motif_hits = "-"
        if not str_motif_hits:
            str_motif_hits = "-"
        if not seq_motif_ids:
            seq_motif_ids = "-"
        if not str_motif_ids:
            str_motif_ids = "-"

        row_str = args.data_id + "\t"
        row_str += args.method_id + "\t"
        row_str += run_id + "\t"
        row_str += motif_db_out + "\t"
        row_str += rbp_id + "\t"

        row_str += str(c_regions) + "\t"

        row_str += str(reg_len_mean) + "\t"
        row_str += str(reg_len_median) + "\t"
        row_str += str(reg_len_min) + "\t"
        row_str += str(reg_len_max) + "\t"

        row_str += str(called_reg_size) + "\t"
        row_str += str(eff_reg_size) + "\t"

        row_str += str(c_reg_with_hits) + "\t"
        row_str += str(perc_reg_with_hits) + "\t"

        row_str += str(c_motif_hits) + "\t"
        row_str += str(c_uniq_motif_hits) + "\t"
        row_str += str(c_uniq_motif_nts) + "\t"
        row_str += str(perc_uniq_motif_nts_cal_reg) + "\t"
        row_str += str(perc_uniq_motif_nts_eff_reg) + "\t"
        row_str += str(uniq_motif_hits_cal_1000nt) + "\t"
        row_str += str(uniq_motif_hits_eff_1000nt) + "\t"
        row_str += wc_pval + "\t"
        row_str += seq_motif_ids + "\t"
        row_str += seq_motif_hits + "\t"
        row_str += str_motif_ids + "\t"
        row_str += str_motif_hits + "\t"
        row_str += internal_id + "\n"

        OUTSTATS.write(row_str)

    OUTSTATS.close()


    """
    Output motif region stats (1 row for each motif hit).
    Report ALL motif hits,
    plus report how many times one genomic motif hit occurs (uniq_count). 

    """

    motif_hit2annot_dic = {}

    OUTSTATS = open(motif_stats_out,"w")

    motif_stats_header = "data_id\tmethod_id\trun_id\tmotif_db\tregion_id\trbp_id\tmotif_id\tchr_id\tgen_s\tgen_e\tstrand\tregion_s\tregion_e\tregion_len\t"
    motif_stats_header += "uniq_count\tfimo_score\tfimo_pval\tcms_score\tcms_eval\tinternal_id\n"
    OUTSTATS.write(motif_stats_header)

    # Unique motif regions BED.
    motif_reg_dic = {}

    for fh in fimo_hits_list:

        rbp_id = id2name_dic[fh.motif_id]
        region_id = fh.seq_name
        region_len = len(tr_seqs_dic[region_id])
        # genomic motif region string.
        fh_str = repr(fh)
        uniq_count = unique_motifs_dic[rbp_id][fh_str]

        motif_db_out = loaded_motif_ids_dic[fh.motif_id]

        internal_id = search_rbps_dic[rbp_id].internal_id

        # Center position of motif hit.
        motif_hit_s = fh.start - 1
        motif_hit_e = fh.end
        tr_id = fh.chr_id
        center_pos = benchlib.get_center_position(motif_hit_s, motif_hit_e)  # 1-based center position.

        utr5_len = tid2regl_dic[tr_id][0]
        cds_len = tid2regl_dic[tr_id][1]
        utr3_len = tid2regl_dic[tr_id][2]

        utr5_e = utr5_len
        cds_s = utr5_e
        cds_e = cds_s + cds_len
        utr3_s = cds_e
        utr3_e = utr3_s + utr3_len

        annot = ["intergenic", False]

        if center_pos <= utr5_e:  # In 5'UTR.

            occ_pos = round((center_pos / utr5_len) * utr5_len_norm)
            if occ_pos > 0:
                occ_pos -= 1
            mrna_reg_occ_dic[rbp_id]["5'UTR"][occ_pos] += 1
            mrna_reg_occ_dic[fh.motif_id]["5'UTR"][occ_pos] += 1

            annot = ["5'UTR", tr_id]

        elif center_pos > utr5_e and center_pos <= cds_e:  # In CDS.

            occ_pos = round(((center_pos - utr5_e) / cds_len) * cds_len_norm)
            if occ_pos > 0:
                occ_pos -= 1
            mrna_reg_occ_dic[rbp_id]["CDS"][occ_pos] += 1
            mrna_reg_occ_dic[fh.motif_id]["CDS"][occ_pos] += 1

            annot = ["CDS", tr_id]
        
        elif center_pos > cds_e and center_pos <= utr3_e:  # In 3'UTR.

            occ_pos = round(((center_pos - cds_e) / utr3_len) * utr3_len_norm)
            if occ_pos > 0:
                occ_pos -= 1
            mrna_reg_occ_dic[rbp_id]["3'UTR"][occ_pos] += 1
            mrna_reg_occ_dic[fh.motif_id]["3'UTR"][occ_pos] += 1

            annot = ["3'UTR", tr_id]

        else:
            assert False, "center position %i not in 5'UTR, CDS or 3'UTR of transcript ID %s (transcript length: %i)" %(center_pos, tr_id, len(tr_seqs_dic[tr_id]))

        # Store motif hit as BED.
        hit_id = "%s:%s-%s(%s),%s" %(fh.chr_id, str(fh.start), str(fh.end), fh.strand, fh.motif_id)

        motif_hit2annot_dic[hit_id] = annot

        if hit_id not in motif_reg_dic:
            bed_row = "%s\t%i\t%i\t%s,%s;%i;%s,%s\t0\t%s\t%s\t%s\t-1.0\t-1.0" %(fh.chr_id, fh.start-1, fh.end, rbp_id, fh.motif_id, uniq_count, args.method_id, args.data_id, fh.strand, str(fh.score), str(fh.pval))
            motif_reg_dic[hit_id] = bed_row

        row_str = args.data_id + "\t"
        row_str += args.method_id + "\t"
        row_str += run_id + "\t"
        row_str += motif_db_out + "\t"
        row_str += region_id + "\t"
        row_str += rbp_id + "\t"
        row_str += fh.motif_id + "\t"
        row_str += fh.chr_id + "\t"
        row_str += str(fh.start) + "\t"  # 1-based.
        row_str += str(fh.end) + "\t"
        row_str += fh.strand + "\t"
        row_str += str(fh.seq_s) + "\t"  # 1-based.
        row_str += str(fh.seq_e) + "\t"
        row_str += str(region_len) + "\t"
        row_str += str(uniq_count) + "\t"
        row_str += str(fh.score) + "\t"
        row_str += str(fh.pval) + "\t"
        row_str += "-\t"
        row_str += "-\t"
        row_str += internal_id + "\n"

        OUTSTATS.write(row_str)

    for cmsh in cmsearch_hits_list:

        rbp_id = id2name_dic[cmsh.motif_id]
        region_id = cmsh.seq_name
        region_len = len(tr_seqs_dic[region_id])
        # genomic motif region string.
        cmsh_str = repr(cmsh) 
        uniq_count = unique_motifs_dic[rbp_id][cmsh_str]

        motif_db_out = loaded_motif_ids_dic[cmsh.motif_id]

        internal_id = search_rbps_dic[rbp_id].internal_id

        # Center position of motif hit.
        motif_hit_s = cmsh.start - 1
        motif_hit_e = cmsh.end
        tr_id = fh.chr_id
        center_pos = benchlib.get_center_position(motif_hit_s, motif_hit_e)  # 1-based center position.

        utr5_len = tid2regl_dic[tr_id][0]
        cds_len = tid2regl_dic[tr_id][1]
        utr3_len = tid2regl_dic[tr_id][2]

        utr5_e = utr5_len
        cds_s = utr5_e
        cds_e = cds_s + cds_len
        utr3_s = cds_e
        utr3_e = utr3_s + utr3_len

        annot = ["intergenic", False]

        if center_pos <= utr5_e:  # In 5'UTR.

            occ_pos = round((center_pos / utr5_len) * utr5_len_norm)
            mrna_reg_occ_dic[rbp_id]["5'UTR"][occ_pos] += 1
            mrna_reg_occ_dic[cmsh.motif_id]["5'UTR"][occ_pos] += 1

            annot = ["5'UTR", tr_id]

        elif center_pos > utr5_e and center_pos <= cds_e:  # In CDS.

            occ_pos = round(((center_pos - utr5_e) / cds_len) * cds_len_norm)
            mrna_reg_occ_dic[rbp_id]["CDS"][occ_pos] += 1
            mrna_reg_occ_dic[cmsh.motif_id]["CDS"][occ_pos] += 1
        
            annot = ["CDS", tr_id]

        elif center_pos > cds_e and center_pos <= utr3_e:  # In 3'UTR.

            occ_pos = round(((center_pos - cds_e) / utr3_len) * utr3_len_norm)
            mrna_reg_occ_dic[rbp_id]["3'UTR"][occ_pos] += 1
            mrna_reg_occ_dic[cmsh.motif_id]["3'UTR"][occ_pos] += 1

            annot = ["3'UTR", tr_id]

        else:
            assert False, "center position %i not in 5'UTR, CDS or 3'UTR of transcript ID %s (transcript length: %i)" %(center_pos, tr_id, len(tr_seqs_dic[tr_id]))

        # Store motif hit as BED.
        hit_id = "%s:%s-%s(%s),%s" %(cmsh.chr_id, str(cmsh.start), str(cmsh.end), cmsh.strand, cmsh.motif_id)

        motif_hit2annot_dic[hit_id] = annot

        if hit_id not in motif_reg_dic:
            bed_row = "%s\t%i\t%i\t%s,%s;%i;%s,%s\t0\t%s\t%s\t%s\t-1.0\t-1.0" %(cmsh.chr_id, cmsh.start-1, cmsh.end, rbp_id, cmsh.motif_id, uniq_count, args.method_id, args.data_id, cmsh.strand, str(cmsh.score), str(cmsh.e_value))
            motif_reg_dic[hit_id] = bed_row

        row_str = args.data_id + "\t"
        row_str += args.method_id + "\t"
        row_str += run_id + "\t"
        row_str += motif_db_out + "\t"
        row_str += region_id + "\t"
        row_str += rbp_id + "\t"
        row_str += cmsh.motif_id + "\t"
        row_str += cmsh.chr_id + "\t"
        row_str += str(cmsh.start) + "\t"
        row_str += str(cmsh.end) + "\t"
        row_str += cmsh.strand + "\t"
        row_str += str(cmsh.seq_s) + "\t"
        row_str += str(cmsh.seq_e) + "\t"
        row_str += str(region_len) + "\t"
        row_str += str(uniq_count) + "\t"
        row_str += "-\t"
        row_str += "-\t"
        row_str += str(cmsh.score) + "\t"
        row_str += str(cmsh.e_value) + "\t"
        row_str += internal_id + "\n"
        #print("region_id:", region_id)
        #print("evalue:", cmsh.e_value)
        #print(row_str)

        OUTSTATS.write(row_str)

    OUTSTATS.close()

    """
    Output motif hits as BED.

    The motif hits written to motif_hits_bed_out are unique motif hits already. 
    If same hit occurs > 1, this is recorded in BED column 4 with format:
    rbp_id,motif_id;uniq_count;method_id,data_id
    These also include regex hits, as they are part of fimo hits.
    
    """

    OUTBED = open(motif_hits_bed_out,"w")
    for hit_id in motif_reg_dic:
        OUTBED.write("%s\n" %(motif_reg_dic[hit_id]))
    OUTBED.close()

    """
    Motif annotations (mRNA regions only).

    """

    rbp2motif2annot2c_dic = {}  # rbp_id -> motif_id -> annot -> count

    for motif_hit in motif_hit2annot_dic:
        # motif_hit format: "chr1:10-15(+),motif_id". Get motif_id.
        motif_id = motif_hit.split(",")[1]
        annot = motif_hit2annot_dic[motif_hit][0]
        # tr_id = motif_hit2annot_dic[motif_hit][1]
        rbp_id = id2name_dic[motif_id]
        if rbp_id not in rbp2motif2annot2c_dic:
            rbp2motif2annot2c_dic[rbp_id] = {}
        if motif_id not in rbp2motif2annot2c_dic[rbp_id]:
            rbp2motif2annot2c_dic[rbp_id][motif_id] = {}
        if annot not in rbp2motif2annot2c_dic[rbp_id][motif_id]:
            rbp2motif2annot2c_dic[rbp_id][motif_id][annot] = 1
        else:
            rbp2motif2annot2c_dic[rbp_id][motif_id][annot] += 1

    """
    Get annotation to color dictionary, which is needed for region annotation plots in HTML reports.

    """

    annot2color_dic = {}

    if rbp2motif2annot2c_dic:

        annot_dic = {}

        if rbp2motif2annot2c_dic:
            for rbp_id in rbp2motif2annot2c_dic:
                for motif_id in rbp2motif2annot2c_dic[rbp_id]:
                    for annot in rbp2motif2annot2c_dic[rbp_id][motif_id]:
                        if annot not in annot_dic:
                            annot_dic[annot] = 1
                        else:
                            annot_dic[annot] += 1

        # hex_colors = get_hex_colors_list(min_len=len(annot_with_hits_dic))
        hex_colors = benchlib.get_hex_colors_list(min_len=len(annot_dic))

        idx = 0
        for annot in sorted(annot_dic, reverse=False):
            # hc = hex_colors[idx]
            # print("Assigning hex color %s to annotation %s ... " %(hc, annot))
            annot2color_dic[annot] = hex_colors[idx]
            idx += 1


    """
    Motif plots and motif hit statistics HTML.

    """
    
    html_motif_plots_out = args.out_folder + "/" + "motif_plots.rbpbench_searchmrna.html"
    if args.plot_abs_paths:
        html_motif_plots_out = os.path.abspath(args.out_folder) + "/" + "motif_plots.rbpbench_searchmrna.html"
    # If HTML file already exists, remove it.
    if os.path.exists(html_motif_plots_out):
        os.remove(html_motif_plots_out)

    print("Generate motif plots HTML ... ")
    
    plots_subfolder = "html_motif_plots"
    benchlib_path = os.path.dirname(benchlib.__file__)

    benchlib.search_generate_html_motif_plots(search_rbps_dic, seq_motif_blocks_dic, 
                                        str_motif_blocks_dic, args.out_folder, 
                                        benchlib_path, loaded_motif_ids_dic,
                                        motif_db_str=motif_db_str,
                                        rbp2motif2annot2c_dic=rbp2motif2annot2c_dic,
                                        annot2color_dic=annot2color_dic,
                                        mrna_reg_occ_dic=mrna_reg_occ_dic,
                                        norm_mrna_reg_dic=norm_mrna_reg_dic,
                                        regex_id=regex_id,
                                        sort_js_mode=args.sort_js_mode,
                                        html_report_out=html_motif_plots_out,
                                        plot_abs_paths=args.plot_abs_paths,
                                        rbpbench_mode="searchmrna",
                                        plots_subfolder=plots_subfolder)


    """
    Output parameter settings.

    """
    # Output mode settings.
    print("Output parameter settings ... ")
    SETOUT = open(settings_file, "w")
    for arg in vars(args):
        SETOUT.write("%s\t%s\n" %(arg, str(getattr(args, arg))))
    for call in call_dic:
        SETOUT.write("%s\t%s\n" %(call, call_dic[call]))
    SETOUT.close()

    """
    Take out the trash.

    """
    print("Delete .tmp files ... ")
    if os.path.exists(out_tmp_bed):
        os.remove(out_tmp_bed)
    if os.path.exists(cmstat_tmp_out):
        os.remove(cmstat_tmp_out)


    """
    Inform about outputs.

    """
    print("")
    print("OUTPUT FILES")
    print("============")
    print("")
    print("Run parameter settings:\n%s" %(settings_file))
    print("mRNA regions .bed:\n%s" %(mrna_regions_bed))
    print("Motif hits .bed:\n%s" %(motif_hits_bed_out))
    print("RBP hit stats .tsv:\n%s" %(rbp_stats_out))
    print("Motif hit stats .tsv:\n%s" %(motif_stats_out))
    print("Motif plots and hit statistics .html:\n%s" %(html_motif_plots_out))
    print("")


################################################################################

def main_searchmrna(args):
    """
    Motif search in mRNA sequences.

    """

    print("Running for you in SEARCHMRNA mode ... ")

    assert os.path.exists(args.in_gtf), "--gtf file \"%s\" not found" % (args.in_gtf)
    assert os.path.exists(args.in_genome), "--genome file \"%s\" not found" % (args.in_genome)

    assert benchlib.boundary_check(args.gtf_feat_min_overlap, 1E-9, 1.0), "set --gtf-feat-min-overlap expected to be >= 1E-9 and <= 1.0"

    # Is MEME >= v5 installed?
    if not args.meme_disable_check:
        assert benchlib.is_tool("meme"), "meme not in PATH"
        check, meme_version = benchlib.check_tool_version("meme -version", "5.0")
        assert check, "RBPBench requires meme version >= 5.0 (installed version: %s)" %(meme_version)

    # Check if MEME version is >= 5.5.4 (need to add fimo --no-pgc option to produce same results!).
    fimo_params = "--norc --verbosity 1 --skip-matched-sequence --text"
    if not args.meme_disable_check:
        check, meme_version = benchlib.check_tool_version("meme -version", "5.5.4")
        if check:
            fimo_params = "--norc --verbosity 1 --skip-matched-sequence --text --no-pgc"
    if args.meme_no_pgc:
        fimo_params = "--norc --verbosity 1 --skip-matched-sequence --text --no-pgc"

    # Regex check.
    if args.regex:
        assert benchlib.is_valid_regex(args.regex), "given --regex \"%s\" is not a valid regular expression. Please provide valid expression" % (args.regex)

    """
    Library path.
    """
    benchlib_path = os.path.dirname(benchlib.__file__)
    db_path = benchlib_path + "/content"

    """
    FIMO nt frequencies.
    """
    fimo_freqs_file = db_path + "/fimo_nt_freqs.txt"
    if args.fimo_nt_freqs:
        fimo_freqs_file = args.fimo_nt_freqs
    assert os.path.exists(fimo_freqs_file), "set FIMO nucleotide frequencies file \"%s\" not found" % (fimo_freqs_file)

    """
    Motif database.
    """
    seq_motifs_db_file, str_motifs_db_file, rbp2ids_file, motif_db_str = specify_motif_db(args.motif_db, 
                                                                            db_path=db_path)
    # Custom motif database: folder given.
    if args.custom_db:
        assert not args.custom_db_meme_xml, "--custom-db folder set incompatible with --custom-db-meme-xml. Provide custom motif database either via folder (--custom-db) or as single files"
        assert not args.custom_db_cm, "--custom-db folder set incompatible with --custom-db-cm. Provide custom motif database either via folder (--custom-db) or as single files"
        assert not args.custom_db_info, "--custom-db folder set incompatible with --custom-db-info. Provide custom motif database either via folder (--custom-db) or as single files"
        seq_motifs_db_file, str_motifs_db_file, rbp2ids_file = specify_custom_motif_db(args.custom_db)
        motif_db_str = args.custom_db_id
    # Custom motif database: single files given.
    if args.custom_db_meme_xml or args.custom_db_cm or args.custom_db_info:
        motif_db_str = args.custom_db_id
        assert not args.custom_db, "single custom motif database files provided not compatible with --custom-db. Provide custom motif database either via folder (--custom-db) or as single files"
        assert args.custom_db_info, "--custom-db-info needed to define custom motif database"
        rbp2ids_file = args.custom_db_info
        assert args.custom_db_meme_xml or args.custom_db_cm, "--custom-db-meme-xml and/or --custom-db-cm needed to define custom motif database"
        if args.custom_db_meme_xml:
            seq_motifs_db_file = args.custom_db_meme_xml
        else:
            seq_motifs_db_file = ""  # setting to empty string results in os.path.exists -> False.
        if args.custom_db_cm:
            str_motifs_db_file = args.custom_db_cm
        else:
            str_motifs_db_file = ""

    args.motif_db_str = motif_db_str

    """
    Get ID mappings

    name2ids_dic:
    RBP name -> motif IDs mapping
    id2type_dic:
    motif ID -> motif type (cm, meme_xml)
    id2org_dic (ignore for now):
    motif ID -> organism ID (so far only "human")

    """
    name2ids_dic, id2type_dic = benchlib.get_rbp_id_mappings(rbp2ids_file)
    # Motif ID -> RBP name (== RBP ID) mapping.
    id2name_dic = {}
    for rbp_id in name2ids_dic:
        for motif_id in name2ids_dic[rbp_id]:
            id2name_dic[motif_id] = rbp_id

    """
    Get MEME XML database motif blocks dictionary.

    """
    seq_motif_blocks_dic = {}
    if os.path.exists(seq_motifs_db_file):
        seq_motif_blocks_dic = benchlib.read_in_xml_motifs(seq_motifs_db_file,
                                                           empty_check=True)
    for motif_id in seq_motif_blocks_dic:
        assert motif_id in id2name_dic, "MEME XML motif ID %s not found in prior mapping. Please contact developers!" %(motif_id)

    """
    Get covariance model database motif blocks dictionary.

    """
    str_motif_blocks_dic = {}
    if os.path.exists(str_motifs_db_file):
        str_motif_blocks_dic = benchlib.read_in_cm_blocks(str_motifs_db_file, 
                                                          empty_check=True)
    for motif_id in str_motif_blocks_dic:
        assert motif_id in id2name_dic, "Covariance model accession ID %s not found in prior mapping. Please contact developers!" %(motif_id)

    # Remove special chars from run ID.
    args.data_id = benchlib.remove_special_chars_from_str(args.data_id)
    assert args.data_id, "empty string after removing special chars from --data-id. Please provide alphanumeric string for data ID (- or _ are okay as well)"
    args.method_id = benchlib.remove_special_chars_from_str(args.method_id)
    assert args.method_id, "empty string after removing special chars from --method-id. Please provide alphanumeric string for method ID (- or _ are okay as well)"
    # Run ID definition.
    run_id = "run_id"
    if args.run_id:
        run_id = benchlib.remove_special_chars_from_str(args.run_id)
        assert run_id, "empty string after removing special chars from --run-id. Please provide alphanumeric string for run ID (- or _ are okay as well)"

    print("Run ID:     ", run_id)
    print("Data ID:    ", args.data_id)
    print("Method ID:  ", args.method_id)


    """
    Output folders + files.

    """
    if not os.path.exists(args.out_folder):
        os.makedirs(args.out_folder)

    mrna_seqs_fa = args.out_folder + "/mrna_sequences.fa"
    mrna_regions_bed = args.out_folder + "/mrna_regions.bed"  # UTR CDS regions on mRNAs (i.e. transcript context).
    seq_motifs_xml = args.out_folder + "/seq_motifs.xml"
    str_motifs_cm = args.out_folder + "/str_motifs.cm"
    fimo_res_tsv = args.out_folder + "/fimo_results.tsv"
    cmsearch_res_txt = args.out_folder + "/cmsearch_results.txt"

    rbp_stats_out = args.out_folder + "/rbp_hit_stats.tsv"
    motif_stats_out = args.out_folder + "/motif_hit_stats.tsv"
    # con_res_out_tsv = args.out_folder + "/contingency_table_results.tsv"
    settings_file = args.out_folder + "/settings.find_motifs.out"
    # rbp_reg_occ_table_out = args.out_folder + "/rbp_region_occupancies.tsv"

    # Output unique motif hits.
    motif_hits_bed_out = args.out_folder + "/motif_hits.rbpbench_searchmrna.bed"

    out_tmp_bed = args.out_folder + "/rbp_motif_hit_regions.tmp.bed"
    cmstat_tmp_out = args.out_folder + "/cmstat_out.tmp.txt"

    # Delete if existing folder.
    if os.path.exists(fimo_res_tsv):
        os.remove(fimo_res_tsv)
    if os.path.exists(cmsearch_res_txt):
        os.remove(cmsearch_res_txt)


    """
    Load RBP data based on --rbps (+ optionally USER data).

    """

    rbp_in_dic = {}
    for rbp_id in args.list_rbps:
        rbp_in_dic[rbp_id] = 1

    # RBPs for motif search.
    loaded_rbps_dic = {}

    # USER set?
    user_motifs = False
    user_rbp_id = False
    if "USER" in rbp_in_dic:
        user_motifs = True
    else:
        assert not args.user_meme_xml, "--user-meme-xml provided but --rbps USER not set. Please add USER to --rbps list to search for user-supplied motifs"
        assert not args.user_cm, "--user-cm provided but --rbps USER not set. Please add USER to --rbps list to search for user-supplied motifs"
        assert not args.user_rbp_id, "--user-rbp-id set but --rbps USER not set. Please add USER to --rbps list to search for user-supplied motifs"

    # If ALL set, load all RBPs (+ optinally USER).
    if "ALL" in rbp_in_dic:
        if len(rbp_in_dic) == 2:
            assert user_motifs, "set --rbps ALL, --rbps ALL USER, or individual RBPs (+ optinally USER) --rbps RBP1 RBP2 ... USER"
        if len(rbp_in_dic) > 2:
            assert False, "set --rbps ALL, --rbps ALL USER, or individual RBPs (+ optinally USER) --rbps RBP1 RBP2 ... USER"
        print("--rbps ALL selected. Loading all database motifs ... ")
        for rbp_id in name2ids_dic:
            loaded_rbps_dic[rbp_id] = motif_db_str

    else:
        # Load individual RBPs.
        for rbp_id in rbp_in_dic:
            if rbp_id != "USER":
                """
                Check if RBP ID in database.
                Suggest similar RBPs based on string similarity (edit distance).

                """
                if rbp_id not in name2ids_dic:
                    db_rbp_list = []
                    for db_rbp_id in name2ids_dic:
                        db_rbp_list.append(db_rbp_id)
                    pair_dist_dic = benchlib.calc_edit_dist_query_list(rbp_id, db_rbp_list)
                    max_c = 10
                    c = 0
                    suggested_rbps = []
                    for key, value in sorted(pair_dist_dic.items(), key=lambda item: item[1], reverse=False):
                        if c >= max_c:
                            break
                        c += 1
                        suggested_rbps.append(key)
                    suggested_rbps_str = ",".join(suggested_rbps)
                    assert False, "provided --rbps ID %s not in internal motif database (%s). Please provide RBP name present in database. Did you mean (any of) the following database ID(s) (top 10 hits based on string similarity): %s ?" %(rbp_id, motif_db_str, suggested_rbps_str)
                # assert rbp_id in name2ids_dic, "provided --rbps ID %s not in internal motif database. Please provide RBP name present in database" %(rbp_id)
                loaded_rbps_dic[rbp_id] = motif_db_str

    # Motif IDs for search.
    loaded_motif_ids_dic = {}
    for rbp_id in loaded_rbps_dic:
        for motif_id in name2ids_dic[rbp_id]:
            loaded_motif_ids_dic[motif_id] = motif_db_str

    """
    Check and load provided USER data.

    """

    if user_motifs:
        print("--rbps USER selected. Check + load provided USER motifs ... ")
        assert args.user_rbp_id, "--rbps USER demands --user-rbp-id to be set to connect the supplied motif(s) with an RBP ID"
        assert args.user_meme_xml or args.user_cm, "--rbps USER requires a provided sequence or structure motif file (via --user-meme-xml AND/OR --user-cm)"

        # Reformat user_rbp_id. 
        user_rbp_id = benchlib.remove_special_chars_from_str(args.user_rbp_id)
        assert user_rbp_id, "empty string after removing special chars from --user-rbp-id. Please provide alphanumeric string for RBP ID (- or _ are okay as well)"

        assert user_rbp_id not in loaded_rbps_dic, "user RBP ID %s already selected from database. Please deselect respective database RBP ID or provide unique user RBP ID via --user-rbp-id" %(user_rbp_id)
        loaded_rbps_dic[user_rbp_id] = "user"
        # In case user_rbp_id in database, reset motif IDs associated to user_rbp_id.
        name2ids_dic[user_rbp_id] = []
        print("RBP ID for user-supplied motifs:", user_rbp_id)

        user_seq_motif_blocks_dic = {}
        if args.user_meme_xml:
            assert os.path.exists(args.user_meme_xml), "--user-meme-xml file \"%s\" not found" % (args.user_meme_xml)
            user_seq_motif_blocks_dic = benchlib.read_in_xml_motifs(args.user_meme_xml, empty_check=False)
            assert user_seq_motif_blocks_dic, "no motifs read in from provided --user-meme-xml. Make sure to supply sequence motifs in MEME XML format!"
            # Check if motif ID already loaded.
            for acc_id in user_seq_motif_blocks_dic:
                assert acc_id not in loaded_motif_ids_dic, "user-supplied MEME XML motif ID %s already selected, i.e., ID is already associated with selected database RBP %s. Please change user motif ID to a unique motif ID or deselect the respective RBP" %(acc_id, id2name_dic[acc_id])
                loaded_motif_ids_dic[acc_id] = "user"
                # Add user to database blocks (overwrite if same ID encountered).
                seq_motif_blocks_dic[acc_id] = user_seq_motif_blocks_dic[acc_id]
                name2ids_dic[user_rbp_id].append(acc_id)
                id2type_dic[acc_id] = "meme_xml"
                id2name_dic[acc_id] = user_rbp_id

        user_str_motif_blocks_dic = {}
        if args.user_cm:
            assert os.path.exists(args.user_cm), "--user-cm file \"%s\" not found" % (args.user_cm)
            # Check for valid format.
            acc_ids_dic = benchlib.check_cm_file(args.user_cm, cmstat_tmp_out, empty_check=False)
            # Read in covariance model blocks.
            user_str_motif_blocks_dic = benchlib.read_in_cm_blocks(args.user_cm)
            for acc_id in acc_ids_dic:
                assert acc_id in user_str_motif_blocks_dic, "accession ID %s not in blocks dictionary. Please contact developers!" %(acc_id)
            # Check if motif ID already loaded.
            for acc_id in user_str_motif_blocks_dic:
                assert acc_id not in loaded_motif_ids_dic, "user-supplied covariance model accession (ACC) ID %s already selected, i.e., ID is already associated with selected database RBP %s. Please change to a unique accession ID or deselect the respective RBP" %(acc_id, id2name_dic[acc_id])
                loaded_motif_ids_dic[acc_id] = "user"
                # Add user to database blocks (overwrite if same ID encountered).
                str_motif_blocks_dic[acc_id] = user_str_motif_blocks_dic[acc_id]
                name2ids_dic[user_rbp_id].append(acc_id)
                id2type_dic[acc_id] = "cm"
                id2name_dic[acc_id] = user_rbp_id

    """
    Check if loaded RBP IDs have motifs.

    """
    for rbp_id in loaded_rbps_dic:
        for motif_id in name2ids_dic[rbp_id]:
            found = 0
            if motif_id in seq_motif_blocks_dic:
                found += 1
            if motif_id in str_motif_blocks_dic:
                found += 1
            assert found, "no motifs loaded for RBP ID \"%s\". Please provide the respective motifs file" %(rbp_id)


    """
    If --regex is set:
    Treat regex as sequence motif / fimo type.
    rbp_id: regex, motif_id: regex, motif_db: regex
    
    """

    regex_id = args.regex_id
    regex = args.regex
    
    if args.regex:

        # Remove , ; from given regex, to avoid motif_id format conflicts.
        regex = benchlib.remove_special_chars_from_str(args.regex,
                                                       reg_ex="[,;]")
        
        assert regex, "empty string after removing special chars from --regex. Please provide a valid regex with DNA letters"

        regex_id = benchlib.remove_special_chars_from_str(args.regex_id)

        assert regex_id, "empty string after removing special chars from --regex-id. Please provide alphanumeric string for regex ID (- or _ are okay as well)"
        assert regex_id not in name2ids_dic, "--regex set but a different RBP ID with name \"%s\" was found. Please provide a different RBP ID or --regex-id" %(regex_id)

        if args.motif_regex_id:
            assert regex_id not in id2type_dic, "--regex set but a different motif ID with name \"%s\" was found. Please provide a different motif ID or --regex-id" %(regex_id)

            id2name_dic[regex_id] = regex_id    # motif_id -> rbp_id
            id2type_dic[regex_id] = "regex"  # motif_id -> motif type string; motif type string can be regex, cm, meme_xml
            loaded_motif_ids_dic[regex_id] = regex_id  # motif_id -> motif_db_str
            name2ids_dic[regex_id] = [regex_id]  # rbp_id -> motif_ids

        else:
            assert regex not in id2type_dic, "--regex set but a different motif ID with name \"%s\" was found. Please provide a different motif ID or use --motif-regex-id" %(regex_id)

            id2name_dic[regex] = regex_id    # motif_id -> rbp_id
            id2type_dic[regex] = "regex"  # motif_id -> motif type string; motif type string can be regex, cm, meme_xml
            loaded_motif_ids_dic[regex] = regex_id  # motif_id -> motif_db_str
            name2ids_dic[regex_id] = [regex]  # rbp_id -> motif_ids

        loaded_rbps_dic[regex_id] = regex_id  # rbp_id -> motif_db_str


    """
    Load RBP data, store in RBP() class.

    """

    # Store motif IDs for search.
    search_rbps_dic = {}
    seq_rbps_dic = {}
    str_rbps_dic = {}
    motif_id2idx_dic = {} # motif ID -> list index.
    args.internal_id = []

    for rbp_id in loaded_rbps_dic:
    
        internal_id = base64.urlsafe_b64encode(os.urandom(6)).decode()
        args.internal_id.append(internal_id)
        rbp = benchlib.RBP(rbp_id, internal_id)

        for motif_id in name2ids_dic[rbp_id]:
        
            assert motif_id in loaded_motif_ids_dic, "motif_id %s not in loaded_motif_ids_dic" %(motif_id)

            if id2type_dic[motif_id] == "meme_xml":
                rbp.seq_motif_ids.append(motif_id)
                motif_id2idx_dic[motif_id] = len(rbp.seq_motif_ids) - 1
                rbp.seq_motif_hits.append(0)
                seq_rbps_dic[rbp_id] = 1
            elif id2type_dic[motif_id] == "regex":
                rbp.seq_motif_ids.append(motif_id)
                motif_id2idx_dic[motif_id] = len(rbp.seq_motif_ids) - 1
                rbp.seq_motif_hits.append(0)
                seq_rbps_dic[rbp_id] = 1
            elif id2type_dic[motif_id] == "cm":
                rbp.str_motif_ids.append(motif_id)
                motif_id2idx_dic[motif_id] = len(rbp.str_motif_ids) - 1
                rbp.str_motif_hits.append(0)
                str_rbps_dic[rbp_id] = 1
            else:
                assert False, "unknown motif type (\"%s\") set for motif_id %s" %(id2type_dic[motif_id], motif_id)

        search_rbps_dic[rbp_id] = rbp


    print("# of RBP IDs for search:    ", len(loaded_rbps_dic))
    print("# of motif IDs for search:  ", len(loaded_motif_ids_dic))

    """
    Get chromosome IDs from --genome.
    """
    print("Get --genome FASTA headers ... ")
    chr_ids_dic = benchlib.get_fasta_headers(args.in_genome)

    """
    Guess chromosome ID style.

    chr_style:
        1: chr1, chr2, ..., chrX, chrM
        2: 1, 2, ... , X, MT

    """
    chr_style = 0  # no changes to chromosome IDs in GTF files.
    
    if "1" in chr_ids_dic:
        assert "chr1" not in chr_ids_dic, "inconsistent chromosome IDs in --genome FASTA file (both chr1 and 1)"
    if "chr1" in chr_ids_dic:
        assert "1" not in chr_ids_dic, "inconsistent chromosome IDs in --genome FASTA file (both chr1 and 1)"
    if "chr1" in chr_ids_dic:
        chr_style = 1
    if "1" in chr_ids_dic:
        chr_style = 2


    """
    Read in gene infos from --gtf.

    """

    # reg_annot_table_file = args.out_folder + "/" + "region_annotations.tsv"

    print("Read in gene features from --gtf ... ")
    tr2gid_dic = {}
    tr_types_dic = {}  # Store transcript biotypes in GTF file.
    gid2gio_dic = benchlib.gtf_read_in_gene_infos(args.in_gtf,
                                                    tr2gid_dic=tr2gid_dic,
                                                    tr_types_dic=tr_types_dic,
                                                    check_chr_ids_dic=chr_ids_dic,
                                                    chr_style=chr_style,
                                                    empty_check=False)
    assert gid2gio_dic, "no gene infos read in from --gtf. Please provide a valid/compatible GTF file (e.g. from Ensembl or ENCODE)"
    c_gene_infos = len(gid2gio_dic)
    print("# gene features read in from --gtf:", c_gene_infos)

    # Get most prominent transcripts or if --tr-list is set, read in transcript IDs.
    tr_ids_dic = {}
    if args.tr_list:
        tr_ids_dic = benchlib.read_ids_into_dic(args.tr_list,
                                                check_dic=False)
        assert tr_ids_dic, "no IDs read in from provided --tr-list file. Please provide a valid IDs file (one ID per row)"
        for tr_id in tr_ids_dic:
            assert tr_id in tr2gid_dic, "transcript ID \"%s\" from provided --tr-list file does not appear in --gtf file. Please provide compatible files" %(tr_id)
            tr_ids_dic[tr_id] = tr2gid_dic[tr_id]
        print("# of transcript IDs (read in from --tr-list): ", len(tr_ids_dic))
    else:
        # Get most prominent transcripts from gene infos.
        tr_ids_dic = benchlib.select_mpts_from_gene_infos(gid2gio_dic,
                                basic_tag=False,  # do not be strict (only_tsl=False too).
                                ensembl_canonical_tag=False,
                                prior_basic_tag=True,  # Prioritize basic tag transcript.
                                only_tsl=False)
        assert tr_ids_dic, "most prominent transcript selection from gene infos failed. Please contact developers"
        print("# of transcript IDs (most prominent transcripts): ", len(tr_ids_dic))

    # Check exon order (return True if minus strand exon 1 is most downstream, not most upstream, which is the correct way).
    print("Check minus-strand exon order in --gtf ... ")
    correct_min_ex_order = benchlib.gtf_check_exon_order(args.in_gtf)
    if correct_min_ex_order:
        print("Correct order encountered ... ")
    else:
        print("Reverse order encountered ... ")
    # Get transcript infos.
    print("Read in transcript infos from --gtf ... ")
    tid2tio_dic = benchlib.gtf_read_in_transcript_infos(args.in_gtf, 
                                                        tr_ids_dic=tr_ids_dic,
                                                        correct_min_ex_order=correct_min_ex_order,
                                                        chr_style=chr_style,
                                                        empty_check=False)

    assert tid2tio_dic, "no transcript infos read in from --gtf. Please provide a valid/compatible GTF file (e.g. from Ensembl or ENCODE)"

    # (in)sanity checks.
    for tr_id in tr_ids_dic:
        assert tr_id in tid2tio_dic, "transcript ID %s not in tid2tio_dic"
    for tr_id in tid2tio_dic:
        assert tr_id in tr_ids_dic, "transcript ID %s not in tr_ids_dic"

    c_tr_infos = len(tid2tio_dic)
    print("# transcript features read in from --gtf:", c_tr_infos)

    # Get mRNA region lengths (from transcript IDs with CDS feature).
    print("Get mRNA region lengths ... ")
    tid2regl_dic = benchlib.get_mrna_region_lengths(tid2tio_dic)
    assert tid2regl_dic, "tid2regl_dic empty. Please contact developers"
    c_mrna_tids = len(tid2regl_dic)
    print("# mRNA transcripts (containing CDS):", c_mrna_tids)

    assert c_mrna_tids, "no mRNA transcripts (containing CDS) found in --gtf. Please provide a valid/compatible GTF file (e.g. from Ensembl or ENCODE)"

    # Get transcript sequences.
    print("Extract mRNA sequences ... ")
    tr_seqs_dic = benchlib.get_transcript_sequences_from_gtf(tid2tio_dic, args.in_genome,
                                                             tr_ids_dic=tid2regl_dic,
                                                             tmp_out_folder=args.out_folder)

    # Check once more.
    for tr_id in tid2regl_dic:
        total_len = tid2regl_dic[tr_id][0] + tid2regl_dic[tr_id][1] + tid2regl_dic[tr_id][2]
        assert total_len == len(tr_seqs_dic[tr_id]), "mRNA region lengths do not match extracted sequence lengths. Please contact developers"

    # Output mRNA regions (5'UTR CDS 3'UTR) to BED.
    print("Output mRNA regions to BED ... ")
    benchlib.output_mrna_regions_to_bed(tid2regl_dic, mrna_regions_bed)

    # Get mean / median UTR CDS lengths.
    utr5_len_list = []
    cds_len_list = []
    utr3_len_list = []
    for tr_id in tid2regl_dic:
        utr5_len_list.append(tid2regl_dic[tr_id][0])
        cds_len_list.append(tid2regl_dic[tr_id][1])
        utr3_len_list.append(tid2regl_dic[tr_id][2])
    
    utr5_len_norm = 100
    cds_len_norm = 100
    utr3_len_norm = 100
    norm_mode = "uniform"

    if args.mrna_norm_mode == 1:
        # Median.
        utr5_len_norm = statistics.median(utr5_len_list)
        cds_len_norm = statistics.median(cds_len_list)
        utr3_len_norm = statistics.median(utr3_len_list)
        norm_mode = "median"
        print("Median lengths of mRNA regions:")

    elif args.mrna_norm_mode == 2:
        # Mean.
        utr5_len_norm = statistics.mean(utr5_len_list)
        cds_len_norm = statistics.mean(cds_len_list)
        utr3_len_norm = statistics.mean(utr3_len_list)
        norm_mode = "mean"
        print("Mean lengths of mRNA regions:")

    else:
        assert False, "invalid --mrna-norm-mode %i set" %(args.mrna_norm_mode)

    print("5'UTR = ", utr5_len_norm)
    print("CDS   = ", cds_len_norm)
    print("3'UTR = ", utr3_len_norm)

    norm_mrna_reg_dic = {"5'UTR": utr5_len_norm, "CDS": cds_len_norm, "3'UTR": utr3_len_norm, "mode": norm_mode, "c_mrna_seqs": c_mrna_tids}

    mrna_reg_occ_dic = {}

    for rbp_id, rbp in search_rbps_dic.items():

        mrna_reg_occ_dic[rbp_id] = {}
        # List of length utr5_len_median with 0s.
        mrna_reg_occ_dic[rbp_id]["5'UTR"] = [0] * int(utr5_len_norm)
        mrna_reg_occ_dic[rbp_id]["CDS"] = [0] * int(cds_len_norm)
        mrna_reg_occ_dic[rbp_id]["3'UTR"] = [0] * int(utr3_len_norm)

        for motif_id in rbp.seq_motif_ids:
            mrna_reg_occ_dic[motif_id] = {}
            mrna_reg_occ_dic[motif_id]["5'UTR"] = [0] * int(utr5_len_norm)
            mrna_reg_occ_dic[motif_id]["CDS"] = [0] * int(cds_len_norm)
            mrna_reg_occ_dic[motif_id]["3'UTR"] = [0] * int(utr3_len_norm)

        for motif_id in rbp.str_motif_ids:
            mrna_reg_occ_dic[motif_id] = {}
            mrna_reg_occ_dic[motif_id]["5'UTR"] = [0] * int(utr5_len_norm)
            mrna_reg_occ_dic[motif_id]["CDS"] = [0] * int(cds_len_norm)
            mrna_reg_occ_dic[motif_id]["3'UTR"] = [0] * int(utr3_len_norm)


    # Output sequences to FASTA.
    print("Output mRNA sequences to FASTA ... ")
    benchlib.fasta_output_dic(tr_seqs_dic, mrna_seqs_fa,
                              split=True)

    # # mRNA sequences for search.
    c_regions = len(tr_seqs_dic)

    # Called region size.
    called_reg_size = 0
    len_list = []
    for seq_id in tr_seqs_dic:
        seq_len = len(tr_seqs_dic[seq_id])
        called_reg_size += seq_len
        len_list.append(seq_len)

    eff_reg_size = called_reg_size

    # Length statistics.
    reg_len_median = statistics.median(len_list)
    reg_len_mean = statistics.mean(len_list)
    reg_len_mean = round(reg_len_mean, 2)
    reg_len_min = min(len_list)
    reg_len_max = max(len_list)


    """
    ====================================
    RUN SEQUENCE MOTIF SEARCH WITH FIMO.
    ====================================
    
    """
    fimo_hits_list = []
    call_dic = {}

    if seq_rbps_dic:

        """
        Print motifs to file.

        """

        print("Output motifs to XML ... ")
        out_str, c_added_motifs = benchlib.blocks_to_xml_string(seq_motif_blocks_dic, loaded_motif_ids_dic)

        benchlib.output_string_to_file(out_str, seq_motifs_xml)


        """
        Run FIMO on sequences + motifs.

        """

        print("Run FIMO ... ")
        benchlib.run_fast_fimo(mrna_seqs_fa, seq_motifs_xml, fimo_res_tsv,
                    pval_thr=args.fimo_pval,
                    nt_freqs_file=fimo_freqs_file,
                    call_dic=call_dic,
                    params=fimo_params,
                    error_check=False)

        """
        Read in FIMO hits.

        """

        assert os.path.exists(fimo_res_tsv), "FIMO output file fimo.tsv %s does not exist! There must have been an error while running FIMO (invalid xml file provided?)" %(fimo_res_tsv)

        print("Read in FIMO results ... ")
        fimo_hits_list = benchlib.read_in_fimo_results(fimo_res_tsv,
                                                       seq_based=True)

        c_fimo_hits = len(fimo_hits_list)
        print("# of FIMO motif hits:", c_fimo_hits)

        """
        If --regex is set, search for regex hits in sequences (stored in out_seqs_dic).

        """
        if args.regex:

            step_size_one = False
            if args.regex_search_mode == 1:
                step_size_one = False
            elif args.regex_search_mode == 2:
                step_size_one = True
            else:
                assert False, "invalid --regex-search-mode %i set" %(args.regex_search_mode)

            print("Run search for --regex \"%s\" ... " %(regex))
            regex_hits_list = benchlib.get_regex_hits(regex, regex_id, tr_seqs_dic,
                                                      step_size_one=step_size_one,
                                                      seq_based=True,
                                                      use_motif_regex_id=args.motif_regex_id)

            c_regex_hits = len(regex_hits_list)
            print("# of regex hits:", c_regex_hits)

            # Add regex hits to fimo_hits_list.
            fimo_hits_list += regex_hits_list


    """
    =========================================
    RUN STRUCTURE MOTIF SEARCH WITH CMSEARCH.
    =========================================

    """
    cmsearch_hits_list = []

    if str_rbps_dic:
        
        print("Output covariance models to .cm ... ")
        benchlib.output_cm_blocks_to_file(str_motif_blocks_dic, loaded_motif_ids_dic, str_motifs_cm)

        # Run cmsearch.
        print("Run cmsearch ... ")
        benchlib.run_cmsearch(mrna_seqs_fa, str_motifs_cm, cmsearch_res_txt,
                        error_check=False,
                        call_dic=call_dic,
                        params="-g --tformat fasta --toponly --incT 1 -T 1 --default") # or add --anytrunc and remove --g
        # Read in hits.
        print("Read in cmsearch results ... ")
        cmsearch_hits_list, c_cms_hits = benchlib.read_in_cmsearch_results(cmsearch_res_txt,
                                                                           seq_based=True,
                                                                           check=True)

        print("# of cmsearch motif hits:", c_cms_hits)


    """
    Store for each RBP the regions with motif hits (and hit counts), using
    dictionary of dictionaries regions_with_motifs_dic.
    This tells us, how many input regions have motif hits, separated by RBP.
    Also store for each RBP the unique motif hit regions (and hit counts), using
    dictionary of dictionaries unique_motifs_dic.

    regions_with_motifs_dic:
        Dictionary of dictionaries, format:
        {rbp_id1 -> {'region1': motif_c_region1, 'region2': motif_c_region2}, rbp_id2 -> {'region1': motif_c_region1}}
    unique_motifs_dic:
        Dictionary of dictionaries, format:
        {rbp_id1 -> {'motif_region1': c_motif_region1, 'motif_region2': c_motif_region2}, rbp_id2 -> .. }

    """

    regions_with_motifs_dic = {}
    unique_motifs_dic = {}

    # Store regions with sequence motifs.
    for fh in fimo_hits_list:

        rbp_id = id2name_dic[fh.motif_id]

        if rbp_id in regions_with_motifs_dic:
            # fh.seq_name : FASTA header (== --in genomic sequence region).
            if fh.seq_name in regions_with_motifs_dic[rbp_id]:
                regions_with_motifs_dic[rbp_id][fh.seq_name] += 1
            else:
                regions_with_motifs_dic[rbp_id][fh.seq_name] = 1
        else:
            regions_with_motifs_dic[rbp_id] = {}
            regions_with_motifs_dic[rbp_id][fh.seq_name] = 1

        fh_str = repr(fh) # genomic motif region string.

        # Unique motif regions for each RBP.
        if rbp_id in unique_motifs_dic:
            if fh_str in unique_motifs_dic[rbp_id]:
                unique_motifs_dic[rbp_id][fh_str] += 1
            else:
                unique_motifs_dic[rbp_id][fh_str] = 1
        else:
            unique_motifs_dic[rbp_id] = {}
            unique_motifs_dic[rbp_id][fh_str] = 1

    # Store regions with structure motifs.
    for cmsh in cmsearch_hits_list:

        rbp_id = id2name_dic[cmsh.motif_id]

        if rbp_id in regions_with_motifs_dic:
            # cmsh.seq_name : FASTA header (== --in genomic sequence region).
            if cmsh.seq_name in regions_with_motifs_dic[rbp_id]:
                regions_with_motifs_dic[rbp_id][cmsh.seq_name] += 1
            else:
                regions_with_motifs_dic[rbp_id][cmsh.seq_name] = 1
        else:
            regions_with_motifs_dic[rbp_id] = {}
            regions_with_motifs_dic[rbp_id][cmsh.seq_name] = 1

        cmsh_str = repr(cmsh) # genomic motif region string.

        # Unique motif regions for each RBP.
        if rbp_id in unique_motifs_dic:
            if cmsh_str in unique_motifs_dic[rbp_id]:
                unique_motifs_dic[rbp_id][cmsh_str] += 1
            else:
                unique_motifs_dic[rbp_id][cmsh_str] = 1
        else:
            unique_motifs_dic[rbp_id] = {}
            unique_motifs_dic[rbp_id][cmsh_str] = 1

    """
    Store infos for each RBP in RBP class.

    search_rbps_dic[rbp_id] = rbp_class
    RBP class arguments:
            name: str,
            seq_motif_ids = None,
            str_motif_ids = None,
            c_hit_reg = 0, # # regions with motif hits.
            perc_hit_reg = 0.0, # % hit regions over all regions (i.e. how many input regions contain >= 1 RBP motif).
            c_motif_hits = 0, # # motif hits.
            c_uniq_motif_hits = 0, # # unique motif hits.
            c_uniq_motif_nts = 0, # # unique motif nucleotides.
            perc_uniq_motif_nts_eff_reg = 0.0, # % unique motif nts over effective region length.
            perc_uniq_motif_nts_cal_reg = 0.0, # % unique motif nts over called region length.
            uniq_motif_hits_eff_1000nt = 0.0, # unique motif hits per effective 1000 nt.
            uniq_motif_hits_cal_1000nt = 0.0, # unique motif hits per called 1000 nt.
            ks_pval = 1.0, # Kolmogorov-Smirnov (KS) statistic p-value (are higher scoring sites enriched with motifs).
            ks_stat = 0.0,
            organism: Optional[str] = None

    Number of sequences for FIMO / cmsearch: 
    c_regions

    """
    # Set number of no-hit regions.
    for rbp_id in search_rbps_dic:
        search_rbps_dic[rbp_id].c_no_hit_reg = c_regions

    for rbp_id in regions_with_motifs_dic:
        # Number of --in regions with RBP motif hits.
        c_hit_reg = len(regions_with_motifs_dic[rbp_id])

        # Number of motif hits on --in regions in total.
        c_motif_hits = 0
        for reg_id in regions_with_motifs_dic[rbp_id]:
            c_motif_hits += regions_with_motifs_dic[rbp_id][reg_id]
        search_rbps_dic[rbp_id].c_hit_reg = c_hit_reg
        search_rbps_dic[rbp_id].c_no_hit_reg = c_regions - c_hit_reg
        search_rbps_dic[rbp_id].c_motif_hits = c_motif_hits

        # % hit regions over all regions (i.e. how many input regions contain >= 1 RBP motif).
        search_rbps_dic[rbp_id].perc_hit_reg = (search_rbps_dic[rbp_id].c_hit_reg / c_regions) * 100

    """
    Get unique motif hits.

    unique_motifs_dic:
        Dictionary of dictionaries, format:
        {rbp_id1 -> {'motif_region1': c_motif_region1, 'motif_region2': c_motif_region2}, rbp_id2 -> .. }
    """

    for rbp_id in unique_motifs_dic:
        c_uniq_motif_hits = len(unique_motifs_dic[rbp_id])
        search_rbps_dic[rbp_id].c_uniq_motif_hits = c_uniq_motif_hits
        # Store individual motif unique hits.
        for motif_str_repr in unique_motifs_dic[rbp_id]:
            motif_id = benchlib.get_motif_id_from_str_repr(motif_str_repr)
            idx = motif_id2idx_dic[motif_id]
            if id2type_dic[motif_id] == "meme_xml":
                search_rbps_dic[rbp_id].seq_motif_hits[idx] += 1
            elif id2type_dic[motif_id] == "regex":
                search_rbps_dic[rbp_id].seq_motif_hits[idx] += 1
            elif id2type_dic[motif_id] == "cm":
                search_rbps_dic[rbp_id].str_motif_hits[idx] += 1
            else:
                assert False, "unknown motif type (\"%s\") set for motif_id %s" %(id2type_dic[motif_id], motif_id)

    """
    Number of motif nucleotides over called + effective region size.

    ALAMO

    """

    print("Calculate effective motif region sizes for each RBP ... ")
    for rbp_id in unique_motifs_dic:
        # Ouput unique motif hit regions (sequence or structure) to BED for RBP rbp_id.
        benchlib.output_motif_hits_to_bed(rbp_id, unique_motifs_dic, out_tmp_bed,
                                          one_based_start=True)
        # Calculate effective motif region size.
        eff_motif_reg_size = benchlib.get_uniq_gen_size(out_tmp_bed)

        # Number of unique motif nucleotides.
        search_rbps_dic[rbp_id].c_uniq_motif_nts = eff_motif_reg_size
        # % unique motif nts over effective region length.
        search_rbps_dic[rbp_id].perc_uniq_motif_nts_eff_reg = (eff_motif_reg_size / eff_reg_size) * 100
        # % unique motif nts over called region length.
        search_rbps_dic[rbp_id].perc_uniq_motif_nts_cal_reg = (eff_motif_reg_size / called_reg_size) * 100
        # Number of unique motif hits per effective 1000 nt.
        search_rbps_dic[rbp_id].uniq_motif_hits_eff_1000nt  = search_rbps_dic[rbp_id].c_uniq_motif_hits / (eff_reg_size / 1000)
        # Number of unique motif hits per called 1000 nt.
        search_rbps_dic[rbp_id].uniq_motif_hits_cal_1000nt  = search_rbps_dic[rbp_id].c_uniq_motif_hits / (called_reg_size / 1000)

    """
    # Print RBP object stats.
    for rbp_id in search_rbps_dic:
        print(search_rbps_dic[rbp_id].__dict__)

    """

    # print(search_rbps_dic["AGGF1"].__dict__)
    print("# --in regions for motif search:", c_regions)
    print("Called genomic region size:     ", called_reg_size)
    print("Effective genomic region size:  ", eff_reg_size)


    """
    Output RBP hit stats (ie one row per RBP).

    Output clowns:
    rbp_id
    c_regions
    called_reg_size
    effective_reg_size
    c_reg_with_hits
    perc_reg_with_hits
    c_motif_hits
    c_uniq_motif_hits
    c_uniq_motif_nts
    perc_uniq_motif_nts_cal_reg
    perc_uniq_motif_nts_eff_reg
    uniq_motif_hits_cal_1000nt
    uniq_motif_hits_eff_1000nt
    wc_pval
    seq_motif_ids
    seq_motif_hits
    str_motif_ids
    str_motif_hits

    """

    rbp_list = []

    OUTSTATS = open(rbp_stats_out, "w")
    rbp_stats_header = "data_id\tmethod_id\trun_id\tmotif_db\trbp_id\tc_regions\tmean_reg_len\tmedian_reg_len\tmin_reg_len\tmax_reg_len\t"
    rbp_stats_header += "called_reg_size\teffective_reg_size\tc_reg_with_hits\tperc_reg_with_hits\t"
    rbp_stats_header += "c_motif_hits\tc_uniq_motif_hits\tc_uniq_motif_nts\tperc_uniq_motif_nts_cal_reg\tperc_uniq_motif_nts_eff_reg\tuniq_motif_hits_cal_1000nt\t"
    rbp_stats_header += "uniq_motif_hits_eff_1000nt\twc_pval\tseq_motif_ids\tseq_motif_hits\tstr_motif_ids\tstr_motif_hits\tinternal_id\n"
    OUTSTATS.write(rbp_stats_header)

    for rbp_id in search_rbps_dic:

        # print(search_rbps_dic[rbp_id].__dict__)
        rbp_list.append(rbp_id)

        motif_db_out = loaded_rbps_dic[rbp_id]

        c_reg_with_hits = search_rbps_dic[rbp_id].c_hit_reg
        perc_reg_with_hits = search_rbps_dic[rbp_id].perc_hit_reg
        c_motif_hits = search_rbps_dic[rbp_id].c_motif_hits
        c_uniq_motif_hits = search_rbps_dic[rbp_id].c_uniq_motif_hits
        c_uniq_motif_nts = search_rbps_dic[rbp_id].c_uniq_motif_nts
        perc_uniq_motif_nts_cal_reg = search_rbps_dic[rbp_id].perc_uniq_motif_nts_cal_reg
        perc_uniq_motif_nts_eff_reg = search_rbps_dic[rbp_id].perc_uniq_motif_nts_eff_reg
        uniq_motif_hits_cal_1000nt = search_rbps_dic[rbp_id].uniq_motif_hits_cal_1000nt
        uniq_motif_hits_eff_1000nt = search_rbps_dic[rbp_id].uniq_motif_hits_eff_1000nt
        wc_pval = "-"
        internal_id = search_rbps_dic[rbp_id].internal_id

        seq_motif_hits = ",".join(str(hc) for hc in search_rbps_dic[rbp_id].seq_motif_hits)
        str_motif_hits = ",".join(str(hc) for hc in search_rbps_dic[rbp_id].str_motif_hits)
        seq_motif_ids = ",".join(search_rbps_dic[rbp_id].seq_motif_ids)
        str_motif_ids = ",".join(search_rbps_dic[rbp_id].str_motif_ids)
        if not seq_motif_hits:
            seq_motif_hits = "-"
        if not str_motif_hits:
            str_motif_hits = "-"
        if not seq_motif_ids:
            seq_motif_ids = "-"
        if not str_motif_ids:
            str_motif_ids = "-"

        row_str = args.data_id + "\t"
        row_str += args.method_id + "\t"
        row_str += run_id + "\t"
        row_str += motif_db_out + "\t"
        row_str += rbp_id + "\t"

        row_str += str(c_regions) + "\t"

        row_str += str(reg_len_mean) + "\t"
        row_str += str(reg_len_median) + "\t"
        row_str += str(reg_len_min) + "\t"
        row_str += str(reg_len_max) + "\t"

        row_str += str(called_reg_size) + "\t"
        row_str += str(eff_reg_size) + "\t"

        row_str += str(c_reg_with_hits) + "\t"
        row_str += str(perc_reg_with_hits) + "\t"

        row_str += str(c_motif_hits) + "\t"
        row_str += str(c_uniq_motif_hits) + "\t"
        row_str += str(c_uniq_motif_nts) + "\t"
        row_str += str(perc_uniq_motif_nts_cal_reg) + "\t"
        row_str += str(perc_uniq_motif_nts_eff_reg) + "\t"
        row_str += str(uniq_motif_hits_cal_1000nt) + "\t"
        row_str += str(uniq_motif_hits_eff_1000nt) + "\t"
        row_str += wc_pval + "\t"
        row_str += seq_motif_ids + "\t"
        row_str += seq_motif_hits + "\t"
        row_str += str_motif_ids + "\t"
        row_str += str_motif_hits + "\t"
        row_str += internal_id + "\n"

        OUTSTATS.write(row_str)

    OUTSTATS.close()


    """
    Output motif region stats (1 row for each motif hit).
    Report ALL motif hits,
    plus report how many times one genomic motif hit occurs (uniq_count). 

    """

    motif_hit2annot_dic = {}

    OUTSTATS = open(motif_stats_out,"w")

    motif_stats_header = "data_id\tmethod_id\trun_id\tmotif_db\tregion_id\trbp_id\tmotif_id\tchr_id\tgen_s\tgen_e\tstrand\tregion_s\tregion_e\tregion_len\t"
    motif_stats_header += "uniq_count\tfimo_score\tfimo_pval\tcms_score\tcms_eval\tinternal_id\n"
    OUTSTATS.write(motif_stats_header)

    # Unique motif regions BED.
    motif_reg_dic = {}

    for fh in fimo_hits_list:

        rbp_id = id2name_dic[fh.motif_id]
        region_id = fh.seq_name
        region_len = len(tr_seqs_dic[region_id])
        # genomic motif region string.
        fh_str = repr(fh)
        uniq_count = unique_motifs_dic[rbp_id][fh_str]

        motif_db_out = loaded_motif_ids_dic[fh.motif_id]

        internal_id = search_rbps_dic[rbp_id].internal_id

        # Center position of motif hit.
        motif_hit_s = fh.start - 1
        motif_hit_e = fh.end
        tr_id = fh.chr_id
        center_pos = benchlib.get_center_position(motif_hit_s, motif_hit_e)  # 1-based center position.

        utr5_len = tid2regl_dic[tr_id][0]
        cds_len = tid2regl_dic[tr_id][1]
        utr3_len = tid2regl_dic[tr_id][2]

        utr5_e = utr5_len
        cds_s = utr5_e
        cds_e = cds_s + cds_len
        utr3_s = cds_e
        utr3_e = utr3_s + utr3_len

        annot = ["intergenic", False]

        if center_pos <= utr5_e:  # In 5'UTR.

            occ_pos = round((center_pos / utr5_len) * utr5_len_norm)
            if occ_pos > 0:
                occ_pos -= 1
            mrna_reg_occ_dic[rbp_id]["5'UTR"][occ_pos] += 1
            mrna_reg_occ_dic[fh.motif_id]["5'UTR"][occ_pos] += 1

            annot = ["5'UTR", tr_id]

        elif center_pos > utr5_e and center_pos <= cds_e:  # In CDS.

            occ_pos = round(((center_pos - utr5_e) / cds_len) * cds_len_norm)
            if occ_pos > 0:
                occ_pos -= 1
            mrna_reg_occ_dic[rbp_id]["CDS"][occ_pos] += 1
            mrna_reg_occ_dic[fh.motif_id]["CDS"][occ_pos] += 1

            annot = ["CDS", tr_id]
        
        elif center_pos > cds_e and center_pos <= utr3_e:  # In 3'UTR.

            occ_pos = round(((center_pos - cds_e) / utr3_len) * utr3_len_norm)
            if occ_pos > 0:
                occ_pos -= 1
            mrna_reg_occ_dic[rbp_id]["3'UTR"][occ_pos] += 1
            mrna_reg_occ_dic[fh.motif_id]["3'UTR"][occ_pos] += 1

            annot = ["3'UTR", tr_id]

        else:
            assert False, "center position %i not in 5'UTR, CDS or 3'UTR of transcript ID %s (transcript length: %i)" %(center_pos, tr_id, len(tr_seqs_dic[tr_id]))

        # Store motif hit as BED.
        hit_id = "%s:%s-%s(%s),%s" %(fh.chr_id, str(fh.start), str(fh.end), fh.strand, fh.motif_id)

        motif_hit2annot_dic[hit_id] = annot

        if hit_id not in motif_reg_dic:
            bed_row = "%s\t%i\t%i\t%s,%s;%i;%s,%s\t0\t%s\t%s\t%s\t-1.0\t-1.0" %(fh.chr_id, fh.start-1, fh.end, rbp_id, fh.motif_id, uniq_count, args.method_id, args.data_id, fh.strand, str(fh.score), str(fh.pval))
            motif_reg_dic[hit_id] = bed_row

        row_str = args.data_id + "\t"
        row_str += args.method_id + "\t"
        row_str += run_id + "\t"
        row_str += motif_db_out + "\t"
        row_str += region_id + "\t"
        row_str += rbp_id + "\t"
        row_str += fh.motif_id + "\t"
        row_str += fh.chr_id + "\t"
        row_str += str(fh.start) + "\t"  # 1-based.
        row_str += str(fh.end) + "\t"
        row_str += fh.strand + "\t"
        row_str += str(fh.seq_s) + "\t"  # 1-based.
        row_str += str(fh.seq_e) + "\t"
        row_str += str(region_len) + "\t"
        row_str += str(uniq_count) + "\t"
        row_str += str(fh.score) + "\t"
        row_str += str(fh.pval) + "\t"
        row_str += "-\t"
        row_str += "-\t"
        row_str += internal_id + "\n"

        OUTSTATS.write(row_str)

    for cmsh in cmsearch_hits_list:

        rbp_id = id2name_dic[cmsh.motif_id]
        region_id = cmsh.seq_name
        region_len = len(tr_seqs_dic[region_id])
        # genomic motif region string.
        cmsh_str = repr(cmsh) 
        uniq_count = unique_motifs_dic[rbp_id][cmsh_str]

        motif_db_out = loaded_motif_ids_dic[cmsh.motif_id]

        internal_id = search_rbps_dic[rbp_id].internal_id

        # Center position of motif hit.
        motif_hit_s = cmsh.start - 1
        motif_hit_e = cmsh.end
        tr_id = fh.chr_id
        center_pos = benchlib.get_center_position(motif_hit_s, motif_hit_e)  # 1-based center position.

        utr5_len = tid2regl_dic[tr_id][0]
        cds_len = tid2regl_dic[tr_id][1]
        utr3_len = tid2regl_dic[tr_id][2]

        utr5_e = utr5_len
        cds_s = utr5_e
        cds_e = cds_s + cds_len
        utr3_s = cds_e
        utr3_e = utr3_s + utr3_len

        annot = ["intergenic", False]

        if center_pos <= utr5_e:  # In 5'UTR.

            occ_pos = round((center_pos / utr5_len) * utr5_len_norm)
            mrna_reg_occ_dic[rbp_id]["5'UTR"][occ_pos] += 1
            mrna_reg_occ_dic[cmsh.motif_id]["5'UTR"][occ_pos] += 1

            annot = ["5'UTR", tr_id]

        elif center_pos > utr5_e and center_pos <= cds_e:  # In CDS.

            occ_pos = round(((center_pos - utr5_e) / cds_len) * cds_len_norm)
            mrna_reg_occ_dic[rbp_id]["CDS"][occ_pos] += 1
            mrna_reg_occ_dic[cmsh.motif_id]["CDS"][occ_pos] += 1
        
            annot = ["CDS", tr_id]

        elif center_pos > cds_e and center_pos <= utr3_e:  # In 3'UTR.

            occ_pos = round(((center_pos - cds_e) / utr3_len) * utr3_len_norm)
            mrna_reg_occ_dic[rbp_id]["3'UTR"][occ_pos] += 1
            mrna_reg_occ_dic[cmsh.motif_id]["3'UTR"][occ_pos] += 1

            annot = ["3'UTR", tr_id]

        else:
            assert False, "center position %i not in 5'UTR, CDS or 3'UTR of transcript ID %s (transcript length: %i)" %(center_pos, tr_id, len(tr_seqs_dic[tr_id]))

        # Store motif hit as BED.
        hit_id = "%s:%s-%s(%s),%s" %(cmsh.chr_id, str(cmsh.start), str(cmsh.end), cmsh.strand, cmsh.motif_id)

        motif_hit2annot_dic[hit_id] = annot

        if hit_id not in motif_reg_dic:
            bed_row = "%s\t%i\t%i\t%s,%s;%i;%s,%s\t0\t%s\t%s\t%s\t-1.0\t-1.0" %(cmsh.chr_id, cmsh.start-1, cmsh.end, rbp_id, cmsh.motif_id, uniq_count, args.method_id, args.data_id, cmsh.strand, str(cmsh.score), str(cmsh.e_value))
            motif_reg_dic[hit_id] = bed_row

        row_str = args.data_id + "\t"
        row_str += args.method_id + "\t"
        row_str += run_id + "\t"
        row_str += motif_db_out + "\t"
        row_str += region_id + "\t"
        row_str += rbp_id + "\t"
        row_str += cmsh.motif_id + "\t"
        row_str += cmsh.chr_id + "\t"
        row_str += str(cmsh.start) + "\t"
        row_str += str(cmsh.end) + "\t"
        row_str += cmsh.strand + "\t"
        row_str += str(cmsh.seq_s) + "\t"
        row_str += str(cmsh.seq_e) + "\t"
        row_str += str(region_len) + "\t"
        row_str += str(uniq_count) + "\t"
        row_str += "-\t"
        row_str += "-\t"
        row_str += str(cmsh.score) + "\t"
        row_str += str(cmsh.e_value) + "\t"
        row_str += internal_id + "\n"
        #print("region_id:", region_id)
        #print("evalue:", cmsh.e_value)
        #print(row_str)

        OUTSTATS.write(row_str)

    OUTSTATS.close()

    """
    Output motif hits as BED.

    The motif hits written to motif_hits_bed_out are unique motif hits already. 
    If same hit occurs > 1, this is recorded in BED column 4 with format:
    rbp_id,motif_id;uniq_count;method_id,data_id
    These also include regex hits, as they are part of fimo hits.
    
    """

    OUTBED = open(motif_hits_bed_out,"w")
    for hit_id in motif_reg_dic:
        OUTBED.write("%s\n" %(motif_reg_dic[hit_id]))
    OUTBED.close()

    """
    Motif annotations (mRNA regions only).

    """

    """
    AALAMO

            # Store motif hit as BED.
        hit_id = "%s:%s-%s(%s),%s" %(cmsh.chr_id, str(cmsh.start), str(cmsh.end), cmsh.strand, cmsh.motif_id)
        if hit_id not in motif_reg_dic:
            bed_row = "%s\t%i\t%i\t%s,%s;%i;%s,%s\t0\t%s\t%s\t%s\t-1.0\t-1.0" %(cmsh.chr_id, cmsh.start-1, cmsh.end, rbp_id, cmsh.motif_id, uniq_count, args.method_id, args.data_id, cmsh.strand, str(cmsh.score), str(cmsh.e_value))
            motif_reg_dic[hit_id] = bed_row
    """






    # # Extract exon + intron regions of selected transcripts from transcript infos.
    # print("Output intron annotations to BED ... ")
    # intron_exon_out_bed = args.out_folder + "/intron_exon_regions.tmp.bed"
    # benchlib.output_transcript_info_intron_exon_to_bed(tid2tio_dic, intron_exon_out_bed,
    #                                     output_mode=3,  # only introns.
    #                                     report_counts=True,
    #                                     add_tr_id=True,
    #                                     empty_check=False)

    # # # Custom transcript biotypes for upset plot.
    # # custom_annot_dic = None
    # # if args.tr_types_list:
    # #     for tr_type in args.tr_types_list:
    # #         assert tr_type in tr_types_dic, "given transcript biotype ID \"%s\" not found in GTF file"
    # #         custom_annot_dic[tr_type] = tr_type

    # # Append detailed exon annotations (CDS, UTR, transcript biotypes) to intron annotations.
    # print("Output exon annotations to BED ... ")
    # benchlib.output_exon_annotations(tid2tio_dic, intron_exon_out_bed,
    #                                  # custom_annot_dic=custom_annot_dic,
    #                                  append=True)

    # # Overlap motif hit BED with genomic annotation regions.
    # print("Overlap mRNA annotations with motif hit regions ... ")


    # params = "-s -wo -f %s" %(str(args.gtf_feat_min_overlap))
    # overlap_motif_hit_annotations_bed = args.out_folder + "/overlap_motif_hit_annotations.tmp.bed"
    # benchlib.bed_intersect_files(motif_hits_bed_out, mrna_regions_bed, 
    #                              overlap_motif_hit_annotations_bed,
    #                              params=params)


    # motif_hit2annot_dic = benchlib.get_region_annotations(
    #                                     overlap_motif_hit_annotations_bed,
    #                                     motif_hits=True,
    #                                     reg_ids_dic=motif_reg_dic)

    # AALAMO

    rbp2motif2annot2c_dic = {}  # rbp_id -> motif_id -> annot -> count

    for motif_hit in motif_hit2annot_dic:
        # motif_hit format: "chr1:10-15(+),motif_id". Get motif_id.
        motif_id = motif_hit.split(",")[1]
        annot = motif_hit2annot_dic[motif_hit][0]
        # tr_id = motif_hit2annot_dic[motif_hit][1]
        rbp_id = id2name_dic[motif_id]
        if rbp_id not in rbp2motif2annot2c_dic:
            rbp2motif2annot2c_dic[rbp_id] = {}
        if motif_id not in rbp2motif2annot2c_dic[rbp_id]:
            rbp2motif2annot2c_dic[rbp_id][motif_id] = {}
        if annot not in rbp2motif2annot2c_dic[rbp_id][motif_id]:
            rbp2motif2annot2c_dic[rbp_id][motif_id][annot] = 1
        else:
            rbp2motif2annot2c_dic[rbp_id][motif_id][annot] += 1

    """
    Get annotation to color dictionary, which is needed for region annotation plots in HTML reports.

    """

    annot2color_dic = {}

    if rbp2motif2annot2c_dic:

        annot_dic = {}

        if rbp2motif2annot2c_dic:
            for rbp_id in rbp2motif2annot2c_dic:
                for motif_id in rbp2motif2annot2c_dic[rbp_id]:
                    for annot in rbp2motif2annot2c_dic[rbp_id][motif_id]:
                        if annot not in annot_dic:
                            annot_dic[annot] = 1
                        else:
                            annot_dic[annot] += 1

        # hex_colors = get_hex_colors_list(min_len=len(annot_with_hits_dic))
        hex_colors = benchlib.get_hex_colors_list(min_len=len(annot_dic))

        idx = 0
        for annot in sorted(annot_dic, reverse=False):
            # hc = hex_colors[idx]
            # print("Assigning hex color %s to annotation %s ... " %(hc, annot))
            annot2color_dic[annot] = hex_colors[idx]
            idx += 1


    """
    Motif plots and motif hit statistics HTML.

    AALAMO
    """
    


    html_motif_plots_out = args.out_folder + "/" + "motif_plots.rbpbench_searchmrna.html"
    if args.plot_abs_paths:
        html_motif_plots_out = os.path.abspath(args.out_folder) + "/" + "motif_plots.rbpbench_searchmrna.html"
    # If HTML file already exists, remove it.
    if os.path.exists(html_motif_plots_out):
        os.remove(html_motif_plots_out)

    print("Generate motif plots HTML ... ")
    
    plots_subfolder = "html_motif_plots"
    benchlib_path = os.path.dirname(benchlib.__file__)

    benchlib.search_generate_html_motif_plots(search_rbps_dic, seq_motif_blocks_dic, 
                                        str_motif_blocks_dic, args.out_folder, 
                                        benchlib_path, loaded_motif_ids_dic,
                                        motif_db_str=motif_db_str,
                                        rbp2motif2annot2c_dic=rbp2motif2annot2c_dic,
                                        annot2color_dic=annot2color_dic,
                                        mrna_reg_occ_dic=mrna_reg_occ_dic,
                                        norm_mrna_reg_dic=norm_mrna_reg_dic,
                                        regex_id=regex_id,
                                        sort_js_mode=args.sort_js_mode,
                                        html_report_out=html_motif_plots_out,
                                        plot_abs_paths=args.plot_abs_paths,
                                        rbpbench_mode="searchmrna",
                                        plots_subfolder=plots_subfolder)


    """
    Output parameter settings.

    """
    # Output mode settings.
    print("Output parameter settings ... ")
    SETOUT = open(settings_file, "w")
    for arg in vars(args):
        SETOUT.write("%s\t%s\n" %(arg, str(getattr(args, arg))))
    for call in call_dic:
        SETOUT.write("%s\t%s\n" %(call, call_dic[call]))
    SETOUT.close()

    """
    Take out the trash.

    """
    print("Delete .tmp files ... ")
    if os.path.exists(out_tmp_bed):
        os.remove(out_tmp_bed)
    if os.path.exists(cmstat_tmp_out):
        os.remove(cmstat_tmp_out)


    """
    Inform about outputs.

    """
    print("")
    print("OUTPUT FILES")
    print("============")
    print("")
    print("Run parameter settings:\n%s" %(settings_file))
    print("mRNA regions .bed:\n%s" %(mrna_regions_bed))
    print("Motif hits .bed:\n%s" %(motif_hits_bed_out))
    # print("RBP region occupancies .tsv:\n%s" %(rbp_reg_occ_table_out))
    print("RBP hit stats .tsv:\n%s" %(rbp_stats_out))
    print("Motif hit stats .tsv:\n%s" %(motif_stats_out))
    # if reg_annot_table_file is not None:
    #     print("Region annotations .tsv:\n%s" %(reg_annot_table_file))
    print("Motif plots and hit statistics .html:\n%s" %(html_motif_plots_out))
    # if args.report:
    #     print("Search report .html:\n%s" %(html_report_out))
    print("")
















################################################################################

def main_optex(args):
    """
    Investigate optimal extension.

    """

    print("Running for you in OPTEX mode ... ")

    assert os.path.exists(args.in_sites), "--in file \"%s\" not found" % (args.in_sites)
    # Check --in BED format.
    benchlib.bed_check_format(args.in_sites)

    # Reformat user_rbp_id. 
    rbp_id = benchlib.remove_special_chars_from_str(args.rbp_id)
    assert rbp_id, "empty string after removing special chars from given --rbp-id %s. Please provide alphanumeric string for RBP ID (- or _ are okay as well)" %(args.rbp_id)

    # Is MEME >= v5 installed?
    if not args.meme_disable_check:
        assert benchlib.is_tool("meme"), "meme not in PATH"
        check, meme_version = benchlib.check_tool_version("meme -version", "5.0")
        assert check, "RBPBench requires meme version >= 5.0 (installed version: %s)" %(meme_version)

    # Check if MEME version is >= 5.5.4 (need to add fimo --no-pgc option to produce same results!).
    fimo_params = "--norc --verbosity 1 --skip-matched-sequence --text"
    if not args.meme_disable_check:
        check, meme_version = benchlib.check_tool_version("meme -version", "5.5.4")
        if check:
            fimo_params = "--norc --verbosity 1 --skip-matched-sequence --text --no-pgc"
    if args.meme_no_pgc:
        fimo_params = "--norc --verbosity 1 --skip-matched-sequence --text --no-pgc"

    """
    Library path.
    """
    benchlib_path = os.path.dirname(benchlib.__file__)
    db_path = benchlib_path + "/content"


    """
    FIMO nt frequencies.
    """
    fimo_freqs_file = db_path + "/fimo_nt_freqs.txt" # CONDA2SET
    if args.fimo_nt_freqs:
        fimo_freqs_file = args.fimo_nt_freqs
    assert os.path.exists(fimo_freqs_file), "set FIMO nucleotide frequencies file \"%s\" not found" % (fimo_freqs_file)

    """
    Motif database.
    """
    seq_motifs_db_file, str_motifs_db_file, rbp2ids_file, motif_db_str = specify_motif_db(args.motif_db, 
                                                                                          db_path=db_path)
    args.motif_db_str = motif_db_str

    """
    Temp outputs.

    """
    tmp_id = base64.urlsafe_b64encode(os.urandom(6)).decode()
    tmp_out_folder = "optex_tmp_out_" + tmp_id

    if not os.path.exists(tmp_out_folder):
        os.makedirs(tmp_out_folder)

    filtered_sites_bed = tmp_out_folder + "/in_sites.filtered.bed"
    filtered_sites_fa = tmp_out_folder + "/in_sites.filtered.fa"
    seq_motifs_xml = tmp_out_folder + "/seq_motifs.xml"
    str_motifs_cm = tmp_out_folder + "/str_motifs.cm"
    fimo_res_tsv = tmp_out_folder + "/fimo_results.tsv"
    cmsearch_res_txt = tmp_out_folder + "/cmsearch_results.txt"

    out_tmp_bed = tmp_out_folder + "/rbp_motif_hit_regions.tmp.bed"
    cmstat_tmp_out = tmp_out_folder + "/cmstat_out.tmp.txt"

    # Delete if existing folder.
    if os.path.exists(fimo_res_tsv):
        os.remove(fimo_res_tsv)
    if os.path.exists(cmsearch_res_txt):
        os.remove(cmsearch_res_txt)

    """
    Get ID mappings

    name2ids_dic:
    RBP name -> motif IDs mapping
    id2type_dic:
    motif ID -> motif type (cm, meme_xml)
    id2org_dic (ignore for now):
    motif ID -> organism ID (so far only "human")

    """
    name2ids_dic, id2type_dic = benchlib.get_rbp_id_mappings(rbp2ids_file)
    # Motif ID -> RBP name (== RBP ID) mapping.
    id2name_dic = {}
    for rbpid in name2ids_dic:
        for motif_id in name2ids_dic[rbpid]:
            id2name_dic[motif_id] = rbpid


    """
    Define search motifs.

    """

    seq_motif_blocks_dic = {}
    str_motif_blocks_dic = {}
    loaded_motif_ids_dic = {}

    if rbp_id in name2ids_dic:

        print("RBP ID %s in database ... " %(rbp_id))

        assert not args.user_meme_xml, "provided RBP ID in motif database, but --user-meme-xml provided. Please provide RBP ID not in motif database to search with --user-meme-xml motif(s)"
        assert not args.user_cm, "provided RBP ID in motif database, but --user-cm provided. Please provide RBP ID not in motif database to search with --user-cm motif(s)"

        """
        Get MEME XML database motif blocks dictionary.

        """
        seq_motif_blocks_dic = benchlib.read_in_xml_motifs(seq_motifs_db_file)
        for motif_id in seq_motif_blocks_dic:
            assert motif_id in id2name_dic, "MEME XML motif ID %s not found in prior mapping. Please contact developers!" %(motif_id)

        """
        Get covariance model database motif blocks dictionary.

        """
        str_motif_blocks_dic = benchlib.read_in_cm_blocks(str_motifs_db_file)
        for motif_id in str_motif_blocks_dic:
            assert motif_id in id2name_dic, "Covariance model accession ID %s not found in prior mapping. Please contact developers!" %(motif_id)

        for motif_id in name2ids_dic[rbp_id]:
            loaded_motif_ids_dic[motif_id] = 1

    else:

        print("RBP ID %s NOT in database ... " %(rbp_id))

        assert args.user_meme_xml or args.user_cm, "--rbp-id not in database. Please provide user motif(s) (via --user-meme-xml OR --user-cm), set different motif database or supply RBP ID present in set database"

        if args.user_meme_xml:
            assert not args.user_cm, "either supply --user-meme-xml or --user-cm"
            assert os.path.exists(args.user_meme_xml), "--user-meme-xml file \"%s\" not found" % (args.user_meme_xml)
            seq_motif_blocks_dic = benchlib.read_in_xml_motifs(args.user_meme_xml, empty_check=False)
            assert seq_motif_blocks_dic, "no motifs read in from provided --user-meme-xml. Make sure to supply sequence motifs in MEME XML format!"
            for acc_id in seq_motif_blocks_dic:
                name2ids_dic[rbp_id] = [acc_id]
                id2type_dic[acc_id] = "meme_xml"
                id2name_dic[acc_id] = rbp_id
                loaded_motif_ids_dic[acc_id] = 1

        if args.user_cm:
            assert not args.user_meme_xml, "either supply --user-meme-xml or --user-cm"
            assert os.path.exists(args.user_cm), "--user-cm file \"%s\" not found" % (args.user_cm)
            # Check for valid format.
            acc_ids_dic = benchlib.check_cm_file(args.user_cm, cmstat_tmp_out, empty_check=True)
            # Read in covariance model blocks.
            str_motif_blocks_dic = benchlib.read_in_cm_blocks(args.user_cm)
            for acc_id in acc_ids_dic:
                assert acc_id in str_motif_blocks_dic, "accession ID %s not in blocks dictionary. Please contact developers!" %(acc_id)
            for acc_id in str_motif_blocks_dic:
                name2ids_dic[rbp_id] = [acc_id]
                id2type_dic[acc_id] = "cm"
                id2name_dic[acc_id] = rbp_id
                loaded_motif_ids_dic[acc_id] = 1


    """
    Make RBP object.

    """
    motif_id2idx_dic = {}
    seq_rbps_dic = {}
    str_rbps_dic = {}
    search_rbps_dic = {}

    rbp = benchlib.RBP(rbp_id, "optex")

    for motif_id in loaded_motif_ids_dic:

        if id2type_dic[motif_id] == "meme_xml":
            rbp.seq_motif_ids.append(motif_id)
            motif_id2idx_dic[motif_id] = len(rbp.seq_motif_ids) - 1
            rbp.seq_motif_hits.append(0)
            seq_rbps_dic[rbp_id] = 1
        else:
            rbp.str_motif_ids.append(motif_id)
            motif_id2idx_dic[motif_id] = len(rbp.str_motif_ids) - 1
            rbp.str_motif_hits.append(0)
            str_rbps_dic[rbp_id] = 1

        search_rbps_dic[rbp_id] = rbp


    print("RBP ID:        ", rbp_id)
    print("# of motif IDs:", len(loaded_motif_ids_dic))
    print("Motif IDs:     ", loaded_motif_ids_dic)

    """
    Get chromosome IDs from --genome.
    """
    print("Get --genome FASTA headers ... ")
    chr_ids_dic = benchlib.get_fasta_headers(args.in_genome)


    """
    Run motif search for each up- downstream extension combination.

    """
    from itertools import product
    ext_list = [0, 5, 10, 15, 20, 25, 30, 35, 40, 45, 50, 55, 60]

    # If user extension list given.
    if args.ext_list:
        ext_dic = {}
        for ext in args.ext_list:
            ext_dic[ext] = 1
        ext_list = []
        for ext in ext_dic:
            ext_list.append(ext)

    combined_list = list(product(ext_list, ext_list))
    ext2pval_dic = {}
    ext2stats_dic = {}
    sum_ext = 0
    longest_ext = "-"
    
    for ext in combined_list:

        print("")
        print("Extension (upstream, downstream):", ext)
        ext_up = ext[0]
        ext_down = ext[1]
        ext_str = "%i-%i" %(ext_up, ext_down)

        # Filter / extend --in BED.
        reg2sc_dic = {}
        reg_stats_dic = benchlib.bed_filter_extend_bed(args.in_sites, filtered_sites_bed,
                                            ext_up=ext_up,
                                            ext_down=ext_down,
                                            remove_dupl=True,
                                            reg2sc_dic=reg2sc_dic,
                                            score_col=args.bed_score_col,
                                            chr_ids_dic=chr_ids_dic)
        
        assert reg_stats_dic["c_out"], "no --in BED sites remain after chromosome ID filtering"

        # Check if all scores same (e.g. 0).
        reg_scores_dic = {}
        for reg_id in reg2sc_dic:
            reg_scores_dic[reg2sc_dic[reg_id]] = 1
        assert len(reg_scores_dic) != 1, "all site scores identical. Please use meaningful scores (--in BED column set by --bed-score-col)"

        """
        Calculate effective size of genomic regions.
        
        """
        print("Calculate effective genomic region size ... ")
        eff_reg_size = benchlib.get_uniq_gen_size(filtered_sites_bed)

        # print("# --in regions pre-filtering:  ", reg_stats_dic["c_in"])
        # print("# --in regions post-filtering: ", reg_stats_dic["c_out"])
        # print("# regions with invalid chr_id: ", reg_stats_dic["c_chr_filter"])
        # print("# duplicated regions removed:  ", reg_stats_dic["c_dupl_filter"])
        # print("Called region length sum:      ", reg_stats_dic["reg_len_sum"])
        # print("Effective region length sum:   ", eff_reg_size)

        """
        Get genomic region sequences from --genome.

        Output FASTA header format:
        >chr8:9772198-9772297(+)

        No need to convert sequences to uppercase, as FIMO works on both 
        lower- and uppercase (as long as DNA / RNA is set correct).

        """
        # print("Extract sequences from --genome ... ")
        benchlib.bed_extract_sequences_from_fasta(filtered_sites_bed, 
                                                args.in_genome, filtered_sites_fa,
                                                print_warnings=True)

        """
        Get FASTA sequences and sequence lengths.
        """

        out_seqs_dic = benchlib.read_fasta_into_dic(filtered_sites_fa,
                                        dna=True,
                                        all_uc=True,
                                        id_check=True,
                                        empty_check=False,
                                        skip_n_seqs=False)

        assert out_seqs_dic, "no sequences extracted from FASTA file for --in BED sites. Make sure to use compatible FASTA/BED files!"

        # Effective number of regions used for motif search.
        c_regions = len(out_seqs_dic)

        # Called region size.
        called_reg_size = 0
        for seq_id in out_seqs_dic:
            called_reg_size += len(out_seqs_dic[seq_id])


        """
        ====================================
        RUN SEQUENCE MOTIF SEARCH WITH FIMO.
        ====================================
        
        """
        fimo_hits_list = []
        call_dic = {}

        if seq_rbps_dic:

            """
            Print motifs to file.

            """

            # print("Output motifs to XML ... ")
            out_str, c_added_motifs = benchlib.blocks_to_xml_string(seq_motif_blocks_dic, loaded_motif_ids_dic)

            benchlib.output_string_to_file(out_str, seq_motifs_xml)


            """
            Run FIMO on sequences + motifs.

            """

            # print("Run FIMO ... ")
            benchlib.run_fast_fimo(filtered_sites_fa, seq_motifs_xml, fimo_res_tsv,
                        pval_thr=args.fimo_pval,
                        nt_freqs_file=fimo_freqs_file,
                        call_dic=call_dic,
                        params=fimo_params,
                        error_check=False)

            """
            Read in FIMO hits.

            """

            assert os.path.exists(fimo_res_tsv), "FIMO output file fimo.tsv %s does not exist! There must have been an error while running FIMO (invalid xml file provided?)" %(fimo_res_tsv)

            # print("Read in FIMO results ... ")
            fimo_hits_list = benchlib.read_in_fimo_results(fimo_res_tsv)

            # c_fimo_hits = len(fimo_hits_list)
            # print("# of FIMO motif hits:", c_fimo_hits)

        """
        =========================================
        RUN STRUCTURE MOTIF SEARCH WITH CMSEARCH.
        =========================================

        """
        cmsearch_hits_list = []

        if str_rbps_dic:
            
            # print("Output covariance models to .cm ... ")
            benchlib.output_cm_blocks_to_file(str_motif_blocks_dic, loaded_motif_ids_dic, str_motifs_cm)

            # Run cmsearch.
            # print("Run cmsearch ... ")
            benchlib.run_cmsearch(filtered_sites_fa, str_motifs_cm, cmsearch_res_txt,
                            error_check=False,
                            call_dic=call_dic,
                            params="-g --tformat fasta --toponly --incT 1 -T 1 --default")
            # Read in hits.
            # print("Read in cmsearch results ... ")
            cmsearch_hits_list, c_cms_hits = benchlib.read_in_cmsearch_results(cmsearch_res_txt)

            # print("# of cmsearch motif hits:", c_cms_hits)

        """
        Store regions with motif hits (and hit counts).
        This tells us, how many input regions have motif hits (+ how many hits).

        Also store the unique motif hit regions (and hit counts).

        regions_with_motifs_dic:
            region -> motif_c_region

        unique_motifs_dic:
            motif_region -> c_motif_region

        """

        regions_with_motifs_dic = {}
        unique_motifs_dic = {}

        # Store regions with sequence motifs.
        for fh in fimo_hits_list:

            if fh.seq_name in regions_with_motifs_dic:
                regions_with_motifs_dic[fh.seq_name] += 1
            else:
               regions_with_motifs_dic[fh.seq_name] = 1 

            fh_str = repr(fh) # genomic motif region string.

            if fh_str in unique_motifs_dic:
                unique_motifs_dic[fh_str] += 1
            else:
                unique_motifs_dic[fh_str] = 1

        # Store regions with structure motifs.
        for cmsh in cmsearch_hits_list:

            if cmsh.seq_name in regions_with_motifs_dic:
                regions_with_motifs_dic[cmsh.seq_name] += 1
            else:
                regions_with_motifs_dic[cmsh.seq_name] = 1 

            cmsh_str = repr(cmsh) # genomic motif region string.

            if cmsh_str in unique_motifs_dic:
                unique_motifs_dic[cmsh_str] += 1
            else:
                unique_motifs_dic[cmsh_str] = 1

        """
        Store infos in RBP object.

        """
        # number of --in regions with RBP motif hits.
        c_hit_reg = len(regions_with_motifs_dic)
        # number of motif hits on --in regions in total.
        c_motif_hits = 0
        for reg_id in regions_with_motifs_dic:
            c_motif_hits += regions_with_motifs_dic[reg_id]
        
        rbp.c_hit_reg = c_hit_reg
        rbp.c_motif_hits = c_motif_hits
        # % hit regions over all regions (i.e. how many input regions contain >= 1 RBP motif).
        rbp.perc_hit_reg = (rbp.c_hit_reg / c_regions) * 100

        """
        Get unique motif hits.

        """
        rbp.c_uniq_motif_hits = len(unique_motifs_dic)
        # Store individual motif unique hits.
        for motif_str_repr in unique_motifs_dic:
            motif_id = benchlib.get_motif_id_from_str_repr(motif_str_repr)
            idx = motif_id2idx_dic[motif_id]
            if id2type_dic[motif_id] == "meme_xml":
                rbp.seq_motif_hits[idx] += 1
            else:
                rbp.str_motif_hits[idx] += 1

        """
        Number of motif nucleotides over called + effective region size.

        """

        # print("Calculate effective motif region sizes ... ")

        # Output unique motif hit regions (sequence or structure) to BED.
        eff_motif_reg_size = 0
        if unique_motifs_dic:
            benchlib.batch_output_motif_hits_to_bed(unique_motifs_dic, out_tmp_bed,
                                                    one_based_start=True)
            # Calculate effective motif region size.
            eff_motif_reg_size = benchlib.get_uniq_gen_size(out_tmp_bed)

        # Number of unique motif nucleotides.
        rbp.c_uniq_motif_nts = eff_motif_reg_size
        # % unique motif nts over effective region length.
        rbp.perc_uniq_motif_nts_eff_reg = (eff_motif_reg_size / eff_reg_size) * 100
        # % unique motif nts over called region length.
        rbp.perc_uniq_motif_nts_cal_reg = (eff_motif_reg_size / called_reg_size) * 100
        # Number of unique motif hits per effective 1000 nt.
        rbp.uniq_motif_hits_eff_1000nt  = rbp.c_uniq_motif_hits / (eff_reg_size / 1000)
        # Number of unique motif hits per called 1000 nt.
        rbp.uniq_motif_hits_cal_1000nt  = rbp.c_uniq_motif_hits / (called_reg_size / 1000)

        print("# --in regions for motif search:", c_regions)
        print("Called genomic region size:     ", called_reg_size)
        print("Effective genomic region size:  ", eff_reg_size)

        """
        Motif enrichment test:
        Are motifs enriched in higher scoring sites?

        """

        # print("Calculate Wilcoxon rank-sum test statistics ... ")

        # Check if all scores same (e.g. 0).
        reg_scores_dic = {}
        for reg_id in reg2sc_dic:
            reg_scores_dic[reg2sc_dic[reg_id]] = 1
        if len(reg_scores_dic) == 1:
            print("WARNING: all site scores identical. Reported p-values meaningless! (i.e., equal 1.0)")

        hit_reg_scores = []
        non_hit_reg_scores = []

        for reg_id in reg2sc_dic:
            reg_sc = reg2sc_dic[reg_id] # float value.
            if reg_id in regions_with_motifs_dic:
                hit_reg_scores.append(reg_sc)
            else:
                non_hit_reg_scores.append(reg_sc)

        wc_pval = 1.0
        # In case no regions without motif hits.
        if not non_hit_reg_scores:
            print("WARNING: all input regions contain motifs. Adding dummy scores (median) ... ")
            dummy_val = statistics.median(hit_reg_scores)
            hit_reg_scores.append(dummy_val)
            non_hit_reg_scores.append(dummy_val)

        print("# regions with motifs:         ", len(hit_reg_scores))
        print("# regions without motifs:      ", len(non_hit_reg_scores))

        hit_reg_median_sc = "-"
        non_hit_reg_median_sc = "-"
        if hit_reg_scores:
            hit_reg_median_sc = statistics.median(hit_reg_scores)
        if non_hit_reg_scores:
            non_hit_reg_median_sc = statistics.median(non_hit_reg_scores)


        print("Median score motif regions:    ", hit_reg_median_sc)
        print("Median score non-motif regions:", non_hit_reg_median_sc)

        if unique_motifs_dic:
            wc_stat, wc_pval = mannwhitneyu(hit_reg_scores, non_hit_reg_scores, alternative="greater")
            rbp.wc_pval = wc_pval
        print("Compact hit stats (RBP ID, # unique hits, Wilcoxon p-value):")
        print("%s\t%i\t%s" %(rbp_id, rbp.c_uniq_motif_hits, str(wc_pval)))

        ext2pval_dic[ext_str] = wc_pval
        ext2stats_dic[ext_str] = [len(hit_reg_scores), len(non_hit_reg_scores), rbp.c_uniq_motif_hits]
        if wc_pval <= args.ext_pval:
            new_sum = ext_up + ext_down
            if new_sum > sum_ext:
                sum_ext = new_sum
                longest_ext = ext_str

    """
    Take out the trash.

    """
    print("Delete tmp folder ... ")
    if os.path.exists(tmp_out_folder):
        import shutil
        shutil.rmtree(tmp_out_folder)

    """
    Report.

    """
    best_pval = 1.0
    best_ext = "-"
    for ext in ext2pval_dic:
        if ext2pval_dic[ext] < best_pval:
            best_pval = ext2pval_dic[ext]
            best_ext = ext

    print("")
    print("REPORT")
    print("======")
    print("")
    print("Longest extension p-value:   ", args.ext_pval)
    print("Longest extension:           ", longest_ext)
    print("Best p-value extension:      ", best_ext)
    print("Best p-value:                ", best_pval)
    print("# hit regions (best ext):    ", ext2stats_dic[best_ext][0])
    print("# non-hit regions (best ext):", ext2stats_dic[best_ext][1])
    print("# unique hits (best ext):    ", ext2stats_dic[best_ext][2])
    print("")


################################################################################

def main_info(args):
    """
    Print RBP IDs in database.

    """

    print("Running for you in INFO mode ... ")

    """
    Library path.
    """
    benchlib_path = os.path.dirname(benchlib.__file__)
    db_path = benchlib_path + "/content"

    """
    Motif database.
    """
    seq_motifs_db_file, str_motifs_db_file, rbp2ids_file, motif_db_str = specify_motif_db(args.motif_db, 
                                                                            db_path=db_path)
    # If custom database folder given.
    if args.custom_db:
        seq_motifs_db_file, str_motifs_db_file, rbp2ids_file = specify_custom_motif_db(args.custom_db)
        motif_db_str = "custom"

    """
    Get ID mappings

    name2ids_dic:
    RBP name -> motif IDs mapping
    id2type_dic:
    motif ID -> motif type (cm, meme_xml)
    id2org_dic (ignore for now):
    motif ID -> organism ID (so far only "human")

    """
    name2ids_dic, id2type_dic = benchlib.get_rbp_id_mappings(rbp2ids_file)
    # Motif ID -> RBP name (== RBP ID) mapping.
    id2name_dic = {}
    c_motif_ids = 0
    for rbp_id in name2ids_dic:
        for motif_id in name2ids_dic[rbp_id]:
            c_motif_ids += 1
            id2name_dic[motif_id] = rbp_id

    print("")
    print("Motif database: %s" %(motif_db_str))
    print("# RBP IDs:      %i" %(len(name2ids_dic)))
    print("# motif IDs:    %i" %(c_motif_ids))
    print("")
    print("rbp_id\t#_motifs")
    for rbp_id in name2ids_dic:
        c_rbp_motifs = len(name2ids_dic[rbp_id])
        print("%s\t%i" %(rbp_id, c_rbp_motifs))
    print("")


################################################################################

def main_dist(args):
    """
    Plot nt distribution at crosslink (CL) positions.

    """

    print("Running for you in DIST mode ... ")

    assert os.path.exists(args.in_sites), "--in file \"%s\" not found" % (args.in_sites)
    assert args.ext_up_down >= 0 and args.ext_up_down <= 100, "please use reasonable --ext (>= 0 AND <= 100)"

    # Check --in BED format.
    benchlib.bed_check_format(args.in_sites)

    """
    Output folders + files.

    """
    if not os.path.exists(args.out_folder):
        os.makedirs(args.out_folder)

    filtered_sites_bed = args.out_folder + "/in_sites.filtered.bed"
    filtered_sites_fa = args.out_folder + "/in_sites.filtered.fa"
    motif_plot_out = args.out_folder + "/nt_dist_zero_pos.png"
    if os.path.exists(motif_plot_out):
        os.remove(motif_plot_out)
    if args.plot_pdf:
        motif_plot_out = args.out_folder + "/nt_dist_zero_pos.pdf"
        if os.path.exists(motif_plot_out):
            os.remove(motif_plot_out)

    """
    Get chromosome IDs from --genome.
    """
    print("Get --genome FASTA headers ... ")
    chr_ids_dic = benchlib.get_fasta_headers(args.in_genome)

    # Filter / extend --in BED.
    print("Preprocess --in sites ... ")
    reg_stats_dic = benchlib.bed_extend_bed(args.in_sites, filtered_sites_bed,
                                          ext_lr=args.ext_up_down,
                                          cp_mode=args.cp_mode,
                                          remove_dupl=True,
                                          chr_ids_dic=chr_ids_dic)

    print("# --in regions pre-filtering:  ", reg_stats_dic["c_in"])
    print("# --in regions post-filtering: ", reg_stats_dic["c_out"])
    print("# regions with invalid chr_id: ", reg_stats_dic["c_chr_filter"])
    print("# duplicated regions removed:  ", reg_stats_dic["c_dupl_filter"])
    assert reg_stats_dic["c_out"], "no --in BED sites remain after chromosome ID filtering"

    """
    Calculate effective size of genomic regions.
    
    """
    print("Calculate effective genomic region size ... ")
    eff_reg_size = benchlib.get_uniq_gen_size(filtered_sites_bed)


    print("Called region length sum:      ", reg_stats_dic["reg_len_sum"])
    print("Effective region length sum:   ", eff_reg_size)

    """
    Get genomic region sequences from --genome.

    Output FASTA header format:
    >chr8:9772198-9772297(+)

    No need to convert sequences to uppercase, as FIMO works on both 
    lower- and uppercase (as long as DNA / RNA is set correct).

    """

    print("Extract sequences from --genome ... ")
    benchlib.bed_extract_sequences_from_fasta(filtered_sites_bed, 
                                              args.in_genome, filtered_sites_fa,
                                              print_warnings=True)


    """
    Get FASTA sequences and sequence lengths.
    """

    out_seqs_dic = benchlib.read_fasta_into_dic(filtered_sites_fa,
                                       dna=True,
                                       all_uc=True,
                                       id_check=True,
                                       empty_check=False,
                                       skip_n_seqs=False)

    assert out_seqs_dic, "no sequences extracted from FASTA file for --in BED sites. Make sure to use compatible FASTA/BED files!"

    # Effective number of regions used for motif search.
    c_regions = len(out_seqs_dic)

    """
    Construct positional probabilty matrix.
        
    """

    # Expected region size.
    exp_reg_len = args.ext_up_down*2 + 1

    print("Create position probability matrix ... ")
    # Get position probability matrix for plotting.
    ppm = benchlib.make_pos_freq_matrix(out_seqs_dic, 
                         exp_len=exp_reg_len,
                         report=True,
                         to_ppm=True)


    print("Plot distribution ... ")
    benchlib.plot_nt_distribution_zero_pos(ppm, args.ext_up_down,
                                           plot_out=motif_plot_out)


    print("")
    print("Filtered input regions .bed:\n%s" %(filtered_sites_bed))
    print("Filtered input regions .fa:\n%s" %(filtered_sites_fa))
    print("Distribution plot file:\n%s" %(motif_plot_out))
    print("")

    # Take out the trash.
    # if os.path.exists(filtered_sites_bed):
    #     os.remove(filtered_sites_bed)
    # if os.path.exists(filtered_sites_fa):
    #     os.remove(filtered_sites_fa)


################################################################################

def main_compare(args):
    """
    Compare and report different rbpbench motif search results.

    """

    print("Running for you in COMPARE mode ... ")

    """
    Check / read in input --in data.

    """
    in_files = []
    for data in args.data_in:
        if os.path.isdir(data):
            rbp_stats_file = data + "/rbp_hit_stats.tsv"
            motif_stats_file = data + "/motif_hit_stats.tsv"
            assert os.path.exists(rbp_stats_file), "RBP stats file %s not found. Please provide valid rbpbench search/batch output folder via --in" %(rbp_stats_file)
            assert os.path.exists(motif_stats_file), "motif stats file %s not found. Please provide valid rbpbench search/batch output folder via --in" %(motif_stats_file)
            in_files.append(rbp_stats_file)
            in_files.append(motif_stats_file)
        elif os.path.isfile(data):
            in_files.append(data)
        else:
            assert False, "--in argument \"%s\" neither folder nor a file. Please provide rbpbench search/batch output folder or RBP/motif stats files" %(data)

    assert in_files, "no --in files read in from given --in locations. Please provide valid rbpbench search/batch output folder or RBP/motif stats files"

    file_check_dic = {}
    for in_file in in_files:
        assert in_file not in file_check_dic, "--in file %s given > 1. Please provide each file only once" %(in_file)
        file_check_dic[in_file] = 1
    
    """
    Read in RBP/motif stats data.

    rbp_stats_dic:
    internal_id -> RBPStats object

    motif_stats_dic:
    internal_id -> MotifStats object

    """
    rbp_stats_dic = {}
    motif_stats_dic = {}

    for in_file in in_files:
        type = benchlib.check_report_in_file(in_file)
        if type == "rbp_stats":
            benchlib.read_in_rbp_stats(in_file, rbp_stats_dic=rbp_stats_dic)
        elif type == "motif_stats":
            benchlib.read_in_motif_stats(in_file, motif_stats_dic=motif_stats_dic,
                                         store_uniq_only=True)
        else:
            assert False, "invalid --in file encountered (%s). Please provide valid rbpbench search/batch output folder or RBP/motif stats files" %(in_file)

    assert rbp_stats_dic, "No RBP stats read in from --in files. Please provide valid (non-empty) rbpbench search/batch output folder or RBP/motif stats files"
    assert motif_stats_dic, "No motif stats read in from --in files. Please provide valid (non-empty) rbpbench search/batch output folder or RBP/motif stats files"
    c_rbp_stats = len(rbp_stats_dic)
    c_motif_stats = len(motif_stats_dic)
    assert c_rbp_stats == c_motif_stats, "# RBP stats != # motif stats. Please provide RBP/motif stats files in pairs"
    for internal_id in rbp_stats_dic:
        assert internal_id in motif_stats_dic, "RBP stats internal_id %s not found in motif stats files. Please provide matching RBP/motif stats files" %(internal_id)

    print("# RBP stats:  ", c_rbp_stats)
    print("# motif stats:", c_motif_stats)

    """
    Output files.

    """
    if not os.path.exists(args.out_folder):
        os.makedirs(args.out_folder)


    """
    Get data_id, method_id, rbp_id infos.
    Depending on whether combinations are present, different statistics can 
    be produced.

    3 types of comparions:
    1) between different methods (same rbp_id,data_id,motif_db)
        Table (some peak region dataset stats) between methods

        Bar plot % of regions with motifs
        Bar plot %
        Venn diagram motif
    2) between different RBPs on same dataset (so same data_id,
    and c_regions,mean_reg_len,median_reg_len,min_reg_len,max_reg_len,called_reg_size)
        basically reporting output of rbpbench search (could also be made as html output of rbpbench search!)
    3) between different datasets (same rbp_id,method_id,motif_db)

    Only do 1) 3) here, 2) can be done in search mode!
        
    for 1) kennzahlen:
    perc_uniq_motif_nts_cal_reg	perc_uniq_motif_nts_eff_reg	uniq_motif_hits_cal_1000nt	uniq_motif_hits_eff_1000nt


    data_id,method_id,motif_db,rbp_id,internal_id
    k562_eclip,dewseq_w100_s5,human_v0.1,PUM1,XRgmwD56
    k562_eclip,dewseq_w100_s5,human_v0.1,PUM2,ZzLuEZR9
    k562_eclip,clipper_idr,human_v0.1,PUM1,GeR1WaFK
    k562_eclip,clipper_idr,human_v0.1,PUM2,fEag63xM

    MotifStats.hit_id : chr:s-e(+),motif_id

    compare_methods_dic: {'k562_eclip,human_v0.1,PUM1': [['clipper_idr', 'GeR1WaFK', 'PUM1', 'k562_eclip', 'human_v0.1'], 
    ['dewseq_w100_s5', 'aErgL-gv', 'PUM1', 'k562_eclip', 'human_v0.1']], 
    'k562_eclip,human_v0.1,PUM2': [['clipper_idr', 'fEag63xM', 'PUM2', 'k562_eclip', 'human_v0.1'], 
    ['dewseq_w100_s5', 'ZzLuEZR9', 'PUM2', 'k562_eclip', 'human_v0.1']]}

    Single run, so same method ID, changing comp_ids:
    k562_eclip,human_v0.1,PUM1
    k562_eclip,human_v0.1,PUM2
    k562_eclip,human_v0.1,SLBP

    So we would need new comp_id:
    k562_eclip,human_v0.1,clipper_idr
    And variable ID will be rbp_id
    
    change to dic of dic 
    clipper_idr,human_v0.1,PUM1 -> k562_eclip -> GeR1WaFK
    

    """
    compare_methods_dic = {}
    compare_datasets_dic = {}

    for internal_id in rbp_stats_dic:
        data_id = rbp_stats_dic[internal_id].data_id
        method_id = rbp_stats_dic[internal_id].method_id
        rbp_id = rbp_stats_dic[internal_id].rbp_id
        motif_db = rbp_stats_dic[internal_id].motif_db
        comp_id = "%s,%s,%s" %(data_id, motif_db, rbp_id) # comparison ID (i.e. what is fixed).
        if comp_id not in compare_methods_dic:
            compare_methods_dic[comp_id] = {}
            compare_methods_dic[comp_id][method_id] = internal_id
        else:
            if method_id not in compare_methods_dic[comp_id]:
                compare_methods_dic[comp_id][method_id] = internal_id
            else:
                assert False, "data supplied via --in contains a combination twice (data_id:%s,rbp_id:%s,motif_db:%s,method_id:%s). Please provide unique combinations for method comparison" %(data_id, rbp_id, motif_db, method_id)
                # compare_methods_dic[comp_id][method_id].append(internal_id)
        # Dataset ID based dict of dicts.
        comp_id = "%s,%s,%s" %(method_id, motif_db, rbp_id)
        if comp_id not in compare_datasets_dic:
            compare_datasets_dic[comp_id] = {}
            compare_datasets_dic[comp_id][data_id] = internal_id
        else:
            if data_id not in compare_datasets_dic[comp_id]:
                compare_datasets_dic[comp_id][data_id] = internal_id
            else:
                assert False, "data supplied via --in contains a combination twice (data_id:%s,rbp_id:%s,motif_db:%s,method_id:%s). Please provide unique combinations for dataset comparison" %(data_id, rbp_id, motif_db, method_id)
                # compare_datasets_dic[comp_id][data_id].append(internal_id)

    # print("compare_methods_dic:", compare_methods_dic)
    # print("compare_datasets_dic:", compare_datasets_dic)

    # Binomial coefficient.
    from math import comb 

    # How much method comparisons?
    c_method_comps = 0
    for comp_id in compare_methods_dic:
        c_methods = len(compare_methods_dic[comp_id])
        c_method_comps += comb(c_methods, 2)

    print("# of method combinations:", c_method_comps)

    # How much dataset comparisons?
    c_data_comps = 0
    for comp_id in compare_datasets_dic:
        c_data = len(compare_datasets_dic[comp_id])
        c_data_comps += comb(c_data, 2)

    print("# of data combinations:", c_data_comps)

    if not c_method_comps and not c_data_comps:
        assert False, "--in data does not contain any dataset or method combinations. Please provide combinations for method or dataset comparison"

    """
    Create comparison statistics and HTML report.

    """

    html_report_out = args.out_folder + "/" + "report.rbpbench_compare.html"
    if args.plot_abs_paths:
        html_report_out = os.path.abspath(args.out_folder) + "/" + "report.rbpbench_compare.html"

    plots_subfolder = "html_report_plots"
    benchlib_path = os.path.dirname(benchlib.__file__)

    # Generate report.
    benchlib.compare_generate_html_report(compare_methods_dic, 
                                          compare_datasets_dic,
                                          rbp_stats_dic, motif_stats_dic,
                                          args.out_folder, benchlib_path,
                                          html_report_out=html_report_out,
                                          plot_abs_paths=args.plot_abs_paths,
                                          sort_js_mode=args.sort_js_mode,
                                          plots_subfolder=plots_subfolder)

    """
    Output comparison stats.

    """

    comp_stats_tsv_out = args.out_folder + "/" + "comparison_stats.rbpbench_compare.tsv"
    motif_hits_tsv_out = args.out_folder + "/" + "motif_hits.rbpbench_compare.tsv"
    motif_hits_bed_out = args.out_folder + "/motif_hits.rbpbench_compare.bed"

    OUTCS = open(comp_stats_tsv_out, "w")
    outcs_header = "combined_id\tmethod_id\tdata_id\tmotif_db\trbp_id\tc_regions\tc_uniq_motif_hits\t"
    outcs_header += "perc_reg_with_hits\tperc_uniq_motif_nts_eff_reg\tuniq_motif_hits_cal_1000nt\n"
    OUTCS.write(outcs_header)

    # Method ID comparisons.
    for comp_id, method_dic in sorted(compare_methods_dic.items()):
        if len(method_dic) < 2:
            continue
        for method_id in method_dic:
            int_id = compare_methods_dic[comp_id][method_id]
            data_id = rbp_stats_dic[int_id].data_id
            rbp_id = rbp_stats_dic[int_id].rbp_id
            motif_db = rbp_stats_dic[int_id].motif_db
            c_regions = rbp_stats_dic[int_id].c_regions
            c_uniq_motif_hits = rbp_stats_dic[int_id].c_uniq_motif_hits
            perc_reg_with_hits = rbp_stats_dic[int_id].perc_reg_with_hits
            perc_uniq_motif_nts_eff_reg = rbp_stats_dic[int_id].perc_uniq_motif_nts_eff_reg
            uniq_motif_hits_cal_1000nt = rbp_stats_dic[int_id].uniq_motif_hits_cal_1000nt
            outcs_line = comp_id + "\t"
            outcs_line += method_id + "\t"
            outcs_line += data_id + "\t"
            outcs_line += motif_db + "\t"
            outcs_line += rbp_id + "\t"
            outcs_line += str(c_regions) + "\t"
            outcs_line += str(c_uniq_motif_hits) + "\t"
            outcs_line += str(perc_reg_with_hits) + "\t"
            outcs_line += str(perc_uniq_motif_nts_eff_reg) + "\t"
            outcs_line += str(uniq_motif_hits_cal_1000nt) + "\n"
            OUTCS.write(outcs_line)

    # Data ID comparisons.
    for comp_id, data_dic in sorted(compare_datasets_dic.items()):
        if len(data_dic) < 2:
            continue
        for data_id in data_dic:
            int_id = compare_datasets_dic[comp_id][data_id]
            method_id = rbp_stats_dic[int_id].method_id
            rbp_id = rbp_stats_dic[int_id].rbp_id
            motif_db = rbp_stats_dic[int_id].motif_db
            c_regions = rbp_stats_dic[int_id].c_regions
            c_uniq_motif_hits = rbp_stats_dic[int_id].c_uniq_motif_hits
            perc_reg_with_hits = rbp_stats_dic[int_id].perc_reg_with_hits
            perc_uniq_motif_nts_eff_reg = rbp_stats_dic[int_id].perc_uniq_motif_nts_eff_reg
            uniq_motif_hits_cal_1000nt = rbp_stats_dic[int_id].uniq_motif_hits_cal_1000nt
            outcs_line = comp_id + "\t"
            outcs_line += method_id + "\t"
            outcs_line += data_id + "\t"
            outcs_line += motif_db + "\t"
            outcs_line += rbp_id + "\t"
            outcs_line += str(c_regions) + "\t"
            outcs_line += str(c_uniq_motif_hits) + "\t"
            outcs_line += str(perc_reg_with_hits) + "\t"
            outcs_line += str(perc_uniq_motif_nts_eff_reg) + "\t"
            outcs_line += str(uniq_motif_hits_cal_1000nt) + "\n"
            OUTCS.write(outcs_line)

    OUTCS.close()


    """
    Output motif intersection stats (used for Venn diagrams).

    """

    OUTMH = open(motif_hits_tsv_out, "w")
    outmh_header = "combined_id\tmotif_hit_id\tmethod_data_ids_with_hit\n"
    OUTMH.write(outmh_header)
    OUTBED = open(motif_hits_bed_out, "w")

    # Method ID comparisons.
    for comp_id, method_dic in sorted(compare_methods_dic.items()):
        if len(method_dic) < 2:
            continue
        int_ids = []
        method_ids = []
        for method_id, int_id in sorted(method_dic.items()):
            int_ids.append(int_id)
            method_ids.append(method_id)

        # Motif Hit ID (chr_id:gen_s-gen_e(strand),motif_id) to method IDs sporting this hit.
        hid2mids_dic = {}
        mid2c_dic = {}

        for idx, int_id in enumerate(int_ids):
            mid = method_ids[idx]
            for motif_stats in motif_stats_dic[int_id]:  # motif_stats instance of MotifStats object.
                hid = motif_stats.hit_id
                if hid in hid2mids_dic:
                    hid2mids_dic[hid].append(mid)
                else:
                    hid2mids_dic[hid] = [mid]
                if mid in mid2c_dic:
                    mid2c_dic[mid] += 1
                else:
                    mid2c_dic[mid] = 1

        # print("Comparison:", comp_id)
        # print("Method ID motif hit counts:")
        # for mid in mid2c_dic:
        #     print(mid, mid2c_dic[mid])


        for hid in hid2mids_dic:
            mids_str = ",".join(hid2mids_dic[hid])
            OUTMH.write("%s\t%s\t%s\n" %(comp_id, hid, mids_str))
            # Also store motif hit in BED format.
            id_elem = benchlib.get_hit_id_elements(hid)
            OUTBED.write("%s\t%s\t%s\t%s;%s;%s\t0\t%s\n" %(id_elem[0], id_elem[1], id_elem[2], id_elem[4], comp_id, mids_str, id_elem[3]))

    # Data ID comparisons.
    for comp_id, data_dic in sorted(compare_datasets_dic.items()):
        if len(data_dic) < 2:
            continue
        int_ids = []
        data_ids = []
        for data_id, int_id in sorted(data_dic.items()):
            int_ids.append(int_id)
            data_ids.append(data_id)

        # Motif Hit ID (chr_id:gen_s-gen_e(strand),motif_id) to data IDs sporting this hit.
        hid2dids_dic = {}
        did2c_dic = {}

        for idx, int_id in enumerate(int_ids):
            did = data_ids[idx]
            for motif_stats in motif_stats_dic[int_id]:
                hid = motif_stats.hit_id
                if hid in hid2dids_dic:
                    hid2dids_dic[hid].append(did)
                else:
                    hid2dids_dic[hid] = [did]
                if did in did2c_dic:
                    did2c_dic[did] += 1
                else:
                    did2c_dic[did] = 1

        # print("Comparison:", comp_id)
        # print("Data ID motif hit counts:")
        # for did in did2c_dic:
        #     print(did, did2c_dic[did])

        for hid in hid2dids_dic:
            dids_str = ",".join(hid2dids_dic[hid])
            OUTMH.write("%s\t%s\t%s\n" %(comp_id, hid, dids_str))
            # Also store motif hit in BED format.
            id_elem = benchlib.get_hit_id_elements(hid)
            OUTBED.write("%s\t%s\t%s\t%s;%s;%s\t0\t%s\n" %(id_elem[0], id_elem[1], id_elem[2], id_elem[4], comp_id, dids_str, id_elem[3]))

    OUTMH.close()
    OUTBED.close()

    """
    Inform about outputs.

    """
    print("")
    print("OUTPUT FILES")
    print("============")
    print("")
    print("Comparison stats .tsv:\n%s" %(comp_stats_tsv_out))
    print("Motif hit stats .tsv:\n%s" %(motif_hits_tsv_out))
    print("Motif hits .bed:\n%s" %(motif_hits_bed_out))
    print("Motif search comparison report .html:\n%s" %(html_report_out))
    print("")


################################################################################

if __name__ == '__main__':
    # Setup argparse.
    parser = setup_argument_parser()
    # Print help if no parameter is set.
    if len(sys.argv) < 2:
        parser.print_help()
        sys.exit()
    # Read in command line arguments.
    args = parser.parse_args()

    # Show some banner.
    print(benchlib.print_some_banner())

    # Run selected mode.
    if args.which == 'search':
        main_search(args)
    elif args.which == 'batch':
        main_batch(args)
    elif args.which == 'searchseq':
        main_searchseq(args)
    elif args.which == 'searchregex':
        main_searchregex(args)
    elif args.which == 'searchlong':
        main_searchlong(args)
    elif args.which == 'searchcorna':
        main_searchcorna(args)
    elif args.which == 'searchmrna':
        main_searchmrna(args)
    elif args.which == 'optex':
        main_optex(args)
    elif args.which == 'info':
        main_info(args)
    elif args.which == 'dist':
        main_dist(args)
    elif args.which == 'compare':
        main_compare(args)
